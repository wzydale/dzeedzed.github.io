<!DOCTYPE html>
<html>

  <style>
      p, ul {
        font-size: 1.25rem;
      }
  </style>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">



  <title>CS 246 - Object-Oriented Software Development</title>
  <meta name="description" content="CS 246 - Object-Oriented Software DevelopmentInstructor: Brad LushmanSection: 001Location: MC 4045Time: Tuesdays and Thursdays 10:00am - 11:20amTutorials: MC...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://dzed.me/notes/2016/05/02/Cs-246.html">
  <link rel="alternate" type="application/rss+xml" title="Dadi "D.Z." Zhang" href="http://dzed.me/feed.xml">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href='https://fonts.googleapis.com/css?family=Karma:500' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>

</head>


  <body>

    <!--
    <link href="/css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link href="/css/style.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link href="/css/homepage.css" type="text/css" rel="stylesheet"/>
  <link href="/css/genericons/genericons.css" type="text/css" rel="stylesheet"/>
 -->
<!-- <header class="site-header">

    <nav class="white site-header" role="navigation">
      <div class="nav-wrapper container">
        <a id="logo-container" href="" class="brand-logo">Dadi "DZ" Zhang</a>

        <ul class="right hide-on-med-and-down">
          
            
            <a class="page-link" href="/blog.html">Blog</a>
            
          
            
          
            
            <a class="page-link" href="/dreamlist.html">Dream List</a>
            
          
            
          
            
          
            
            <a class="page-link" href="/gotutorials.html">Go Tutorials</a>
            
          
            
          
            
          
            
          
            
          
            
            <a class="page-link" href="/notes.html">Notes</a>
            
          
            
            <a class="page-link" href="/projects.html">Projects</a>
            
          
        </ul>
      </div>
    </nav>

</header> -->

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href='https://fonts.googleapis.com/css?family=Karma:500' rel='stylesheet' type='text/css'>

<style>

/* Fade */
.hvr-fade {
  display: inline-block;
  vertical-align: middle;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
  box-shadow: 0 0 1px rgba(0, 0, 0, 0);
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
  -moz-osx-font-smoothing: grayscale;
  overflow: hidden;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
  -webkit-transition-property: color, background-color;
  transition-property: color, background-color;
}
.hvr-fade:hover, .hvr-fade:focus, .hvr-fade:active {
  background-color: black;
  color: white;
}

.page-link {
    padding-top: 17px;
    padding-bottom: 17px;
    padding-right: 14px;
    padding-left: 14px;
    margin-left: -24.5px;
    margin-right: -24.5px;
}


.site-title:hover {
    text-decoration: none;
}

.page-link:hover {
    text-decoration: none;
}

.site-title {
  font-family: "Raleway", serif;
  font-size: 2rem;
}

.trigger a {
  font-family: "Raleway", serif;
}

</style>

<header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Dadi "D.Z." Zhang</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">


      <div class="trigger">
        
          
          <a class="page-link hvr-fade" href="/blog.html">Blog</a>
          
        
          
        
          
          <a class="page-link hvr-fade" href="/dreamlist.html">Dream List</a>
          
        
          
        
          
        
          
          <a class="page-link hvr-fade" href="/gotutorials.html">Go Tutorials</a>
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link hvr-fade" href="/notes.html">Notes</a>
          
        
          
          <a class="page-link hvr-fade" href="/projects.html">Projects</a>
          
        
          <a class="page-link hvr-fade" href="/resume/resume.pdf">R&eacutesum&eacute</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">CS 246 - Object-Oriented Software Development</h1>
    <p class="post-meta">
    

    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <div class="highlighter-rouge"><pre class="highlight"><code>CS 246 - Object-Oriented Software Development
Instructor: Brad Lushman
Section: 001
Location: MC 4045
Time: Tuesdays and Thursdays 10:00am - 11:20am
Tutorials: MC 4060 Wednesdays 1:30pm - 2:20pm
Term: Spring 2016
</code></pre>
</div>

<p><strong>Shoutout to Brian Forbes, <a href="http://www.yufeiyang.me">Steven Yang</a>, and <a href="http://ziqizhou.com">Ziqi Zhou</a>!</strong></p>

<h2 id="may-3-2016---lecture-1">May 3, 2016 - Lecture 1</h2>

<p><strong>Grading Scheme</strong></p>

<ul>
  <li>Assignments - 0(A0) 7 7 7 7 12(project) = 40%</li>
  <li>Midterm (4:30pm - 6:20pm, June 23 (Th), 2016) = 20%</li>
  <li>Final = 40%</li>
</ul>

<p>This course requires you to work in Linux. There are several options:</p>

<ol>
  <li>Lab machines</li>
  <li>Install Linux on your own machines</li>
  <li>Make SSH connection to school machines (Use Putty (putty.exe) on Windows, winscp for file transfer, XMing for Xwindows)</li>
  <li>Download cygwin - Linux-like environment for Windows</li>
  <li>Get a Mac</li>
</ol>

<p><strong>4 Modules in this Course:</strong></p>

<ul>
  <li>Linux Shell (2 weeks)</li>
  <li>C++ Language, C++14 (10 weeks)</li>
  <li>Tools</li>
  <li>Software Engineering (design etc.)</li>
</ul>

<p>“Homework”: Go on Piazza -&gt; Linux Reference Sheet -&gt; Save and print</p>

<h2 id="module-1-linux-shell">Module 1: Linux Shell</h2>

<p>A shell is an interface to the operating system, i.e. how we get the OS to do things (run programs, manage files etc.). There are two kinds of shells: graphical (with icons and clicking) and the command line. The shell we will use is Bash. Check if you are using Bash, login to shell and type in:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ echo $0
</code></pre>
</div>

<p>It should return “bash”.</p>

<p><strong>Linux file system: working with files</strong></p>

<p><strong>cat</strong> - short for concatenate; display contents of a file (e.g. cat user/share/dict/words). In Linux, a directory is considered a special kind of file</p>

<p><strong>ls</strong> - list files in the current directory (non-hidden files)</p>

<p><strong>ls -a</strong> - list all files (including hidden; hidden files start with a “.”)</p>

<p><strong>pwd</strong> - print current directory (pwd = print working directory)</p>

<p>What happens when we only type in “cat”? It just kind of sits there, waiting for input. It’s kinda like a parrot, repeating what you typed in. If we can capture the output into a file…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ cat &gt; output.txt
</code></pre>
</div>

<p>It would capture the input. NOT RECOMMENDED: ^C. It would prevent cat from doing clean-up. Let it finish on its own: ^D at the beginning of a line sends an “EOF” signal to cat.</p>

<p>One greater than sign replaces, two appends.<br />
In general, command args &gt; file
executes command args + captures the output in file -&gt; called <strong>output redirection</strong>.</p>

<p>Using less than sign, takes in input from the file.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ cat &lt; output.txt
</code></pre>
</div>

<p>The line above displays the file. Seems to be equivalent to what we have before. Are these two things the same? NO. The reason is very important:</p>

<ul>
  <li>
    <p>cat input.txt -&gt; passes the NAME input.txt to cat as an argument. Cat opens input.txt and displays its contents</p>
  </li>
  <li>
    <p>cat &lt; input.txt -&gt; the shell opens the file and passes the contents to cat IN PLACE of keyboard input</p>
  </li>
</ul>

<p><strong>wc</strong> - word count, displays numbers of lines, words, and characters of a file</p>

<p><strong>cat *.txt</strong> - *.txt globbing pattern -&gt; matches any sequence of characters (the shell finds all files that mathch the pattern)</p>

<p><strong>cat &lt; *.txt</strong> - ERROR! The shell will only attach one file to cat’s input stream</p>

<p>Many (but not all) commands take both kinds of inputs:</p>

<p><strong>cat &lt; input.txt &gt; output.txt</strong> - sends chars from input.txt to output.txt; effectively a copy-paste action</p>

<p>Every process is attached to 3 streams. Stdin goes into the program, stdout and stderr come out of the program. Stdin -&gt; program -&gt; stdout and stderr. By default, stdin = keyboard, stdout, stderr = screen.
&lt; connects stdin to file, &gt; connects stdout to file, 2&gt; stdrr. Stderr separates output stream from error messages, so that output error messages can go to different places, and that error messages don’t cut/block output files.</p>

<p>Also, stdout may be <strong>buffered</strong>. System may assemble characters before displaying. However, stderr isn’t buffered, because user needs to see error messages immediately.</p>

<p><strong>Pipes</strong>: Make one program’s output(stdout) another program’s input(stdin). Example: How many words occur in the first 20 lines of sample.txt?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>head -n file
</code></pre>
</div>

<p>gives the first n lines of file</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wc -w
</code></pre>
</div>

<p>counts words (just print the word count)</p>

<p>so</p>

<div class="highlighter-rouge"><pre class="highlight"><code>head -20 sample.txt | wc -w
</code></pre>
</div>

<table>
  <tbody>
    <tr>
      <td>Here,</td>
      <td>(the pipe symbol) makes the output of the command before it the input of the command after it.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h2 id="may-4-2016---tutorial-1">May 4, 2016 - Tutorial 1</h2>

<p>To zip your assignment files, do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>zip (directory where your files are).zip *
</code></pre>
</div>

<p>in the directory where the files are.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>marmoset_submit cs246 (question, e.g a0) (file you want to submit, zipped)
</code></pre>
</div>

<p>is how you submit assignments to Marmoset.</p>

<p><br /></p>

<h2 id="may-5-2016---lecture-2">May 5, 2016 - Lecture 2</h2>

<p>Suppose we have files words1.txt, words2.txt…, and each of them has one word per line. We want: A duplicate-free list of all the words used in any of these files</p>

<p>We need the following:</p>

<ul>
  <li>sort - sorts lines (man: Write sorted concatenation of all FILES(s) to standard output)</li>
  <li>uniq - remove consecutive duplicate lines from input (man: filter adjacent matching lines from INPUT, writing to OUTPUT)</li>
</ul>

<p>One possibility:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat words*.txt | uniq
</code></pre>
</div>

<p>What’s the problem with this? We must sort our input first, because for aabaacd, it would produce abacd, with duplicates.</p>

<p>This should work:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat words*.txt | sort | uniq
</code></pre>
</div>

<p>Sort it first, then call uniq. But there’s still a problem: it’s way too inefficient, beacuse it cat(s) all the files together FIRST, and then sorts it.</p>

<p>This is better:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sort words*.txt | uniq
</code></pre>
</div>

<p>Q: Is it possible to use the output onf one program as a <strong>parameter</strong> to another?</p>

<p>Yes. E.g.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo "Today is $(date) and I am $(whoami)"
</code></pre>
</div>

<p>The shell executes date and whoami, and subsitutes the results into the command line.</p>

<p>WARNING:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo 'Today is $(date) and I am $(whoami)'
</code></pre>
</div>

<p>This will print the <strong>LITERAL</strong> interpretation, i.e. Today is $(date) and I am $(whoami)<br />
Single quotes do not execute the substitution.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo "$(ls words*.txt)"
</code></pre>
</div>

<p>prints a list of names of the text files:<br />
words1.txt<br />
words2.txt<br />
…</p>

<p><strong>Pattern Matching in Text Files</strong><br />
Use egrep (extended global regular expression print) = grep -E</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep pattern file
</code></pre>
</div>

<p>returns all lines that contain the pattern.</p>

<p>E.g. print lines that contain “cs246”</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep cs246 index.html
</code></pre>
</div>

<p>What about “cs246” OR “CS246”?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep "cs246|CS246" index.html
</code></pre>
</div>

<p>The vertical bar (|) means “OR”, and the double quotes prevent the shell from interpreting the bar as a pipe.</p>

<p>We can use parentheses to group subexpressions together:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep "(cs|CS)246" index.html
</code></pre>
</div>

<p>The patterns that egrep understands are called <strong>regular expressions</strong>. NOT globbing patterns.</p>

<p>“(c|C)(s|S)246” is equivalent to “[cC][sS]246”</p>

<p><strong>[…]</strong> syntax says to match any SINGLE character in he square brackets. (a|1|c|2) is equivalent to [a1c2].</p>

<p><strong>[^…]</strong> matches any 1 character not in the square brackets.</p>

<p>“[cC][sS] ?246” allows for an optional space before the 246. ? syntax says to match 0 or 1 occurrences of the preceding expression.</p>

<p>* syntax which matches 0 or more of the preceding expression. So (cs)*246 -&gt; 246, cs246, cscs246, cscscs246…<br />
cs(cs)*246 matches at least one cs at the front (eliminating the zero case)</p>

<p>(cs)+246 is equivalent to cs(cs)*246. The + syntax matches 1 or more of the preceding expression.</p>

<p>.* will match any sequence of characters</p>

<p>.+ will match any non-empty sequence of characters</p>

<p>“cs *246” matches any string starting with cs, followed by any string, followed by 246.</p>

<p>^ matches beginning of line</p>

<p>$ matches the end of line</p>

<p>^cs246 line starts with cs246</p>

<p>cs246$ line ends with cs246</p>

<p>Want all lines of even length</p>

<p>^(..)*$</p>

<h1 id="the-other-section">The Other Section</h1>

<p>Pipes allow us to hook the stdin of one program to the stdout of another. This is done using the pipe character | between commands</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cmd1 args1 | cmd2 args2
</code></pre>
</div>

<p><strong>Regex Rules</strong>:</p>

<ul>
  <li>Can use parentheses for a sub-pattern</li>
  <li>Can use square brackets to match any one character in the square brackets</li>
  <li>[^…] matches any one character EXCEPT those in the square brackets</li>
  <li>A ? after a pattern or character represents 0 or 1 of that pattern/character</li>
  <li>A * after a pattern/character represents 0 or more of that pattern/character</li>
  <li>A + “1 or more”</li>
  <li>. matches any SINGLE character</li>
  <li>^ and $ match the start and end of line respectively</li>
</ul>

<p>E.g.<br />
.* - anything<br />
.+ - non-empty string<br />
^.+$ - all non-empty lines<br />
^.*$ - all lines</p>

<p>^(..)*$ - grabs all lines with even number of characters</p>

<p><strong>Permissions</strong></p>

<ul>
  <li>ls -l gives the long form listing of the files in the current directory</li>
  <li>First 3 bits: Owner r-read w-write x-execute</li>
  <li>Middle 3 bits: Group</li>
  <li>Last 3 bits: Others</li>
  <li>r: ordinary files-&gt; can be read, directories-&gt; contents can be read, globbing workds, ls works</li>
  <li>w: ordinary files-&gt;can be modified, directories-&gt; contents can be modified, add/remove</li>
  <li>x: file’s contents can be executed as a program, directories-&gt;directories can be navigated (can cd into the directory)</li>
</ul>

<p><strong>Changing Permissions</strong></p>

<ul>
  <li>
    <p>to change permissions use chmod</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  chmod mode file
</code></pre>
    </div>
  </li>
  <li>mode is broken up to 3 parts - user, operator, and permissions</li>
  <li>user is either u (owner), g (group), o (other), or a (all)</li>
  <li>operator is either + (add), - (remove), = (set exactly)</li>
  <li>permissions are r, w, x</li>
</ul>

<p>E.g.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod o+r filename
</code></pre>
</div>

<p>gives other group read access to the file</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod o-r filename
</code></pre>
</div>

<p>is the reverse</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod a-r filename
</code></pre>
</div>

<p>then nobody can read it</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod u=rwx filename
</code></pre>
</div>

<p>then the owner can do anything with it.</p>

<p><strong>Shell Scripts</strong></p>

<p>A shell script is a file containing sequences of shell commands execueted as a program. For example if we wanted to print the date, current user, current dir.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash (this header tells the OS that this is a Bash script; allows the OS to interpret it the following as bash commands)</span>
date
whoami
<span class="nb">pwd</span>
</code></pre>
</div>

<p>.sh is the standard extension of a bash script, but you can put whatever you want. Don’t forget permissions. Needs to be executable. Use chmod to give it executation rights.</p>

<p><strong>Variables</strong></p>

<ul>
  <li>Variables can be assigned with single equals.</li>
  <li>x=1 (NO SPACES!!!)</li>
  <li>use echo &amp;{x} to grab the value of the variable x (parentheses run what’s inside it in a “subshell”) (curly braces are important: good practice)</li>
</ul>

<p><strong>Shell Script Example</strong></p>

<p>Write a script that takes in a string to check if it is BAD. A string that can be found in a dict is bad.
General format of conditional statements in bash:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>if [ cond ]; then // the square brackets cannot "touch" what's inside
...
elif [ cond ]; then
...
else
...
fi
</code></pre>
</div>

<p><strong>$?</strong> contains the return value of the last-run command.
<strong>$1</strong> retrieves the first parameter</p>

<p>Create a .sh script as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

egrep <span class="s2">"^</span><span class="nv">$1</span><span class="s2">$"</span> /usr/share/dict/words &gt; /dev/null  <span class="c"># /dev/null is where data goes to DIE</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -eq 0 <span class="o">]</span>; <span class="k">then</span> //-eq compares
<span class="nb">echo </span>Bad password
<span class="k">else
</span><span class="nb">echo </span>Maybe not the worst
<span class="k">fi</span>
</code></pre>
</div>

<p>And before you run it,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod u+x goodpass.sh
</code></pre>
</div>

<p>In bash, the pound symbol (#) starts a comment.</p>

<p><br /></p>

<h2 id="may-10-2016---lecture-3">May 10, 2016 - Lecture 3</h2>

<p>Review:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep pattern file
</code></pre>
</div>

<p>prints all lines in file that contain a match to pattern</p>

<p><strong>Shell Scripts Review</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash  #"Shebang line"  </span>
date  
whoami  
<span class="nb">pwd</span>
</code></pre>
</div>

<p>To run the script in the current directory:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./myscript
</code></pre>
</div>

<p><strong>Variables</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>x=1 #NO SPACES  
echo $x #Use $ when fetching the value of a variable
# No $ when setting a var ($ = "fetch the value of")
# Good practice: ${x} - brace brackets, good style
# All vars contain strings, e.g. x is the STRING 1, not the number/int
</code></pre>
</div>

<p>E.g.<br />
    dir = ~/cs246
    echo ${dir}
    /u/bmlushma/cs246 # get the absolute path
    ls ${dir} # contents of cs246</p>

<p>There are some global variables:<br />
    env # environment variables
    echo ${PATH} # list of directories (where the shell looks for programs)</p>

<p>When you type a command, the shell searches the list in order for a matching program.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo * # prints all files in the current directory
echo "*" - suppresses globbing pattern
echo '*' - suppresses globbing pattern
echo "$PATH" # expands the quotes, $-expansion happens
echo '$PATH' # absolutely literally
</code></pre>
</div>

<p><strong>Special Variables for Scripts</strong><br />
    $1, $2, … # command-line arguments</p>

<p>E.g. check whether a word is in the dictionary</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./isItAWord hello

#!/bin/bash

egrep "^$1$" /usr/share/dict/words # prints the word if found, prints nothing if not
</code></pre>
</div>

<p>E.g. a good password is not in the dictionary</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep "^$1$"/usr/share/dict/words &gt; /dev/null # to black hole, suppress output
# we could store the out in a variable
x=$egrep ...
</code></pre>
</div>

<p>Note: every program returns a status code when finished: egrep returns 0 if found, 1 if not found (general convention in UNIX: 0 means success, non-0 means failure)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$? # status of the most recently executed command

if [ $? -eq 0]; then # the first square bracket is the name of a program, and what's inside the square brackets are its arguments
    echo Bad password
else
    echo Maybe a good password
fi
</code></pre>
</div>

<p>We want to verify that the user has inputted the correct number of arguments, and print a usage message if it’s wrong</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

usage<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"usage: </span><span class="nv">$0</span><span class="s2"> password"</span> <span class="c"># $0 is the name of the script/program as it was typed</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>-ne 1 <span class="o">]</span>; <span class="k">then</span> <span class="c"># $# is the number of arguments</span>
    usage
    <span class="nb">exit </span>1
<span class="k">fi

</span>egrep ... <span class="c"># as established above</span>
</code></pre>
</div>

<p>Now this is a good program that can also check if the input is valid.</p>

<p>The general structure of conditional statements is as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>if [ cond ]; then
    ...
elif [ cond ]; then
    ...
else
    ...
fi
</code></pre>
</div>

<p>Comparisons to other conditions: Check the Linux reference sheet</p>

<p><strong>Loops</strong></p>

<p>Loops: print the numbers from 1 to $1</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">x</span><span class="o">=</span>1
<span class="k">while</span> <span class="o">[</span> <span class="nv">$x</span> -le <span class="nv">$1</span> <span class="o">]</span>, <span class="k">do
    </span><span class="nb">echo</span> <span class="nv">$x</span>
    <span class="nv">x</span><span class="o">=</span><span class="k">$((</span>x+1<span class="k">))</span> <span class="c"># $(()) for arithmetic</span>
<span class="k">done</span>
</code></pre>
</div>

<p>Looping over a list, e.g. rename all .cpp to .cc</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="k">for </span>name <span class="k">in</span> <span class="se">\*</span>.cpp; <span class="k">do</span> <span class="c"># for ... in sets the variable to each word in the given list</span>
    mv <span class="k">${</span><span class="nv">name</span><span class="k">}</span> <span class="k">${</span><span class="nv">name</span><span class="p">%cpp</span><span class="k">}</span>cc <span class="c"># value of name, without trailing cpp</span>
<span class="k">done</span>
</code></pre>
</div>

<p>e.g. how many times does word $1 occur in the file $2?</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">x</span><span class="o">=</span>0
<span class="k">for </span>word <span class="k">in</span> <span class="k">$(</span>cat <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span><span class="k">)</span>; <span class="k">do</span> <span class="c">#good idea - enclose vars in double quotes, prevent bad input</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$word</span> <span class="o">==</span> <span class="nv">$1</span> <span class="o">]</span>; <span class="k">then</span> <span class="c">#String equality == instead of -eq</span>
        <span class="nv">x</span><span class="o">=</span><span class="k">$((</span>x+1<span class="k">))</span>
    <span class="k">fi
done
</span><span class="nb">echo</span> <span class="nv">$x</span>
</code></pre>
</div>

<p>e.g. Payday is the last Friday of the month. When is this month’s payday?</p>

<p>2 tasks here: compute date and fomat the answer</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cal | awk '{print $6}' | egrep "[0-9]" | tail -1
</code></pre>
</div>

<p><br /></p>

<h2 id="may-11-2016---tutorial-2">May 11, 2016 - Tutorial 2</h2>

<p>Want: stdout and stderr in the same file</p>

<p>printer » out 2&gt; out # works
  printer &gt; out 2» out #doesn’t work</p>

<p>#Alternatives
  printer &amp;&gt; out
  printer &gt; out 2&gt;&amp;1
  printer 2&gt;out 1&gt;&amp;2</p>

<p>Want: Give the top 10 most commonly used words</p>

<table>
  <tbody>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>head # problem</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>sort</td>
      <td>tail # works</td>
      <td> </td>
    </tr>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>sort -k1,1rn -k2,2</td>
      <td>head # sort takes in arguments -k as key; 1,1 = first character r = reverse order(descending) n = sort in numerical order, 2 break ties</td>
      <td> </td>
    </tr>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>sed ‘s_6<em>12</em>’</td>
      <td>sort</td>
      <td>tail # Use sed to replace 6s with 12s and then sort lexigraphically</td>
    </tr>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>sed ‘s_6<em>12</em>’</td>
      <td>sort -k1,1nr -k2,2</td>
      <td>head</td>
    </tr>
  </tbody>
</table>

<p>egrep:</p>

<p>^ - match beginning of line<br />
$ - match end of a line<br />
^$, ^a$<br />
. - matches any single character<br />
? - matches preceeding pattern 0 or 1 times<br />
* - 0 or more<br />
+ - 1 or more</p>

<p>Note: abc* != (abc)*
ab, abccc, abcccccc, in comparison to abc, abcabc, abcabcabc</p>

<p><br /></p>

<h2 id="may-12-2016---lecture-4">May 12, 2016 - Lecture 4</h2>
<p>Recall: compute payday (last Friday of the month); report nicely</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

answer<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$1</span> -eq 31 <span class="o">]</span>; <span class="k">then</span> <span class="c"># inside a fn - $1, $2 etc are the args to the function</span>
    <span class="nb">echo</span> <span class="s2">"This month: the 31st"</span>
  <span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"This month: the </span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="s2">th"</span>
  <span class="k">fi</span>
<span class="o">}</span>

answer <span class="k">$(</span>cal | awk <span class="s1">'{print $6}'</span> | egrep <span class="s2">"[0-9]"</span> | tail -1<span class="k">)</span> <span class="c"># the whole thing after the dollar sign is ${1}</span>
</code></pre>
</div>

<p>Generalize to any month:</p>

<p>cal June 2016 # gives calendar for June 2016<br />
Want: let payday June 2016 gives June 2016’s payday</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

answer<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$2</span> <span class="o">]</span>; <span class="k">then
    </span><span class="nv">preamble</span><span class="o">=</span><span class="k">${</span><span class="nv">2</span><span class="k">}</span>
  <span class="k">else
    </span><span class="nv">preamble</span><span class="o">=</span><span class="s1">'This month'</span>
  <span class="k">fi

  if</span> <span class="o">[</span> <span class="nv">$1</span> -eq 31 <span class="o">]</span>; <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">preamble</span><span class="k">}</span><span class="s2">'s payday is on the 31st."</span>
  <span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">preamble</span><span class="k">}</span><span class="s2">'s payday is on the </span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="s2">th."</span>
  <span class="k">fi</span>
<span class="o">}</span>

answer <span class="k">$(</span>cal <span class="nv">$1</span> <span class="nv">$2</span> | awk <span class="s1">'{print $6}'</span> | egrep <span class="s2">"[0-9]"</span> | tail -1<span class="k">)</span> <span class="nv">$1</span> <span class="c"># if $1 and $2 are supplied, revert back to previous behaviour</span>
</code></pre>
</div>

<h2 id="software-engineering-testingsaka-qa-lmao">Software Engineering: Testings(aka QA lmao)</h2>

<ul>
  <li>essential part of program development</li>
  <li>ongoing, not just at the end
    <ul>
      <li>begins <strong>BEFORE</strong> coding</li>
      <li>test suites - expected behaviour</li>
    </ul>
  </li>
  <li>NOT debugging - cannot debug without first testing</li>
  <li>cannot guarantee correctness, can only prove wrongness</li>
  <li>ideally, developer + tester should be different people</li>
</ul>

<p><strong>Human Testing</strong> - Humans look over code, find flaws, code inspection, walkthroughs<br />
<strong>Machine Testing</strong> - Run the program on selected input, check against spec, can’t test everything - choose test cases carefully</p>

<p><strong>Black/White/Grey Box Testing</strong>: no/full/some knowledge of program implementation<br />
Start with black box, supplement with white box</p>

<ul>
  <li>various classes of input, e.g. numerical ranges, positive/negative</li>
  <li>Boundaries of valid ranges (edge cases)</li>
  <li>Multiple simulatenous boundaries (corner cases)</li>
  <li>Intuition/Experience (“Ayy I’ve seen programs like that before, better try blah lmao”)</li>
  <li>Extreme cases (e.g. integer overflow; how large can the integer get before it breaks)</li>
</ul>

<p>White box - executes all logical paths through the program</p>

<ul>
  <li>run through the true part and false branch of conditional statements</li>
  <li>every way you can go from start to finish should be tested</li>
  <li>make sure every function you write actually gets called</li>
</ul>

<p><strong>Performance Testing</strong> - Is the program fast enough?<br />
<strong>Regression Testing</strong></p>

<ul>
  <li>Make sure new changes to the program don’t break old tests</li>
  <li>test suites (ALWAYS ADD TESTS; NEVER SUBTRACT), testing scripts</li>
</ul>

<h2 id="module-2-c-ayy">Module 2: C++ (ayy)</h2>

<p>Hello World in C:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main() {
  printf("Hello World!\n");
  return 0;
}
</code></pre>
</div>

<p>Hello World in C++:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;iostream&gt;
using namespace std;

int main() {
  cout &lt;&lt; "Hello World" &lt;&lt; endl;
  return 0;
}
</code></pre>
</div>

<p>Notes:</p>

<ul>
  <li>main MUST return int in C++</li>
  <li>stdio.h, printf still available in C++</li>
  <li>preferred C++ I/O: header <iostream></iostream></li>
</ul>

<p>Output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>std::cout &lt;&lt; ___ &lt;&lt; ____ &lt;&lt; ____  
std::endl = end-of-line
</code></pre>
</div>

<p>Using namespace std lets you say cout and endl instead of std::cout and std::endl</p>

<p>Return statement - returns status code to the shell ($?). If left out, main returns 0</p>

<p><strong>Compiling C++ Programs</strong></p>

<p>On the school Linux environment:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    g++-5 -std=c++14 program.cc -o program
    (-o program is the name of the executable binary (if not specified: a.out))
    // OR
    g++14 program.cc -o program // if you have done A0 and made the alias
    // Run the program by
    ./program
</code></pre>
</div>

<p><strong>Input/Output</strong><br />
  3 IO streams: cout - for printing to stdout, cin - for reading from stdin, cerr - for writing to stderr</p>

<p>Operators: « “put to” - Output, » “get from” - input</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  cerr &lt;&lt; x // x flows to cerr
  cin &gt;&gt; x // input flows to x
  // The operator points in the direction of information flow
</code></pre>
</div>

<p>E.g. Add 2 numbers</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;iostream&gt;
using namespace std;

int main() {
  int x, y;
  cin &gt;&gt; x &gt;&gt; y; // cin ignores whitespace; gets two integers, ignoring whitespace
  cout &lt;&lt; x+y ;
}
</code></pre>
</div>

<p>If the input doesn’t contain an integer next - statement fails, value of the var is undefined</p>

<p>What if the input is exhaustive, before we get two ints? - Same as above</p>

<p>If the read failed: cin.fail() will be TRUE<br />
If we got an EOF: cin.fail() and cin.eof() will be both TRUE; cin.eof() not until the attempted read fails</p>

<p>E.g. Read all ints from stdin, echo one per line to stdout. Stop on bad input or EOF</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int main() {
  int i;
  while(true) {
    cin &gt;&gt; i;
    if (cin.fail()) break;
    cout &lt;&lt; i &lt;&lt; endl;
  }
}
</code></pre>
</div>

<p><br /></p>

<h2 id="may-17-2016---lecture-5">May 17, 2016 - Lecture 5</h2>

<p>E.g. Read all ints from stdin + echo, one per line, to stdout, stop on bad input of EOF</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int main() {
	int i;
	while (true) {
		cin &gt;&gt; i;
		if (cin.fail()) {
			break;
		}
		cout &lt;&lt; i &lt;&lt; endl;
	}
}
</code></pre>
</div>

<p>Recall: if read fails, cin.fail() will be true; if EOF: cin.fail() and cin.eof() both true, but not until the attepted read fails</p>

<p>Note: there is an implicit conversion from cin to bool, so cin can be used as a condition. The conversion is that it’s true if fail/bad/eof bits are clear, or false if fail/bad/eof set</p>

<p>E.g. v2.0</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cin</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// using cin as the condition, means the same thing as the other program
</span>			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Note: » is C’s right bitshift operator; a » b shifts a’s bits to the right by b spots</p>

<p>E.g. 21 » 3; 21 in binary is 10101, push the last 3 digits off the cliff, so it becomes 10 in binary, which is 2; equivalent to dividing by 2 to the b-th power, ignoring remainders</p>

<p>But when the left hand side is cin, this is the “get from” operator</p>

<div class="highlighter-rouge"><pre class="highlight"><code>operator &gt;&gt;
 	// inputs: LHS cin (istream), RHS data (variety of types); output: return cin (istream)
 	// This is why we can write: cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; cin &gt;&gt; x produces cin, x gets populated, and now we get cin &gt;&gt; y &gt;&gt; z, and so on.
</code></pre>
</div>

<p>E.g. v3.0</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// using it as both a condition and populating i
</span>      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>E.g. v4.0</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// changing the break statement into a single while loop
</span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>E.g. read and echo ints until EOF, skip non-integer input</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">eof</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// clears the fail bit, so that cin is ready to read again
</span>      <span class="n">cin</span><span class="p">.</span><span class="n">ignore</span><span class="p">();</span> <span class="c1">// throws away the next character
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>E.g. Reading strings: type std::string (#include <string>)</string></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// skips leading white space;
// stops at whitespace (reads one word)
</span></code></pre>
</div>

<p>What if we want the hvitespace? Use getline(cin, s), it reads from the current position to next newline, into s.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">95</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 95
</span></code></pre>
</div>

<p>What if we want to print a number in hexadecimal?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="mi">95</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="c1">// this will print 95 in hex, 5f
// hex is std::hex, is the I/O manipulator, reconfigures the
// output string, all subsequent ints are printed in hex
// (FOR THE REST OF ETERNITY, nah jkjk till the program terminates); A bit of an overkill?
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span><span class="p">;</span> <span class="c1">// goes back to decimal
</span>
<span class="c1">// Other manipulator, SEE NOTES, don't forget #include &lt;iomanip&gt;
</span></code></pre>
</div>

<p>Stream abstraction applies to other fsources of data</p>

<p><strong>Files</strong> - Read from a file instead of stdin<br />
	std::ifstream reads from a file<br />
	std::ofstream writes to a file</p>

<p>File access in C:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"suite.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span> <span class="c1">// r = read mode; file is a handle
</span>	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fscanf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"%255s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">feof</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>File access in C++:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ifstream</span> <span class="n">file</span><span class="p">{</span><span class="s">"suite.txt"</span><span class="p">};</span> <span class="c1">// creating and initializing an ifstream opens the file
</span>	<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">file</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// IMPORTANT: the file is closed when the variable (in this case, file), goes out of scope; when the program stops, it's popped of the runtime stack, it then closes.
</span><span class="p">}</span>
</code></pre>
</div>

<p>Anything you can do do with cin and cout, you can do with an ifstream or an ofstream. ANYTHING.</p>

<p>E.g. string - attach a stream to a string and read/write it</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;sstream&gt;
</span><span class="c1">// std::istringstream and std::ostringstream
// read from/write to a string
</span>
<span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">...,</span> <span class="n">lo</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">ostringstream</span> <span class="n">ss</span><span class="p">;</span> <span class="c1">// think of it as a sock
</span><span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a # between"</span> <span class="o">&lt;&lt;</span> <span class="n">lo</span> <span class="o">&lt;&lt;</span> <span class="s">"and"</span> <span class="o">&lt;&lt;</span> <span class="n">hi</span><span class="p">;</span> <span class="c1">// stuffing the sock with string
</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> <span class="c1">// cuts open the sock and gets the string
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>

<p>E.g. convert a string to a #</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a number"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">istringstream</span> <span class="n">ss</span> <span class="p">{</span><span class="n">s</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// stop if you get int
</span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I said,"</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"You entered"</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>

<p>Example revisited - echo numbers, skip non-numbers</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">istringstream</span> <span class="n">ss</span> <span class="p">{</span><span class="n">s</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="strings">Strings</h2>

<p>In C, array of char (char* or char[]), terminated by IO. Must manage own memory: get morememory when strings grow; Easy to overwrite IO and corrupt program</p>

<p><strong>In C++, strings grow as needed, and are thus safer.</strong></p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">string</span> <span class="n">s</span><span class="p">{</span><span class="s">"Hello"</span><span class="p">};</span> <span class="c1">// it's still an array (C-style string);
// C++ string created from C string on initialization
</span></code></pre>
</div>

<p><strong>String Operations:</strong></p>

<ul>
  <li>Equality Inequality, s1 == s2, s1 != s2</li>
  <li>Comparison: s1 &lt;= s2 (lexicographical comparison)</li>
  <li>Length: s.length()</li>
  <li>Extract individual characters: s[0], s[1] etc.</li>
  <li>Concatenation: s3 = s1 + s2, s3 += s4</li>
  <li>More details: SEE NOTES</li>
</ul>

<p>Default Function Parameters</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printSuiteFile</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"suite.txt"</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// default value, must be last
</span>  <span class="p">...</span>
<span class="p">}</span>

<span class="n">printSuiteFile</span><span class="p">(</span><span class="s">"suite2.txt"</span><span class="p">);</span>
<span class="n">printSuiteFile</span><span class="p">();</span> <span class="c1">// prints from suite.txt
</span></code></pre>
</div>

<p>Note: optional params must be last; if you leave out two parameters, they have to be the last two; 3,3 etc.</p>

<p><br /></p>

<h2 id="may-18-2016---tutorial-2">May 18, 2016 - Tutorial 2</h2>

<h2 id="shell-scripting">Shell Scripting</h2>

<ul>
  <li>Exit codes are important; non-zero return/exit value = ERROR</li>
  <li>Write to the correct stream</li>
  <li>Scoping for subroutines, anything defined befored a subroutine is visible(and modifiable) in the subroutine, except positional arguments ($1, $2, …)</li>
</ul>

<h2 id="testing">Testing</h2>

<ul>
  <li>Don’t have to worry about invalid inputs</li>
  <li>Testing is hard</li>
  <li>Try sanity checks (“No one could make this mistake”)</li>
  <li>Good coverage: boundary/edge and corner cases, equivalence classes, weird cases</li>
</ul>

<p><strong>Possible Test Cases</strong></p>

<ul>
  <li>Equivalence courses: small, medium, and large values of the target</li>
  <li>Boundary/edge cases: test containing 0 as target</li>
</ul>

<h2 id="c-io">C++ I/O</h2>

<ul>
  <li>DO NOT USE C I/O</li>
  <li>3 default streams: cout, cerr, cin</li>
  <li>If a read from cin fails, <strong>all subsequent reads will fail</strong></li>
</ul>

<h2 id="make-io-more-robust">Make I/O More Robust</h2>

<ul>
  <li>Reading from cin could fail in two ways
    <ul>
      <li>EOF</li>
      <li>got unexpected input</li>
    </ul>
  </li>
  <li>When a read fails, a flag goes up in cin
    <ul>
      <li>cin.fail() will be true</li>
      <li>Only cin.fail() will be true if it was an error</li>
      <li>Both cin.fail() and cin.eof() will be true if it was EOF</li>
      <li>How to clear: cin.clear() -&gt; put all cin flags down and turn it into a valid state</li>
      <li>How to continue: cin.ignore(); order is important: clear then ignore</li>
    </ul>
  </li>
  <li>If you want the entire line, use getline(cin, s)</li>
</ul>

<h2 id="strings-1">Strings</h2>

<ul>
  <li>Encapsulates something like char* in C</li>
  <li>Has length, insert, delete, search methods</li>
  <li>Can be accessed like an array</li>
  <li>include<string></string></li>
  <li>at(index): checks for bounds and throws an exception if out of bounds</li>
  <li>[index]: does not check for bounds</li>
</ul>

<p><br /></p>

<h2 id="may-19-2016---lecture-6">May 19, 2016 - Lecture 6</h2>

<p><strong>Overloading</strong></p>

<p>C: Functions with different parameter lists cannot share the same name</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">negInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">n</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">negBool</span><span class="p">(</span><span class="n">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</code></pre>
</div>

<p>C++: Functions with different parameter lists can share the same name</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">neg</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">n</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">neg</span><span class="p">(</span><span class="n">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// example of overloading
</span></code></pre>
</div>

<p>Compiler uses number of types of arguments to decide which neg is being called.</p>

<p>Overloads must differ in number of type of arguments, not just on the return type. We’ve seen this before: », « (operators, could be right shift/left shift, or could be input and output; the behaviour depends on types of args)</p>

<p><strong>Structs</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// don't forget the semicolon
</span>
<span class="n">Node</span> <span class="n">n1</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">};</span> <span class="c1">// nullptr is the syntax for a null pointer in C++.
// Do not say NULL or 0 in this class!!!!!!!
// 0 will be always treated as a number, not pointer
</span>
<span class="k">const</span> <span class="n">Node</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span> <span class="c1">// constant struct means that its fields
// cannot be changed; n2 is an immutable copy of n1
</span></code></pre>
</div>

<p><strong>Parameter Passing</strong></p>

<p>Recall:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">inc</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 5; call-by-value
// inc gets a copy of x and modifies the copy, not the original
</span></code></pre>
</div>

<p>Sol’n: If a function needs to modify its arugument - pass a pointer</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x's address passed by value, inc changes value at that address, visible to caller
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 6
</span></code></pre>
</div>

<p>Question: Why cin » x and not cin » &amp;x?<br />
Answer: C++ has another pointer-like type: references</p>

<p><strong>References (IMPORTANT!!!)</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// NEW. Ampersand after int.
// z is an lvalue reference to int (which is y)
// Reference is like a constant pointer, similar to int *const z = &amp;y;
// (z is a constant pointer to an int; z will always point to y implied by const)
// (but y is not constant; you can change y however you like)
</span></code></pre>
</div>

<p>References are like constant pointers with automatic dereferencing.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">z</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// NOT *z = 12
</span><span class="kt">int</span> <span class="err">\</span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">;</span> <span class="c1">// &amp;z gives the address of y.
// No matter what you do to z, you do it y.
// In all cases, z behaves exactly like y. z is an alias for y.
</span></code></pre>
</div>

<p><strong>Things you CANNOT do with lvalue references</strong></p>

<ul>
  <li>leave them uninitialized, because they are constant, cannot assign later
    <ul>
      <li>must be initialized with something that actually has an address (an lvalue) since references are pointers</li>
      <li>E.g.</li>
    </ul>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// WRONG: WONT COMPILE!
// because 3 is not an address, it's a constant literal
</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// WRONG!
</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// GOOD
</span></code></pre>
    </div>
  </li>
  <li>create pointer to a reference: int &amp;* x; // WRONG
    <ul>
      <li>reference to a pointer is legal: int *&amp; x;</li>
    </ul>
  </li>
  <li>create a reference to a reference: int &amp;&amp; x = …; // means something different (will discuss later)</li>
  <li>create an array of references: int &amp;a[] = {x, x, x}; // given the similarity between arrays and pointers</li>
</ul>

<p><strong>Things you CAN do with lvalue references</strong></p>

<ul>
  <li>Pass as function parameters:</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// const pointer to the argument (x), thus changes to n affect x
</span>  <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// no pointer dereferencing
</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">inc</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 6
</span></code></pre>
</div>

<p>Why does cin » x work? It takes x by reference</p>

<p>istream &amp;operator » (istream &amp;in, int &amp;n);</p>

<p><strong>Pass-by-value</strong></p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// copies the argument
// if the argument is big, copying is expensive
</span>
<span class="k">struct</span> <span class="n">ReallyBig</span><span class="p">{};</span> <span class="c1">// Massive struct with thousands of fields
</span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="n">ReallyBig</span> <span class="n">rb</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// copying would be slow
</span>
<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="n">ReallyBig</span> <span class="o">&amp;</span><span class="n">rb</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// pass as reference, no copy, it's an alias, fast
// this could change rb in the caller, in contrast to pass by value, which guarantees
// no changes to rb itself after calling
</span>
<span class="kt">int</span> <span class="nf">h</span><span class="p">(</span><span class="k">const</span> <span class="n">ReallyBig</span> <span class="o">&amp;</span><span class="n">rb</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// pass constant reference, no copy, fast, and the parameter cannot be changed
</span></code></pre>
</div>

<p>Advice: prefer pass-by-const-reference over pass-by-value for anything larger than an int, unless the function needs to make a copy anyway - then maybe pass by value. DEFAULT SHOULD BE PASS-BY-CONST-REF. Sizeof reference is same as size of a pointer</p>

<p>Also:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>
<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>

<span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// LMAO FAILS WON'T COMPILE, because 5 does not have an address;
// can't initialize an lvalue reference (n) to a literal value;
// if n changes, can't change the literal 5
</span>
<span class="n">g</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// OK; since n can never be changed, the compiler will allow this
// How though? The compiler creates a temporary location to hold 5, so that n has something to point at
</span></code></pre>
</div>

<p>That’s why const ref is so CRITICALLY IMPORTANT.</p>

<p><strong>Dynamic Memory Allocation</strong></p>

<p>C:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="c1">// Don't use these in this course though
</span></code></pre>
</div>

<p>C++: new/delete</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span> <span class="c1">// allocates a Node on the heap and np points to it
// ...
</span><span class="k">delete</span> <span class="n">np</span><span class="p">;</span>
<span class="c1">// all local variables reside on the stack
// deallocated (popped) when their scope ends
// Allocated memory is on the heap, it stays there until you get rid of it
// Remains allocated until delete is called
</span></code></pre>
</div>

<p>If you don’t delete - MEMORY LEAK</p>

<p><strong>Arrays on the heap</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">*</span><span class="n">myArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">// ...
</span><span class="k">delete</span> <span class="p">[]</span> <span class="n">myArray</span><span class="p">;</span> <span class="c1">// The square brackets have to be there
</span></code></pre>
</div>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="nf">getMeANode</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// copy to caller's frame, expensive
</span>    <span class="n">Node</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="o">&amp;</span><span class="n">getMeANode</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// WORST. Returns a ref (essentially a pointer) to
</span>  <span class="c1">// stack-allocated data, which is dead on return
</span>    <span class="n">Node</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="o">*</span><span class="n">getMeANode</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// fast-ish and safe, not returning pointer to dead data
</span>  <span class="c1">// caller responsible for delete when done
</span>    <span class="n">Node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Considering all options, do No.1.</p>

<p><strong>Operator Overloading</strong><br />
Give our own meanings to C++ operators for types we create</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">v</span><span class="p">{</span><span class="n">v1</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">v2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">v2</span><span class="p">.</span><span class="n">y</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="may-24-2016---lecture-7">May 24, 2016 - Lecture 7</h2>

<h2 id="preprocessor-variables">Preprocessor Variables</h2>

<ul>
  <li>We can also define preprocessor symbols via the compiler; with gcc, syntax is -Dvname or -Dvname=val (-DX)</li>
  <li><strong>ifdef</strong> and <strong>ifndef</strong> directives: these check if a preprocessor variable has been defined (a use for simply defining variables); can be used to debug; #ifdef DEBUG to conditionally print stuff out to debug code; can offload run time to compile time
    <ul>
      <li>syntax:
  <code class="highlighter-rouge">
  g++14 -DDEBUG program.cpp // set DEBUG
 </code></li>
    </ul>
  </li>
</ul>

<h2 id="separate-compilation">Separate Compilation</h2>
<ul>
  <li>To help readability and create modularity we can split our programs into composable modules. Each module consist of <strong>interface</strong> (type definitions and prototypes for functions, .h file, contains declarations, won’t allocate space for the variables) and <strong>implementation</strong> (full details, allocates space for variables/functions, .cpp file, contains definitions)</li>
  <li>Example: Let’s take the vector struct and overloaded addition operator we created and put in a module so that it can be used by other files; create vec.h and vec.cpp</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// vec.h
</span><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v1</span>
              <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span> <span class="c1">// constant reference to vectors, do not modify the originals
</span>
<span class="c1">// ---------------------------------------
// vec.cpp
</span><span class="cp">#include "vec.h"
</span><span class="c1">// to get the struct definition from the interface file
</span>
<span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">v1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">y</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// main.cpp
</span><span class="cp">#include "vec.h"
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">x</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>
  <span class="n">Vec</span> <span class="n">y</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
  <span class="n">Vec</span> <span class="n">v</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<p>when compiling:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>g++14 -c vec.cpp // -c oppresses linking, creates .o (object) file
g++14 -c main.cpp
g++14 vec.o main.o -o main
./main
</code></pre>
</div>

<h2 id="global-variables">Global Variables</h2>

<ul>
  <li>Consider we want to want to define a global variable in a module</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// abc.h
</span><span class="kt">int</span> <span class="n">globalNum</span><span class="p">;</span> <span class="c1">// Wrong - definition and declaration
// This won't work, every file that includeds abc.h
// defines a SEPARATE globalNum and the program will not link
</span></code></pre>
</div>

<ul>
  <li>Solution: put the variable in the .cpp file</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// abc.h
</span><span class="k">extern</span> <span class="kt">int</span> <span class="n">globalNum</span><span class="p">;</span> <span class="c1">// Correct, just declaration
// extern keyword
// -------------------------
// abc.cpp
</span><span class="kt">int</span> <span class="n">globalNum</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="multiple-includes">Multiple Includes</h2>

<ul>
  <li>Always put #include guards in .h files (ifdef, define, endif)</li>
  <li>Never put using namespace std in .h files; DO NOT USE ANY NAMESPACES WHATSOEVER!</li>
</ul>

<h2 id="classes">Classes</h2>

<ul>
  <li>The big innovation of OOP - we can put functions inside of structs</li>
  <li>A class is some struct that can contain functions</li>
  <li>An object is an instance of a class</li>
  <li>Member functions (aka Methods) are functions inside a class</li>
  <li>this = pointer to the object a member function is called on; syntax: this-&gt;var; s.grade() is like calling grade(&amp;s)</li>
</ul>

<p><br /></p>

<h2 id="may-26-2016---lecture-8">May 26, 2016 - Lecture 8</h2>

<h2 id="classes-continued">Classes Continued</h2>
<p>Recall: student.cpp, implemented as struct<br />
This class:</p>

<h2 id="initializing-objects">Initializing Objects</h2>
<ul>
  <li>When creating an object typicaly the class will have data members that need to be assigned values - initialized</li>
  <li>As shown in the student example we could use curly braces to initialize our class, and in C++ this is true for most types - this is called <strong>Uniform Initialization</strong></li>
  <li>Ex. Student bob {60, 70, 80} in the student.cpp example</li>
</ul>

<h2 id="constructors">Constructors</h2>
<ul>
  <li>Without defining how your class should be constructed C++ just takes those values and assigns them to each field in the order they were declared - this is okay, but has limitations</li>
  <li>A better idea is to include in your class a method that does the initialization - called a <strong>constructor</strong></li>
  <li>
    <p>Ex. in the student.cpp example</p>

    <p>Student(int assns, int mt, int final) {
    // Debug statement here
    this-&gt;assns = assns;
    this-&gt;mt = mt;
    this-&gt;final = final;
  }
  // default value given
  Student(int assns=0, int mt=0, int final=0) {
      // …
  }</p>
  </li>
</ul>

<h2 id="notes-on-initialization">Notes on Initialization</h2>
<ul>
  <li>
    <p>Sometimes variables are initialized with the assignment operator</p>

    <p>int x = 5;
  string s = “hello”;</p>
  </li>
  <li>
    <p>And sometimes with (), especially when invoking Constructors</p>

    <p>int x(5);
string s(“Hello”)
Student bob(60, 70, 80)</p>
  </li>
  <li>
    <p>An exception to this: std::vector</p>

    <p>std::vector B{1,3,5} // contains elements 1,3,5
std::vector V(5) // of size 5
std::vector G{1} // actually contains element 1; curly brackets -&gt; element rather than size</p>
  </li>
  <li>
    <p>Also,</p>

    <p>int x = 2.0; // the decimal will get chopped off
int x {2.0} // COMPILER ERROR</p>
  </li>
  <li>
    <p>A class is a struct itself, an object is an actual variable of that type</p>
  </li>
</ul>

<h2 id="default-constructor">Default Constructor</h2>

<ul>
  <li>Every class comes with a default (zero-argument) constructor which calls: you can create an object but set its values later</li>
  <li>As soon as you declare your own constructor, you lose the default</li>
</ul>

<h3 id="section">#</h3>

<ul>
  <li>What about if our class contains a constant field or a reference field?</li>
  <li>For example let’s consider adding an ID field to our student class, this should be a const value that never changes but is different for each initialized student object</li>
  <li>Where to initialize them though? Struct definition (i.e. create an ID field in the struct; const int id = 0;)? In the body of the constructor?</li>
  <li>Problem: const int should be initialized</li>
  <li>Solution:</li>
</ul>

<h2 id="object-creation-steps">Object Creation Steps</h2>
<ul>
  <li>Space is allocated</li>
  <li>Fields are constructed</li>
  <li>Constructor body runs</li>
  <li>The moddile step is the missing piece of the puzzle where our initialization must go!</li>
</ul>

<h2 id="mil">MIL</h2>
<ul>
  <li>The member initialization list is part of our constructor that specifies how to initialize object and non-static data members of our class</li>
  <li>Can be used for any non-static memebers</li>
  <li>Initialized in order of declaration in struct</li>
  <li>Is more efficient, when the constructor is doing the same thing as the MIL, when there is a class inside a class (school class in student class)</li>
  <li>
    <p>Ex.</p>

    <p>Student(): assns{assns}, mt{mt}, final{final}, id{id} {</p>

    <p>}</p>
  </li>
</ul>

<h2 id="copy-constructor">Copy Constructor</h2>
<ul>
  <li>What happens when you use the assignment opeartor to instantiate an object?</li>
  <li>Ex.</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Student</span> <span class="n">a</span> <span class="p">{</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">80</span><span class="p">}</span>
<span class="n">Student</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre>
</div>

<ul>
  <li>b will be initialized via the copy constructor</li>
  <li>All classes have an implicit copy constructor that just copies all regular data fields and calls copy constructors on all object fields</li>
  <li>Ex.</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include "Node.h"
</span><span class="n">Node</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// recursively copies the nodes
</span></code></pre>
</div>

<h2 id="implicit-methods">Implicit Methods</h2>
<ul>
  <li>Every class comes with
    <ul>
      <li>A default constructor</li>
      <li>A copy constructor (just copies all fields)</li>
      <li>A copy assignment operator</li>
      <li>A destructor</li>
      <li>A move constructor</li>
      <li>A move assignmenet operator</li>
    </ul>
  </li>
</ul>

<h2 id="notes-on-copy-constructor">Notes on Copy Constructor</h2>
<ul>
  <li>The copy constructor (implicit or otherwise) is called when
    <ul>
      <li>An object is initialized by another object</li>
      <li>When an object is passed by value</li>
      <li>When an object is returned by a function</li>
    </ul>
  </li>
</ul>

<h2 id="implicit-conversion">Implicit conversion</h2>
<ul>
  <li>Be careful with a constructor that takes only one parameter - this will create an implicit conversion</li>
</ul>

<h2 id="destructor">Destructor</h2>
<ul>
  <li>Necessary if your class has any memory allocated on the heap</li>
</ul>

<p><br /></p>

<h2 id="may-31-2016---lecture-9">May 31, 2016 - Lecture 9</h2>

<h2 id="recall">Recall</h2>

<ul>
  <li>Copy constructor</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}}};</span>
<span class="n">Node</span> <span class="n">m</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="c1">// copy ctor
</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="o">*</span><span class="n">n</span><span class="p">};</span> <span class="c1">// copy ctor
</span></code></pre>
</div>

<ul>
  <li>Simple copy of fields -&gt; only the first node actually copied (shallow copy)</li>
  <li>If you want a deep copy (copy the whole list), must write your own copy constructor</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
	<span class="c1">// ...
</span>	<span class="n">Node</span> <span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">data</span> <span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">},</span>
    <span class="n">next</span> <span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="o">?</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">};</span>
    <span class="c1">// recursively copies the rest of the list
</span><span class="p">};</span>
</code></pre>
</div>

<p>The copy constructor is called:</p>

<ol>
  <li>When an object is initialized with another object (same class)</li>
  <li>When an object is passed by value</li>
  <li>When an object is return ed by a function</li>
</ol>

<p>There are exceptions to all 3.</p>

<p>Note: Careful with chars that can take ONE argument</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span> <span class="p">{</span><span class="n">d</span><span class="p">},</span> <span class="n">next</span> <span class="p">{</span><span class="n">nullptr</span><span class="p">}</span> <span class="p">{}</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="c1">//Single-argument ctors create implicit conversions
</span>
<span class="n">Node</span> <span class="n">n</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">Node</span> <span class="n">n</span><span class="p">{</span><span class="mi">4</span><span class="p">};</span>
<span class="c1">// but also
</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">// You can also do this now
</span><span class="kt">int</span> <span class="nf">f</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>
<span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="c1">// You can do this because 4 is implicitly converted to Node
// How converting C string to C++ string makes sense; generally not a good idea though
</span></code></pre>
</div>

<p>Danger: accidentally pass an int to a function expecting a Node
  + Compiler does not signal an error
  + Potential errors not caught</p>

<p>Good idea: disable the implicit conversion</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">explicit</span> <span class="n">Node</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span> <span class="p">{</span><span class="n">d</span><span class="p">},</span> <span class="n">next</span> <span class="p">{</span><span class="n">nullptr</span><span class="p">}</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// Now these are still fine
</span><span class="n">Node</span> <span class="n">n</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">Node</span> <span class="n">n</span><span class="p">{</span><span class="mi">4</span><span class="p">};</span>
<span class="c1">// But these are not
</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">f</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>
<span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="destructors">Destructors</h2>

<p>When an obect is destroyed a method called the destructor runs
  + Stack-allocated: goes out of scope
  + Heap-allocated: is deleted</p>

<p><strong>Specifically</strong>:</p>

<ol>
  <li>The destructor body runs</li>
  <li>Destructor is called on all the fields (called in reverse declaration order; if declared from top to bottom, then destroyed from bottom to top)</li>
  <li>Space is deallocated</li>
</ol>

<p>Class comes with a destructor (just calls destructors for all fields that are objects)</p>

<p>When do we need to write one?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}}};</span>
</code></pre>
</div>

<p>If np goes out of scope, the pointer is reclaimed (it was on the stack), the memory is leaked.</p>

<p>If we say delete np; it calls *np’s destructor, which doesn’t do anything (it only frees the very first node (1), 2, 3 are leaked)</p>

<p>Write a destructor to ensure the whole list is freed:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// tilda has the connotation of negation; NOT; opposite of constructor
</span>
    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// recursively calls
</span>    <span class="c1">// *next's destructor, thus the whole list is deallocated*
</span>    <span class="c1">// do not need to check nullptr
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="copy-assignment-operator">Copy Assignment Operator</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Student</span> <span class="n">billy</span> <span class="p">{</span><span class="mi">60</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">80</span><span class="p">};</span>
<span class="n">Student</span> <span class="n">jane</span> <span class="p">{</span><span class="n">billy</span><span class="p">};</span> <span class="c1">// copy constructor
</span><span class="n">Student</span> <span class="n">joey</span><span class="p">;</span> <span class="c1">// default constructor
</span><span class="n">joey</span> <span class="o">=</span> <span class="n">billy</span><span class="p">;</span> <span class="c1">// copy, but not construction
// Above is copy assignment operator, uses compiler-supplied default
</span></code></pre>
</div>

<p>You need to write your own copy assignmennt operator when there is heap-allocated memory</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// returns Node &amp; so that cascading works
</span>    <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="c1">// next = other.next would be wrong (shallow copy)
</span>    <span class="c1">// because that's what the default one does
</span>    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// otherwise it leaks, because the old object could point to real data
</span>    <span class="c1">// in order to replace the old data, need to delete old data
</span>    <span class="n">next</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="o">?</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="c1">// DANGEROUS STILL //*
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Very dangerous.<br />
Why?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="n">n</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}}};</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// deletes n, then tries to copy n to n, UNDEFINED BEHAVIOUR
</span>
<span class="c1">// For example:
</span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span> <span class="c1">// where p and q points to the same address
</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</code></pre>
</div>

<p>When writing operator=, ALWAYS watch for self-assignment</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c1">//*
</span>  <span class="p">}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="o">?</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">;</span> <span class="c1">//*
</span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Better:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">next</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span> <span class="o">?</span> <span class="p">{</span><span class="k">new</span> <span class="n">Node</span><span class="p">{</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">};</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
  <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Above works even if other is in my list, if new fails, Node will still be ain a valid state</p>

<h2 id="alternative---idiom">Alternative - idiom</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;utility&gt;
</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span> <span class="c1">// copy other
</span>    <span class="n">swap</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span> <span class="c1">// swap with my old data
</span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="c1">// tmp deallocated, frees my old data
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Rvalues + Rvalue references</p>

<p>Recall: an levalue is anything an address, an lvalue reference (&amp;) is always initialized by an lvalue</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="n">n</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}};</span>
<span class="n">Node</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// copy ctor
</span><span class="n">Node</span> <span class="n">m2</span><span class="p">;</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// copy assignment operator
</span>
<span class="n">Node</span> <span class="nf">plusOne</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">plusOne</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// What runs? What is other here?
// Compiler creates a temporary object to hold the result of plusOne, so other has something to point at
// copy ctor deep copies data drom the temp object
</span></code></pre>
</div>

<p><br /></p>

<h2 id="june-2-2016---lecture-10">June 2, 2016 - Lecture 10</h2>

<ul>
  <li>Need to be able to tell whether other is a reference to a temporary object or a standalone object</li>
  <li>C++: rvalue reference Node&amp;&amp; is a reference be a temporary object (aka rvalue) of type Node</li>
  <li>Version of the ctor that takes a Node&amp;&amp;</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="n">Node</span><span class="p">(</span><span class="n">Node</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// ... called a move ctor
</span><span class="p">}</span>
</code></pre>
</div>

<p>What should it do? Steal other’s data.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">...</span>
<span class="n">Node</span> <span class="p">(</span><span class="n">Node</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span><span class="o">:</span>
    <span class="n">data</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">},</span>
    <span class="n">next</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="p">{</span> <span class="c1">// steal data
</span>        <span class="n">other</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="c1">// other will be destroyed, so point to null so that the Nodes it points to won't get destroyed
</span>    <span class="p">}</span>
</code></pre>
</div>

<p>Similarly:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="n">m</span><span class="p">;</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">addOne</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// Assignment from temporary
</span></code></pre>
</div>

<p>More assignment operator:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Node</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// steal other's data
</span>    <span class="c1">// destroy my old data
</span>    <span class="c1">// so we can just swap without copy
</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

    <span class="c1">// temp object will be destroyed and take our old data with it
</span><span class="p">}</span>
</code></pre>
</div>

<p>If you don’t define move ctor/move assignment operator, copy versions will be used.<br />
If the move ctor/move assignment operator is defined, it will replace calls to the copy ctor/copy assignment operator where the argument is a temporary (an rvalue).</p>

<h2 id="copymove-elision">Copy/Move Elision</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Vec</span> <span class="nf">makeAVec</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// invokes basic ctor
</span><span class="p">}</span>

<span class="n">Vec</span> <span class="n">v</span> <span class="o">=</span> <span class="n">makeAvec</span><span class="p">();</span> <span class="c1">// what operations run here? copy ctor? move ctor?
// Not sure, in g++: just the basic ctor, no cpy ctor, no move ctor
</span></code></pre>
</div>

<p>In some circumstances, the compiler is allowed to skip calling copy/move ctors (but doesn’t have to). In the example above, makeAVec writes its result ({0,0}) directly into the space occupied by v in the caller, rather than copy it later</p>

<p>Example:
```c++
void doSomething(Vec v) { // pass-by-value copy ctor</p>

<p>}</p>

<p>doSomething(makeAVec());
```</p>

<ul>
  <li>result of makeAVec() written directly into the parameter - no copy</li>
  <li>This is allowed, even if dropping ctor calls would change the behaviour of the program (e.g. if the ctors print something)</li>
  <li>In this course, you are not expect edt oknow the eact circumstances under which copy/move elision is allowed</li>
</ul>

<p>If you need all of the ctors to run:
<code class="highlighter-rouge">
g++14 -fno-elide-constructors
</code>
But this can slow down your program considerably.</p>

<p>In summary: <strong>Rule of 5 (Big 5)</strong></p>

<p>If you need a custom version of any one of:
    1. copy ctor
    2. copy assignment operator
    3. destructor
    4. move ctor
    5. move assignment operator
Then you usually need a custom version of all 5. Because the circumstances you need to create one of them, will probably mean that these also apply to the other 4.</p>

<p>Notice: operator= is a member function, not a standalone function. When an operator is a member, “this” plays the role of the LHS argument.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="c1">// ...
</span>    <span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="o">+</span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">};</span>
    <span class="p">}</span>
    <span class="n">Vec</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="n">y</span><span class="p">};</span> <span class="c1">// implements v*k
</span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>How do we do k*v? Can’t be a member-first arg not vec. Must be a non-member (as before)</p>

<p>I/O operators:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="err">''</span> <span class="o">&lt;&lt;</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>What’s wrong? It makes Vec the LHS and ostream the RHS. Use as v « cout</p>

<p>So define «, » as standalone functions.</p>

<p>Certain operators must be members:</p>

<ul>
  <li>operator=</li>
  <li>operator[]</li>
  <li>operator()</li>
  <li>operator-&gt;</li>
  <li>operatorT (where T is a type)</li>
</ul>

<h2 id="arrays-of-objects">Arrays of Objects</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">Vec</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
    <span class="n">x</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">y</span><span class="p">}</span>
    <span class="p">{</span>

    <span class="p">}</span>
<span class="p">};</span>

<span class="n">Vec</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// ERROR
</span><span class="n">Vec</span> <span class="n">moreVectors</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span> <span class="c1">// ERROR
</span></code></pre>
</div>

<p>These want to call the default ctor on each item, but there isn’t one. Thus cannot initialize.</p>

<p><strong>Options:</strong></p>

<ol>
  <li>Provide a default ctor</li>
  <li>For stack arrays:</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Vec</span> <span class="n">moreVecs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{...};</span>
</code></pre>
</div>

<ol>
  <li>For heap arrays, create an array of pointers</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Vec</span> <span class="o">**</span><span class="n">vp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec</span><span class="o">*</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">vp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="n">vp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// etc...
// then delete
</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">vp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">delete</span> <span class="p">[]</span> <span class="n">vp</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="separate-compilation-for-classes">Separate Compilation for Classes</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Node.h
</span>
<span class="cp">#ifndef _NODE_H_
#define _NODE_H_
</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="o">=</span><span class="n">nullptr</span><span class="p">);</span>
    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif
</span>
<span class="c1">// Node.cc
</span>
<span class="cp">#include "Node.h"
</span>
<span class="c1">// Prefix with Node::
// Double colon :: = scope resolution operator
</span>
<span class="n">Node</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span><span class="p">{</span><span class="n">data</span><span class="p">},</span> <span class="n">next</span><span class="p">{</span><span class="n">next</span><span class="p">}</span> <span class="p">{}</span>
<span class="n">Node</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">},</span> <span class="n">next</span><span class="p">{}</span> <span class="p">{}</span>

<span class="c1">// Node::___ means ____ in the context of struct Node
// :: is like . for classes
// . where LHS is a class (or namespace), not an object
</span>
</code></pre>
</div>

<h2 id="const-objects">Const Objects</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>    
</code></pre>
</div>

<p>Const objects arise often, especially in params.<br />
What is a const object? - Fields cannot change.</p>

<p>Can we call methods on a const object?<br />
Issue: method might change fields (violate const)</p>

<p>A: Yes. We can call methods that promise not to mofidy fields</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">assns</span><span class="p">,</span> <span class="n">mt</span><span class="p">,</span> <span class="n">final</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">grade</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// doesn't modify fields, so declare it const
</span><span class="p">}</span>
</code></pre>
</div>

<p>Compiler checks that const methods don’t modify fields. Only const methods can be called on const objects.</p>

<p>Now consider: Want to collect usage stats on Student obj</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span>  <span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="kt">int</span> <span class="n">numMethodCalls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="nf">grade</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// now can't call on const Students
</span>        <span class="o">++</span><span class="n">numMethodCalls</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>But mutating numMethod calls affect only the <strong>physical constness</strong> of the object (actual bit pattern), not its <strong>logical constness</strong> (whether it acts like a constant).</p>

<p>Want to update numMethodCalls, even if the object is const.
Solution: Declare the field mutable</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="k">mutable</span> <span class="kt">int</span> <span class="n">numMethodCalls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// can be changed, even if the object is const
</span>
    <span class="kt">float</span> <span class="nf">grade</span> <span class="p">()</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">numMethodCalls</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="june-7-2016---lecture-11">June 7, 2016 - Lecture 11</h2>

<h2 id="static-fields-and-methods">Static Fields and Methods</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
  <span class="k">mutable</span> <span class="kt">int</span> <span class="n">nCalls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">grade</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">nCalls</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// blah blah blah
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>nCalls tracks the number of times a method was called on a <strong>particular object</strong>. What if we want the number of calls over all Student objects? Or what if we want to know how many Students were created?</p>

<h3 id="static-members">Static Members</h3>

<ul>
  <li>Associated with the class itself, NOT any particular object</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">static</span> <span class="kt">int</span> <span class="n">numInstances</span><span class="p">;</span>
  <span class="n">Student</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">numInstances</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// in .cc file
</span><span class="kt">int</span> <span class="n">Student</span><span class="o">::</span><span class="n">numInstances</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>NOTE</strong>: Static fields MUST be defined external to the class</p>

<h3 id="static-member-functions">Static Member Functions</h3>

<ul>
  <li>Don’t depend on any particular instance (no “this” parameter) (not methods)</li>
  <li>Can only access static fields and call other static member functions</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">static</span> <span class="kt">int</span> <span class="n">numInstances</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">printNumInstances</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">numInstances</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// main
</span><span class="n">Student</span> <span class="n">billy</span> <span class="p">{};</span>
<span class="n">Student</span> <span class="n">jane</span> <span class="p">{};</span>
<span class="n">Student</span><span class="o">::</span><span class="n">printNumInstances</span><span class="p">();</span> <span class="c1">// prints 2
</span></code></pre>
</div>

<h2 id="invariants-and-encapsulation">Invariants and Encapsulation</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// main
</span>
<span class="n">Node</span> <span class="n">n1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}};</span>
<span class="n">Node</span> <span class="n">n2</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">};</span>
<span class="n">Node</span> <span class="n">n3</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n2</span><span class="p">};</span>
</code></pre>
</div>

<p>What happens when these go out of scope? n3’s destructor tries to delete &amp;n2, which is on the stack, not on the heap! Thus, UNDEFINED BEHAVIOUR!</p>

<p>Class Node relies on an assumption, called an <strong>invariant</strong>, a statement that shold always be true. In this case, the invariant is that next is either:</p>

<ul>
  <li>a nullptr, or</li>
  <li>a valid pointer to the heap</li>
</ul>

<p>But we cannot guarantee this invariant. Because we cannot control the user, we cannot guarantee any invariant because the user can interfere. For example, in a stack implementation, the invaraint is: last item pushed is the first item popped. If you cannot rely on variants, it would be hard to reason about programs</p>

<p>To solve: Encapsulation - we want clients to treat objects as “black boxes” (or capsules)</p>

<ul>
  <li>Implementation details are sealed away</li>
  <li>Can only interact via the provided methods</li>
  <li>Can create an abstraction, regain us control</li>
</ul>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
  <span class="n">Vec</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// by default, public
</span><span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// can only be accessed from inside Vec
</span><span class="nl">public:</span>
  <span class="n">vec</span> <span class="n">Operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span> <span class="c1">// anyone can access
</span><span class="p">};</span>
</code></pre>
</div>

<p>In general, we want fields to be private, and only methods should be public. Introducing class:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span> <span class="c1">// constructors etc are public
</span>  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// private by default now
</span><span class="nl">public:</span>
  <span class="n">Vec</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Only difference between struct and class: default visibility, otherwise completely identical</p>

<p>Now we fix the linked list class</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// list.h
</span>
<span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span><span class="p">;</span> <span class="c1">// private nested class
</span>  <span class="n">Node</span> <span class="o">*</span><span class="n">theList</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">addToFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ith</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
  <span class="o">~</span><span class="n">List</span><span class="p">();</span>
  <span class="c1">// ... etc etc
</span><span class="p">};</span>

<span class="c1">// list.cc
</span><span class="cp">#include "list.h"
</span><span class="k">struct</span> <span class="n">List</span><span class="o">::</span><span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// nested class
</span>  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span> <span class="c1">// MIL
</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">List</span><span class="o">::</span><span class="n">addToFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">theList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theList</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">List</span><span class="o">::</span><span class="n">ith</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">theList</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">List</span><span class="o">::~</span><span class="n">List</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">delete</span> <span class="n">theList</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Only List can create/manipulate Node objects, thus we can guarantee the invariance that next is either a nullptr or a valid pointer to the heap. BUT, now we can’t traverse the entire list in linear time. Repeated calling ith(int i) to traverse the whole list -&gt; O(n<sup>2</sup>) time. On the other hand, we can’t expose the Nodes or we will lose encapsulation</p>

<h2 id="se-topic-design-patterns">SE Topic: Design Patterns</h2>

<ul>
  <li>Certain problems arise frequently</li>
  <li>Keep track of good solutions and use them in similiar situations</li>
  <li>Good Solutions Hall of Fame</li>
  <li>If you have a situation like this, then this technique may solve it</li>
</ul>

<p>In this case, we use the <strong>Iterator Pattern</strong>.</p>

<ul>
  <li>Create a class that manages access to nodes (abstraction of a pointer)</li>
  <li>Walk through the list without exposing the next pointers</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span><span class="p">;</span> <span class="c1">// nested inner class
</span>  <span class="n">Node</span> <span class="o">*</span><span class="n">theList</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">p</span><span class="p">{</span><span class="n">p</span><span class="p">}</span> <span class="p">{}</span>

    <span class="kt">int</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// reference because might want to modify data
</span>      <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Iterator</span> <span class="o">&amp;</span><span class="n">opeartor</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// standalone functions
</span>  <span class="n">Iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">theList</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ... other list functions follow
</span>
<span class="p">};</span>

<span class="c1">// client
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">List</span> <span class="n">l</span><span class="p">;</span>
  <span class="n">l</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">l</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">l</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">List</span><span class="o">::</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// prints 1 2 3
</span><span class="p">}</span>
</code></pre>
</div>

<p>Shortcut when writing the Iterator for loop: we can use automatic type deduction</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// auto gives x y's type
</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// "shortercut" - Range-based for loop
</span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">:</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Range-based for loop: available for all classes with:</p>

<ul>
  <li>Methods begin, end that produce Iterators</li>
  <li>Iterator must support !=, prefix ++, unary *</li>
</ul>

<p>If we want to modify list items(or save copying):</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">n</span> <span class="o">:</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// use reference
</span>  <span class="o">++</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="june-9-2016---lecture-12">June 9, 2016 - Lecture 12</h2>

<p>But List client can create Iterators directly by doing the following:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">List</span><span class="o">::</span><span class="n">Iterator</span><span class="p">{</span><span class="n">nullptr</span><span class="p">};</span>
</code></pre>
</div>

<p>This violates encapsulation as the client should be calling begin and end, which we provide.</p>

<p>We could preserve encapsulation by:</p>

<ul>
  <li>Making Iterator’s constructor private
    <ul>
      <li>Then client cannot call List::Iterator</li>
      <li>But then neither can List</li>
    </ul>
  </li>
  <li><strong>Solution</strong>: give list privileged access to Iterator -&gt; make it a <strong>friend</strong></li>
</ul>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="c1">// ... Iterator functions
</span>    <span class="c1">// friend
</span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">List</span><span class="p">;</span> <span class="c1">// List now has access to all members of Iterator
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Now, List can still create Iterators, but client can only create Iterators by calling begin and end.</p>

<p><strong>NOTE</strong>: Give your classes as few friends as possible, because it weakens encapsulation. Once again, we want to keep fields private.</p>

<p>What if you want to give clients access to fields? “Getters” and “Setters” methods</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">getX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setY</span><span class="p">(</span><span class="kt">int</span> <span class="n">newY</span><span class="p">)</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>What about operator «? It needs x and y, but it cannot be a member function</p>

<ul>
  <li>If getX, getY are defined, then we are ok</li>
  <li>But if you don’t want to provide getX and getY, make operator« a friend function that is standalone</li>
</ul>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// .h file
</span>
<span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// .cc file
</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="tools-topic-make">Tools Topic: Make</h2>

<p><strong>Separate Compilation</strong>: lectures/c++/tools/example1</p>

<div class="highlighter-rouge"><pre class="highlight"><code>g++14 -c list.cc
g++14 -c node.cc
g++14 -c iter.cc
g++14 -c main.cc
g++14 main.o iter.o node.o list.o -o myprogram
</code></pre>
</div>

<p>Why do we do this? So we don’t have to recompile files that haven’t changed.</p>

<p>But how do we keep track of what’s changed and what hasn’t? Let Linux help you with <strong>make</strong>. We can create a Makefile that says which files depend on which other files. Refer to /lectures/c++/tools/example1/Makefile</p>

<div class="highlighter-rouge"><pre class="highlight"><code>myprogram: main.o list.o node.o iter.o # (myprogram depends on these)
  g++-5 -std=c++14 main.o list.o node.o iter.o -o myprogram # (tab in the beginning)
</code></pre>
</div>

<p>Then from the command line:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>make # builds the whole project
# Now change iter.cc
make # recompiles iter.cc and then relinks myprogram
</code></pre>
</div>

<p>Command <strong>make</strong>: builds the first target (myprogram) in the Makefile. And what does myprogram depend on? main.o, list.o, node.o, iter.o. So make recursively builds these if necessary. Make uses a dependency graph.</p>

<p>For example, iter.cc changes, then iter.cc is now newer than iter.o (by checking the last modified date and time). Thus make rebuilds iter.o. Now iter.o is newer than myprogram, thus make rebuilds myprogram</p>

<p>Make can also build specific targets, for example make node.o</p>

<p>Common practice: put a target clean: at the bottom of the Makefile to remove all binaries</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">clean </span><span class="c">#</span><span class="nf"> (to avoid a file called clean if present)</span>
<span class="nl">clean</span><span class="o">:</span>
  <span class="err">rm</span> <span class="err">*.o</span> <span class="err">myprogram</span>
</code></pre>
</div>

<p>To do a full rebuild:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>make clean
make
</code></pre>
</div>

<p>Now we can generalize with variables. In the Makefile:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CXX = g++-5
CXXFLAGS = -std=c++14 -Wall # (turns on all warnings)
</code></pre>
</div>

<p>E.g.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iter.o: iter.cc iter.h
${CXX} ${CXXFLAGS} -c iter.cc
</code></pre>
</div>

<p>Shortcut: for any make of the form</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x.o: x.cc a.h b.h
</code></pre>
</div>

<p>We can leave out the build command and make would guess that the build command is ${CXX} ${CXXFLAGS}, so we can just write</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="o">-</span><span class="n">c</span> <span class="n">x</span><span class="p">.</span><span class="n">cc</span> <span class="o">-</span><span class="n">o</span> <span class="n">x</span><span class="p">.</span><span class="n">o</span>
</code></pre>
</div>

<p>Biggest problems:</p>

<ul>
  <li>Writing dependencies</li>
  <li>Maintaining them if they change</li>
</ul>

<p>Can get help from g++:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>g++14 -MMD -c iter.cc
</code></pre>
</div>

<p>This creates iter.o <strong>and</strong> iter.d, and iter.d contains:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iter.o: iter.cc list.h node.h
</code></pre>
</div>

<p>Now just include iter.d in the Makefile:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CXX = g++-5
CXXFLAGS = -std=c++14 -Wall -MMD
OBJECTS = main.o list.o iter.o node.o
DEPENDS = ${OBJECTS:.o=.d}
EXEC = myprogram

${EXEC}:${OBJECTS}
  ${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}

-include ${DEPENDS}
</code></pre>
</div>

<p>As the project expands, just add .o files to the Makefile</p>

<h2 id="system-modelling">System Modelling</h2>

<p>Building an object-oriented system involves identifying abstractions and formalizing the relationships among items. It helps to map out relationships. A popular standard is the Unified Modelling Language (UML). Modelling a class, write its name, fields (optional), and methods (optional), and use + to denote public and - to denote private</p>

<h3 id="relationship-composition">Relationship: Composition</h3>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Vec</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Basis</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// client
</span><span class="n">Basis</span> <span class="n">b</span><span class="p">;</span>
</code></pre>
</div>

<p>This will not compile because Basis cannot initialize v1, v2, because the default constructor for b calls default constructors for v1, v2, which do not exist.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Basis</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Basis</span><span class="p">()</span><span class="o">:</span> <span class="n">v1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">v2</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{}</span> <span class="c1">// default constructor, now it will compile
</span><span class="p">};</span>
</code></pre>
</div>

<p>Embedding one object (v1) into another (b), called <strong>composition</strong>. The relationship between Basis and Vec is called “owns-a”, as a Basis “owns a” two Vecs.</p>

<p>If A owns a B, then typically:</p>

<ul>
  <li>B has no identity outside of A</li>
  <li>If A is destroyed, then B is destroyed</li>
  <li>If A is copied, then B is copied (deep copy)</li>
</ul>

<p><br /></p>

<h2 id="june-14-2016---lecture-13">June 14, 2016 - Lecture 13</h2>

<p>A car owns 4 wheels</p>

<ul>
  <li>A wheel is a part of a car</li>
  <li>Destroy the car -&gt; Destroy the wheels</li>
  <li>Copy the car -&gt; Copy the wheels</li>
  <li><strong>Implementation: Composition of classes</strong></li>
  <li>UML: A -&gt; B  (filled arrow), means A owns some number of B’s, can annotate with multiplicities</li>
</ul>

<h3 id="relationship-aggregation">Relationship: Aggregation</h3>

<ul>
  <li>Compare parts in a car (“owns a”) vs. car parts in a catalogue</li>
  <li>A “has a” relationship (aggregation): the catalogue contains the partsm but the parts have an independent existence</li>
  <li>If “A has B”, then typically:
    <ul>
      <li>B has an existence apart from its association with A</li>
      <li>If A is destroyed, then B lives on</li>
      <li>If A is copied, B is not (shallow copy) - copies of A share the same B</li>
    </ul>
  </li>
  <li><strong>Implementation: Pointer fields</strong></li>
</ul>

<p>E.g. Parts in a catalogue, ducks in a pond; UML: Pond -&gt; Duck (hollow arrow)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Pond</span> <span class="p">{</span>
  <span class="n">Duck</span> <span class="o">*</span><span class="n">ducks</span><span class="p">[</span><span class="n">maxDucks</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
  <span class="n">Person</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="specializationgeneralization-inheritance">Specialization/Generalization (Inheritance)</h2>

<p>Suppose you want to track your collection of books</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">(...);</span> <span class="c1">// ctor
</span>  <span class="c1">// other functions
</span><span class="p">};</span>
</code></pre>
</div>

<p>For textbooks, we also want the <strong>topic</strong>:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Text</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">topic</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Text</span><span class="p">(...);</span> <span class="c1">// Text ctor
</span>  <span class="c1">// other functions
</span><span class="p">};</span>
</code></pre>
</div>

<p>For comic books, we want the <strong>hero</strong>:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comic</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">hero</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Comic</span><span class="p">(...);</span> <span class="c1">// Comic ctor
</span>  <span class="c1">// other functions
</span><span class="p">};</span>
</code></pre>
</div>

<p>This is okay, but it doesn’t capture relationships among Book, Text, and Comic. And how do we create an array (or other collection) with a mix of these?</p>

<p>We could:</p>

<ol>
  <li>Use a union - *BAD (subverts the type system)**</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">union</span> <span class="n">BookTypes</span><span class="p">{</span><span class="n">Book</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span> <span class="n">Test</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span> <span class="n">Comic</span> <span class="o">*</span><span class="n">c</span><span class="p">;};</span>
<span class="n">BookTypes</span> <span class="n">myBooks</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</code></pre>
</div>

<ol>
  <li>Array of void * <strong>BAD (pointer to anything)</strong></li>
</ol>

<p>Rather, observe that Text and Comic are kinds of Books - Books with extra features.</p>

<p>C++ - model with Inheritance</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Base class (superclass)
</span><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">(...);</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="c1">// derived classes (or subclasses)
</span><span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">topic</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Text</span><span class="p">(...);</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Comic</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">hero</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Comic</span><span class="p">(...);</span>
  <span class="c1">// ...
</span><span class="p">};</span>
</code></pre>
</div>

<p>Derived classes <strong>inherit</strong> fields and methods from the base class, so Text, Comic get title, author, numPages fields. Any method that can be invoked on Book can be called on Text and Comic.</p>

<p>Who can see these members?</p>

<ul>
  <li>title, author, numPages - private in Book; Text and Comic cannot see them, even subclasses can’t see them</li>
</ul>

<p>How do we initialize Text? Need title, author, numPages (these are needed to initialize the Book part) and topic (specific to Text)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">topic</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Text</span><span class="p">(</span><span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numPages</span><span class="p">,</span> <span class="n">string</span> <span class="n">topic</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">title</span><span class="p">{</span><span class="n">title</span><span class="p">},</span> <span class="n">author</span><span class="p">{</span><span class="n">author</span><span class="p">},</span> <span class="n">numPages</span><span class="p">{</span><span class="n">numPages</span><span class="p">},</span> <span class="n">topic</span><span class="p">{</span><span class="n">topic</span><span class="p">}</span> <span class="p">{}</span>
  <span class="c1">// WRONG!!!
</span><span class="p">};</span>
</code></pre>
</div>

<p>Wrong for 2 reasons:</p>

<ul>
  <li>title etc are not accessible to Text</li>
  <li>Once again, when an object is constructed:
    <ol>
      <li>space is allocated</li>
      <li>superclass part is constructed (NEW!)</li>
      <li>fields constructed</li>
      <li>constructor body runs</li>
    </ol>
  </li>
</ul>

<p>And in this case, superclass cannot be constructed because Book has no default constructor.</p>

<p><strong>Fix:</strong> invoke Book’s constructor in Text’s MIL</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">topic</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Text</span><span class="p">(</span><span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numPages</span><span class="p">,</span> <span class="n">string</span> <span class="n">topic</span><span class="p">)</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">{</span><span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="n">numPages</span><span class="p">},</span> <span class="n">topic</span><span class="p">{</span><span class="n">topic</span><span class="p">}</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre>
</div>

<p><strong>NOTE:</strong> If a superclass has no default constructor, subclass must invoke a superclass constructor in its MIL. Good reasons to keep superclass’s fields inaccessible to subclasses. If you want to give subclasses access to certain members, use <strong>protected</strong> access:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="k">protected</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span> <span class="c1">// accessible to Book and its subclasses
</span>  <span class="nl">public:</span>
    <span class="n">Book</span><span class="p">(...);</span>
    <span class="c1">// ...
</span><span class="p">};</span>

<span class="c1">// subclasses
</span><span class="k">class</span> <span class="nc">Text</span><span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="nl">public:</span>
    <span class="c1">// ...
</span>    <span class="kt">void</span> <span class="n">addAuthor</span><span class="p">(</span><span class="n">string</span> <span class="n">newAuthor</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">author</span> <span class="o">+=</span> <span class="n">newAuthor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Note: Not a good idea to give subclasses unlimited access to fields; <strong>Better</strong> - make fields private, but provide protected accessors</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="n">title</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">string</span> <span class="n">getTitle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">setAuthor</span><span class="p">(</span><span class="n">string</span> <span class="n">newAuthor</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">(...);</span> <span class="c1">// ctor
</span>  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Relationship among Book, Text, and Comic is called “is a”: A Text is a Book; A Comic is a Book. UML: Text-&gt;(hollow)Book&lt;-(hollow)Comic. Implement “is a” by public inheritance.</p>

<p>Now consider the method isItHeavy. When is a Book heavy?</p>

<ul>
  <li>For ordinary Books, &gt; 200 pages</li>
  <li>For Texts, &gt; 500 pages</li>
  <li>For Comics, &gt; 30 pages</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">numPages</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Text</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">numPages</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Comic</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">numPages</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// =====================
// client
</span><span class="n">Book</span> <span class="n">b</span> <span class="p">{</span><span class="s">"A small book"</span><span class="p">,</span> <span class="s">"1Q84"</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
<span class="n">Comic</span> <span class="n">c</span> <span class="p">{</span><span class="s">"A big comic"</span><span class="p">,</span> <span class="s">"Waterloo Memers"</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Mr Paninos"</span><span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// false, it's a small Book as 50 &lt; 200
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">isItHeavy</span><span class="p">;</span> <span class="c1">// true, it's a big comic as 40 &gt; 30
</span></code></pre>
</div>

<p>Since public inheritance means “is a”, we can do:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Comic</span><span class="p">{</span><span class="s">"A big comic"</span><span class="p">,</span> <span class="s">"Balkan Chevaps"</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"We Deliver"</span><span class="p">};</span>
</code></pre>
</div>

<p><strong>Question:</strong> Is b heavy? b.isItHeavy() returns true or false? Which isItHeavy() run, Book::isItHeavy or Comic::isItHeavy?</p>

<p><strong>Answer:</strong> No, it is not heavy. Book::isItHeavy is what runs. Why? Book contains 3 fields: title, author, numPages, while Comic contains 4 fields: title, author, numPages, and hero. Thus,</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Comic</span> <span class="p">{...};</span>
</code></pre>
</div>

<p>tries to create a Comic object when there’s only space for a Book. Comic is then <strong>sliced (“hero” field is chopped off)</strong>. Comic is coerced (forced) into a Book. Basically, Book b = Comic {…} converts a Comic into a Book and Book::isItHeavy runs.</p>

<p>When accessing objects through pointers, <strong>slicing is unnecessary and does not occur</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Comic</span> <span class="n">c</span> <span class="p">{</span><span class="s">"friend5ever"</span><span class="p">,</span> <span class="s">"Sedra Smith"</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"RealisticAFMStudent"</span><span class="p">};</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">Comic</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// true; 40 &gt; 30, heavy Comic
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// false, 40 &lt; 200, not heavy Book
// same behaviour as the slicing example, Book::isItHeavy runs as pointer is Book
</span></code></pre>
</div>

<p>Still, Book::isItHeavy runs when we access pb-&gt;isItHeavy(). Some objects behaves differently, depending on what type of pointer points to it.</p>

<p><br /></p>

<h2 id="june-16-2016---lecture-14">June 16, 2016 - Lecture 14</h2>

<p>Compiler uses the type of the pointer (or type of the reference) to decide which isItHeavy to run. It does not consider the actual type of the object. So a Comic is a Comic only if a comic pointer points to it. Pointer »&gt; Actual object.</p>

<p>Then, how do you make Comic act like a Comic, even when pointed at by a Book pointer? <strong>Solution: declare the method virtual</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="c1">// ... fields
</span><span class="nl">protected:</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">(...);</span>
  <span class="k">virtual</span> <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// use of virtual here
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Comic</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// override keyword in virtual function
</span><span class="p">};</span>

<span class="c1">// =================
// client
</span><span class="n">Comic</span> <span class="n">c</span> <span class="p">{</span><span class="s">"RealisticMathStudent"</span><span class="p">,</span> <span class="s">"UWGo"</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Quest God"</span><span class="p">};</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">rb</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="n">Comic</span> <span class="o">&amp;</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">Book</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// true, Comic::isItHeavy
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rb</span><span class="p">.</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// true, Comic::isItHeavy
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// true, Comic::isItHeavy
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// FALSE, Book::isItHeavy
</span></code></pre>
</div>

<h3 id="virtual-and-polymorphism">Virtual and Polymorphism</h3>

<p><strong>Virtual Methods</strong>: chosen based on the actual types of the object at <strong>runtime</strong></p>

<p>E.g. My book collection</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="o">*</span><span class="n">myBooks</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myBooks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">isItHeavy</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">// This uses Book::isItHeavy for Books, Text::isItHeavy for Texts
</span>  <span class="c1">// and Comic::isItHeavy for Comics
</span><span class="p">}</span>
</code></pre>
</div>

<p>It accommodates multiple types under one abstraction -&gt; <strong>Polymorphism</strong></p>

<p>Note: This is why a function</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
</code></pre>
</div>

<p>can be passed an ifstream, because ifstream is a subclass of istream.</p>

<p><strong>DANGER</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">One</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">One</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Two</span> <span class="o">:</span> <span class="k">public</span> <span class="n">One</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Two</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">One</span><span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">},</span> <span class="n">z</span><span class="p">{</span><span class="n">z</span><span class="p">}</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">One</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// ===============
// clientdas
</span><span class="n">Two</span> <span class="n">myArray</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}];</span>
<span class="n">f</span><span class="p">(</span><span class="n">myArray</span><span class="p">);</span>
</code></pre>
</div>

<p><strong>Data Misaligned</strong>: MyArray is originally [1 2 3][4, 5, 6]; after calling f, it becomes [6 7 8][9 5 6].</p>

<p>Note: NEVER use arrays of objects polymorphically. If you want polymorphism, use an array of pointers</p>

<h3 id="destructor-revisited">Destructor Revisited</h3>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]}</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Y</span> <span class="o">:</span> <span class="k">public</span> <span class="n">X</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Y</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">X</span><span class="p">{</span><span class="n">n</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">]}</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">Y</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// =================
// client
</span><span class="n">X</span> <span class="o">*</span><span class="n">myX</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Y</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
<span class="k">delete</span> <span class="n">myX</span><span class="p">;</span> <span class="c1">// LEAKS!
</span></code></pre>
</div>

<p><strong>Why?</strong> The last line calls ~X, not ~Y, so only x, but not y, is freed.<br />
To ensure that deletion through a superclass pointer calls the subclass destructor, <strong>declare the destructor virtual</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="k">virtual</span> <span class="o">~</span><span class="n">X</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
</div>

<p><strong>ALWAYS</strong> make the destructor virtual in classes that are meant to have subclasses, even if the virtual destructor does nothing. If a class is NOT meant to have subclassses, declare the destructor <strong>final</strong>.</p>

<h3 id="pure-virtual-methods-and-abstract-classes">Pure Virtual Methods and Abstract Classes</h3>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span> <span class="c1">// there are 2 kinds of Students, regular and co-op
</span><span class="nl">protected:</span>
  <span class="kt">int</span> <span class="n">numCourses</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// ...
</span>  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">fees</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Regular</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Student</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">fees</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// virtual - override
</span>  <span class="c1">// regular fees
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Coop</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Student</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">fees</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// virtual - override
</span>  <span class="c1">// coop fees
</span><span class="p">};</span>
</code></pre>
</div>

<p>What do we put for Student::fees? We don’t know, because every Student should be either regular or co-op.</p>

<p>We can explicitly given Student::fees <strong>NO implementation</strong> -&gt; <strong>pure virtual method</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">fees</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =0, NO IMPLEMENTATION
</span>  <span class="c1">// Called pure virtual method = no implementation
</span><span class="p">};</span>
</code></pre>
</div>

<p>A class with a <strong>pure virtual method cannot be instantiated</strong>, and the class is called an <strong>abstract class</strong>. Its purpose is to organize subclasses.</p>

<p>Subclasses of abstract classes are abstract as well, <strong>unless they implement ALL pure virtual methods.</strong> Non-abstract classes are called <strong>concrete classes</strong>.</p>

<p>UML: virtual and pure virtual methods: italics; abstract class: class name in italics; protected: #</p>

<h3 id="inheritance-and-copymove">Inheritance and Copy/Move</h3>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// Defines all copy/move operators here
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// DOES NOT define copy/move operators
</span><span class="p">};</span>

<span class="c1">// ===============
// client
</span><span class="n">Text</span> <span class="n">t</span> <span class="p">{</span><span class="s">"Algorithms"</span><span class="p">,</span> <span class="s">"CLRS"</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="s">"CS"</span><span class="p">};</span>
<span class="n">Text</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// No copy ctor in Text, what happens?
// calls Book's copy ctor,
// then goes field by field (i.e. default behaviour) for the Text part
// same for other opeartors
</span></code></pre>
</div>

<p>To write your own:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// copy ctor
</span><span class="n">Text</span><span class="o">::</span><span class="n">Text</span><span class="p">(</span><span class="k">const</span> <span class="n">Text</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">Book</span><span class="p">{</span><span class="n">other</span><span class="p">},</span> <span class="n">topic</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">}</span> <span class="p">{}</span>

<span class="c1">// copy assignment opor
</span><span class="n">Text</span> <span class="o">&amp;</span><span class="n">Text</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Text</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Book</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="c1">// superclass copy assignment
</span>  <span class="n">topic</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">;</span> <span class="c1">// assign field
</span>  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// move ctor
</span><span class="n">Text</span><span class="o">::</span><span class="n">Text</span><span class="p">(</span><span class="n">Text</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">Book</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">)},</span> <span class="n">topic</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">)}</span> <span class="p">{</span>

<span class="p">}</span>

<span class="c1">// move assignment opor
</span><span class="n">Text</span> <span class="o">&amp;</span><span class="n">Text</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Text</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Book</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">));</span>
  <span class="n">topic</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Note</strong>: Even though other “points” at an rvalue, other itself is an lvalue. std::move(x) forces lvalue x to be treated as an rvalue, so that move versions of operators can run</p>

<p><br /></p>

<h2 id="june-21-2016---lecture-15">June 21, 2016 - Lecture 15</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Text</span> <span class="n">t1</span><span class="p">{...};</span>
<span class="n">Text</span> <span class="n">t2</span><span class="p">{...};</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t1</span><span class="p">;</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">;</span>
</code></pre>
</div>

<p>What if we do</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="o">*</span><span class="n">pb1</span> <span class="o">=</span> <span class="o">*</span><span class="n">pb2</span><span class="p">;</span> <span class="c1">// ?
</span></code></pre>
</div>

<p>Then Book::operator= runs, <strong>partial assignment</strong> - copies only the Book part. How do we fix this? Try making operator= virtual.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="k">virtual</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span> <span class="c1">// make the copy assignment opor virtual
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="n">Text</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// override - virtual in subclass
</span><span class="p">};</span>
</code></pre>
</div>

<p>Note: different return types, but parameter types must be the same or it’s not an override, and thus WILL NOT COMPILE.</p>

<p>Thus assignment of a Book object to a Text variable would be allowed.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Text</span> <span class="n">t</span> <span class="p">{...};</span>
<span class="n">Book</span> <span class="n">b</span> <span class="p">{...};</span>
<span class="n">Text</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="o">*</span><span class="n">pb</span><span class="p">;</span> <span class="c1">// uses a book to assign to a text, BAD
</span>
<span class="c1">// ALSO
</span><span class="n">Comic</span> <span class="n">c</span> <span class="p">{...};</span>
<span class="n">Comic</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span> <span class="c1">// BAD
</span></code></pre>
</div>

<p>If operator= is non-virtual -&gt; partial assignment through base class pointers -&gt; BAD<br />
If operator= is virtual -&gt; compiler allows mixed assignment -&gt; BAD</p>

<p>Recommendation: All superclasses should be <strong>abstract</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AbstractBook</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">AbstractBook</span> <span class="o">&amp;</span><span class="n">opeartor</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">AbsratctBook</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span>
  <span class="c1">// prevents assignment through base class pointers from compiling
</span>  <span class="c1">// but implementation still available to subclasses
</span><span class="nl">public:</span>
  <span class="n">AbsratctBook</span><span class="p">(...);</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">AbsratctBook</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// "be abstract"
</span>  <span class="c1">// need at least one pure virtual method to make it abstract
</span>  <span class="c1">// if you don't have any, make dtor pure virtual
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">NormalBook</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractBook</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">NormalBook</span><span class="p">(...);</span>
  <span class="o">~</span><span class="n">NormalBook</span><span class="p">();</span>
  <span class="n">NormalBook</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NormalBook</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AbstractBook</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ============
// client
</span><span class="o">*</span><span class="n">pb1</span> <span class="o">=</span> <span class="o">*</span><span class="n">pb2</span><span class="p">;</span> <span class="c1">// DOES NOT COMPILE
</span></code></pre>
</div>

<p><strong>Prevents mixed &amp; partial assignment</strong>.<br />
Note: virtual destructor must always be implemented, even if it is pure virtual.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">AbsratctBook</span><span class="o">::~</span><span class="n">AbstractBook</span><span class="p">()</span> <span class="p">{}</span>
</code></pre>
</div>

<h2 id="templates">Templates</h2>

<p>Huge topic - just the highlights here</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">theList</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">List</span><span class="o">::</span><span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">};</span>
</code></pre>
</div>

<p><strong>Question:</strong> what if you want to store something else? Whole new class? Nah.</p>

<p><strong>Templates</strong>: class parameterized by a type</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Stack</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
  <span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="n">Stack</span><span class="p">(){...}</span>
<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">){...}</span>
<span class="n">T</span> <span class="n">top</span><span class="p">(){...}</span>
<span class="kt">void</span> <span class="n">pop</span><span class="p">(){...}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">theList</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="nf">Iterator</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">p</span><span class="p">{</span><span class="n">p</span><span class="p">}</span> <span class="p">{}</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...
</span>  <span class="p">};</span>

  <span class="n">T</span> <span class="nf">ith</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">addToFront</span><span class="p">(</span><span class="n">T</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ==================
// client
</span><span class="n">List</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l1</span><span class="p">;</span>
<span class="n">List</span> <span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">t2</span><span class="p">;</span>
<span class="n">t1</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">t2</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="n">l1</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">l1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span>
</code></pre>
</div>

<p>Compiler specializes template at the source code level, before compilation begins. Refer to /string/istream/ostream templates.</p>

<h2 id="the-standard-template-library-stl">The Standard Template Library (STL)</h2>

<p>Large number of useful templates</p>

<p>E.g. dynamic length arrays: vectors</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span> <span class="c1">// vector&lt;int&gt; v(4,5) = {5,5,5,5};
</span><span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">// {4,5,6}
</span><span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// {4,5,6,7}
</span></code></pre>
</div>

<p>Looping over vectors:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OR
</span><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// To iterate in reverse
</span><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span>

<span class="c1">// To remove last element
</span><span class="n">v</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

<span class="c1">// Use iterators to remove items from inside the vector
</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="c1">// erase element 0
</span><span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// erase element 3
// returns an iterator to first item after the erase
</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="c1">// erase item pointed to by it
</span><span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// erase last item
</span>
<span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// i-th element of v; unchecked: out of bounds -&gt; undefined behaviour
</span><span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// checked version of v[i], what happens if i is out of bounds
</span></code></pre>
</div>

<p><strong>Question</strong>: What should happen?</p>

<p>Problem: Vector can detect the error, but doesn’t know whatto do about it</p>

<p>C Solution: function returns a status code, or set the global variable errno; encourages programmers to ignore error checks</p>

<p>C++ Solution: when an error condition occurs, the function raises an exception</p>

<p><br /></p>

<h2 id="june-23-2016---lecture-16">June 23, 2016 - Lecture 16</h2>

<h2 id="exceptions">Exceptions</h2>

<p>What happens? By default, execution stops. But we can write <strong>handler</strong> to <strong>catch</strong> exceptions and deal with them. vector <T>::at throws exception out_of_range.</T></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdexcept&gt;
</span><span class="c1">// ...
</span><span class="n">try</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// statements that may raise an exception
</span>  <span class="c1">// go in the try block
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">out_of_range</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"range error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre>
</div>

<p>Consider:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="n">out_of_range</span> <span class="p">{</span><span class="s">"f"</span><span class="p">};</span> <span class="c1">// raise an exception
</span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">h</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">g</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">h</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">out_of_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>What happens?</p>

<p>main calls h, h calls g, g calls f, f throws, g has no handler for out_of_range, control goes back through the call chain (unwinds the stack) until a handler is found. Control goes all the way back to main, main handles the exception.</p>

<p>If no one handles the exception, program terminates.</p>

<p>What is out_of_range? It’s a class.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">throw</span> <span class="n">out_of_range</span> <span class="p">{</span><span class="s">"f"</span><span class="p">};</span> <span class="c1">// invokes a ctor with arg "f" and throws it
// "f" is auxiliary information
</span></code></pre>
</div>

<p>To examine auxiliary information:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">out_of_range</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints "f"
</span><span class="p">}</span>
</code></pre>
</div>

<p>A handler might do part of the recovery job - execute some corrective code and raise another exception:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">someErrorType</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">throw</span> <span class="n">someOtherError</span><span class="p">(...);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Or throw the same exception:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">someErrorType</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The difference between throw and throw s. Throw is used when an actual type of s is retained (most cases), it rethrows the same exception object it caught; throw s: s may be a subtype of someErrorType, throw rethrows a new exception of type someErrorType.</p>

<p>A handler can act as a catch-all:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span> <span class="c1">// catches all exceptions
</span>  <span class="c1">// ...
</span><span class="p">}</span>
</code></pre>
</div>

<p>You can throw anything you want - doesn’t have to be objects</p>

<p>Define your own classes (or use appropriate existing ones) for errors. E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BadInput</span><span class="p">();</span>

<span class="n">try</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">BadInput</span><span class="p">{};</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">BadInput</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// catch by ref to prevent slicing
</span>  <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="c1">// ...
</span><span class="p">}</span>
</code></pre>
</div>

<p>Note:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BaseExn</span><span class="p">{};</span>
<span class="k">class</span> <span class="nc">DerivedExn</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseExn</span><span class="p">{};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DerivedExn</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">BaseExn</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// BaseExn type
</span>  <span class="k">throw</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="n">f</span><span class="p">();</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">DerivedExn</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... DerivedExn handler
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">BaseExn</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... BaseExn handler
</span><span class="p">}</span>
</code></pre>
</div>

<p>Which handler runs? BaseExn handler runs, as the type of the reference (i.e. the static type of the object) determines the handler.</p>

<p>Some standard exceptions:</p>

<ul>
  <li>length_error - attempting to resize strings/vectors that are too long</li>
  <li>bad-alloc - new fails</li>
  <li>ios::failure - I/O streams fail; refer to lectures/c++/exceptions</li>
</ul>

<p><strong>NEVER NEVER NEVER let a destructor throw an exception</strong></p>

<ul>
  <li>If the dtor was executed during stack unwinding while dealing with another exception, you now have two active unhandled exceptions, and the program will terminate immediately</li>
</ul>

<h2 id="design-patterns-continued">Design Patterns (Continued)</h2>

<p><strong>Guiding Principle</strong>:</p>

<ul>
  <li>Program with interfaces not implementations</li>
  <li>Abstract base classes define the interface</li>
  <li>Work with pointers to an abstract base class and call their methods</li>
  <li>Concrete subclasses can be swapped in and out</li>
  <li>Abstracting over a variety of behaviours</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractIterator</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Set</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractIterator</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AbstractIterator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">AbstractIterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(...)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractIterator</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Then you can write code that operates over iteartors:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foreach</span><span class="p">(</span><span class="n">AbstractIterator</span> <span class="n">start</span><span class="p">,</span> <span class="n">AbstractIterator</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">);</span> <span class="c1">// f must be a callible entity
</span>    <span class="o">++</span><span class="n">start</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// this works over both Lists and Sets
</span>
<span class="n">List</span> <span class="n">l</span><span class="p">;</span>
<span class="n">foreach</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">someFunction</span><span class="p">);</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="june-28-2016---lecture-17">June 28, 2016 - Lecture 17</h2>

<h2 id="observer-design-pattern">Observer Design Pattern</h2>

<p>aka <strong>publish-subscribe model</strong></p>

<p>Publisher/Subject - source of data, generates data; Subscribers/Observers - receive data and react to it.</p>

<p>Sequence of the model calls:</p>

<ol>
  <li>Subject’s state is updated()</li>
  <li>Subject::notifyObservers() -&gt; calls each observer’s notify();</li>
  <li>Each observer calls ConcreteSubject::getState() to react accordingly</li>
</ol>

<p>E.g. horse races; subject publishes winners, observers (individual betters) declare victory when their horse wins.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Subject</span> <span class="p">{</span>
  <span class="n">vector</span> <span class="o">&lt;</span><span class="n">Observers</span> <span class="o">*&gt;</span> <span class="n">observers</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">attach</span><span class="p">(</span><span class="n">Observer</span> <span class="o">*</span><span class="n">ob</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">observers</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">ob</span><span class="p">);</span> <span class="c1">// add to observers
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">detach</span><span class="p">(</span><span class="n">Observer</span> <span class="o">*</span><span class="n">ob</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// remove
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">notifyObservers</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">ob</span><span class="p">;</span> <span class="n">observers</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ob</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Subject</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// make class abstract
</span><span class="p">};</span>

<span class="n">Subject</span><span class="o">::~</span><span class="n">Subject</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// dtor must have user-defined implementation (since declared pure virtual)
</span>
<span class="k">class</span> <span class="nc">Observer</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="n">notify</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Horserace</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Subject</span> <span class="p">{</span>
  <span class="n">ifstream</span> <span class="n">in</span><span class="p">;</span> <span class="c1">// get data from that file
</span>  <span class="n">string</span> <span class="n">winner</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Horserace</span><span class="p">(</span><span class="n">string</span> <span class="n">source</span><span class="p">)</span> <span class="o">:</span> <span class="n">in</span><span class="p">{</span><span class="n">source</span><span class="p">};</span>
  <span class="n">bool</span> <span class="n">race</span><span class="p">();</span> <span class="c1">// true if there was a race, false if EOF
</span>  <span class="n">string</span> <span class="nf">getState</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">winner</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Bettor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span> <span class="p">{</span>
  <span class="n">Horserace</span> <span class="o">*</span><span class="n">subject</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">myHorse</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Bettor</span><span class="p">(...)</span> <span class="p">...</span> <span class="p">{</span>
    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">notify</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">winner</span> <span class="o">=</span> <span class="n">subject</span><span class="o">-&gt;</span><span class="n">getState</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">winner</span> <span class="o">==</span> <span class="n">myHorse</span> <span class="o">?</span> <span class="s">"Win"</span> <span class="o">:</span> <span class="s">"Lose"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// main
</span><span class="n">Horserace</span> <span class="n">hr</span><span class="p">;</span>
<span class="n">Bettor</span> <span class="n">Larry</span><span class="p">(</span><span class="n">hr</span><span class="p">,</span> <span class="s">"Larry"</span><span class="p">,</span> <span class="s">"Pig4"</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="n">hr</span><span class="p">.</span><span class="n">race</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">hr</span><span class="p">.</span><span class="n">notifyObservers</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Simplifications</strong>:</p>

<ol>
  <li>If only one type of subject, could merge Subject and ConcreteSubject</li>
  <li>If state is trivial (so that just let notify tells you all you need to know), then don’t need getState()</li>
  <li>If subject = observer (e.g. cell in a grid in a spreadsheet), could merge these classes</li>
</ol>

<h2 id="decorator-pattern">Decorator Pattern</h2>

<ul>
  <li>Want to add features to an object at runtime</li>
</ul>

<p>E.g. Operating System: basic window, then add menu, then add scrollbar, and we want to change these at runtime</p>

<p>class component - interface - operations</p>

<p>You will provide</p>

<p>ConcreteComponent - implements the interface</p>

<p>Decorators all inherit from Decorator, which inherits Component. Thus every Decorator is a Component and every Decorator has a Component</p>

<p>A window with a scrollbar is a window, and has a pointer to the underlying plain window. Windw with scrollbar and menu is a window and has a pointer to a pointer to a window with scrollbar, which has a pointer to a plain window</p>

<p><br /></p>

<h2 id="june-29-2016---tutorial">June 29, 2016 - Tutorial</h2>

<p>protected: acts like private, but subclasses can access superclass fields; within the hierarchy</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Computer</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">makeCall</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Making call"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Testing"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Smartphone</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Computer</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">makeCall</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Mobile"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">testCall</span><span class="p">(</span><span class="n">Computer</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">c</span><span class="p">.</span><span class="n">test</span><span class="p">();</span>
  <span class="n">c</span><span class="p">.</span><span class="n">makeCall</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Smartphone</span> <span class="n">lmao</span><span class="p">;</span>
  <span class="n">testCall</span><span class="p">(</span><span class="n">lmao</span><span class="p">);</span>
  <span class="n">Computer</span> <span class="o">*</span><span class="n">laptop</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Smartphone</span><span class="p">;</span>
  <span class="n">laptop</span><span class="o">-&gt;</span><span class="n">makeCall</span><span class="p">();</span>
  <span class="n">lmao</span><span class="p">.</span><span class="n">makeCall</span><span class="p">();</span>
  <span class="n">lmao</span><span class="p">.</span><span class="n">test</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

  </div>

</article>

<div id="disqus_thread"></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//dzklavier.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
      </div>
    </div>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-77018906-1', 'auto');
  ga('send', 'pageview');

</script> 


    <footer class="site-footer">

  <style>
    .footer-col-3 p, .contact-list {
      font-size: 1rem;
    } 
  </style>

  <div class="wrapper">


    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list social-media-list">
          <li>Dadi "D.Z." Zhang</li>
          <li><a href="mailto:d236zhan@uwaterloo.ca">d236zhan@uwaterloo.ca</a></li>
          
          <li>
            <a href="https://github.com/dzeedzed"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">dzeedzed</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        
      </div>

      <div class="footer-col footer-col-3">
        <p>Dadi "D.Z." Zhang | Coder. Developer. Language enthusiast. Go fanatic. Jays fan. Worships 442.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
