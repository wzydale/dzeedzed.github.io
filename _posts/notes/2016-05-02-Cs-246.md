---
layout: post
title: CS 246 - Object-Oriented Software Development
date: 2016-05-02 18:56:00 -0400
categories: notes
---

    CS 246 - Object-Oriented Software Development
    Instructor: Brad Lushman
    Section: 001
    Location: MC 4045
    Time: Tuesdays and Thursdays 10:00am - 11:20am
    Tutorials: MC 4060 Wednesdays 1:30pm - 2:20pm
    Term: Spring 2016


May 3, 2016 - Lecture 1
-----------------------

**Grading Scheme**

+ Assignments - 0(A0) 7 7 7 7 12(project) = 40%  
+ Midterm (4:30pm - 6:20pm, June 23 (Th), 2016) = 20%   
+ Final = 40%

This course requires you to work in Linux. There are several options:

1. Lab machines  
2. Install Linux on your own machines  
3. Make SSH connection to school machines (Use Putty (putty.exe) on Windows, winscp for file transfer, XMing for Xwindows)  
4. Download cygwin - Linux-like environment for Windows
5. Get a Mac

**4 Modules in this Course:**

* Linux Shell (2 weeks)
* C++ Language, C++14 (10 weeks)  
* Tools
* Software Engineering (design etc.)

"Homework": Go on Piazza -> Linux Reference Sheet -> Save and print

Module 1: Linux Shell
---------------------

A shell is an interface to the operating system, i.e. how we get the OS to do things (run programs, manage files etc.). There are two kinds of shells: graphical (with icons and clicking) and the command line. The shell we will use is Bash. Check if you are using Bash, login to shell and type in:

    $ echo $0

It should return "bash".

**Linux file system: working with files**

**cat** - short for concatenate; display contents of a file (e.g. cat user/share/dict/words). In Linux, a directory is considered a special kind of file

**ls** - list files in the current directory (non-hidden files)

**ls -a** - list all files (including hidden; hidden files start with a ".")

**pwd** - print current directory (pwd = print working directory)

What happens when we only type in "cat"? It just kind of sits there, waiting for input. It's kinda like a parrot, repeating what you typed in. If we can capture the output into a file...

    $ cat > output.txt

It would capture the input. NOT RECOMMENDED: ^C. It would prevent cat from doing clean-up. Let it finish on its own: ^D at the beginning of a line sends an "EOF" signal to cat.

One greater than sign replaces, two appends.  
In general, command args > file
executes command args + captures the output in file -> called **output redirection**.

Using less than sign, takes in input from the file.

    $ cat < output.txt

The line above displays the file. Seems to be equivalent to what we have before. Are these two things the same? NO. The reason is very important:

* cat input.txt -> passes the NAME input.txt to cat as an argument. Cat opens input.txt and displays its contents

* cat < input.txt -> the shell opens the file and passes the contents to cat IN PLACE of keyboard input

**wc** - word count, displays numbers of lines, words, and characters of a file

**cat *.txt** - *.txt globbing pattern -> matches any sequence of characters (the shell finds all files that mathch the pattern)

**cat < *.txt** - ERROR! The shell will only attach one file to cat's input stream

Many (but not all) commands take both kinds of inputs:

**cat < input.txt > output.txt** - sends chars from input.txt to output.txt; effectively a copy-paste action

Every process is attached to 3 streams. Stdin goes into the program, stdout and stderr come out of the program. Stdin -> program -> stdout and stderr. By default, stdin = keyboard, stdout, stderr = screen.
< connects stdin to file, > connects stdout to file, 2> stdrr. Stderr separates output stream from error messages, so that output error messages can go to different places, and that error messages don't cut/block output files.

Also, stdout may be **buffered**. System may assemble characters before displaying. However, stderr isn't buffered, because user needs to see error messages immediately.

**Pipes**: Make one program's output(stdout) another program's input(stdin). Example: How many words occur in the first 20 lines of sample.txt?

    head -n file

gives the first n lines of file

    wc -w

counts words (just print the word count)

so

    head -20 sample.txt | wc -w

Here, | (the pipe symbol) makes the output of the command before it the input of the command after it.

<br />

May 4, 2016 - Tutorial 1
---

To zip your assignment files, do:

    zip (directory where your files are).zip *

in the directory where the files are.


    marmoset_submit cs246 (question, e.g a0) (file you want to submit, zipped)

is how you submit assignments to Marmoset.

<br />

May 5, 2016 - Lecture 2
---

Suppose we have files words1.txt, words2.txt..., and each of them has one word per line. We want: A duplicate-free list of all the words used in any of these files

We need the following:

+ sort - sorts lines (man: Write sorted concatenation of all FILES(s) to standard output)
+ uniq - remove consecutive duplicate lines from input (man: filter adjacent matching lines from INPUT, writing to OUTPUT)

One possibility:

    cat words*.txt | uniq

What's the problem with this? We must sort our input first, because for aabaacd, it would produce abacd, with duplicates.

This should work:

    cat words*.txt | sort | uniq

Sort it first, then call uniq. But there's still a problem: it's way too inefficient, beacuse it cat(s) all the files together FIRST, and then sorts it.

This is better:

    sort words*.txt | uniq

Q: Is it possible to use the output onf one program as a __parameter__ to another?

Yes. E.g.

    echo "Today is $(date) and I am $(whoami)"

The shell executes date and whoami, and subsitutes the results into the command line.

WARNING:

    echo 'Today is $(date) and I am $(whoami)'

This will print the **LITERAL** interpretation, i.e. Today is $(date) and I am $(whoami)  
Single quotes do not execute the substitution.

    echo "$(ls words*.txt)"

prints a list of names of the text files:  
words1.txt  
words2.txt  
...

**Pattern Matching in Text Files**  
Use egrep (extended global regular expression print) = grep -E

    egrep pattern file

returns all lines that contain the pattern.

E.g. print lines that contain "cs246"

    egrep cs246 index.html

What about "cs246" OR "CS246"?

    egrep "cs246|CS246" index.html

The vertical bar (\|) means "OR", and the double quotes prevent the shell from interpreting the bar as a pipe.

We can use parentheses to group subexpressions together:

    egrep "(cs|CS)246" index.html

The patterns that egrep understands are called **regular expressions**. NOT globbing patterns.

"(c\|C)(s\|S)246" is equivalent to "[cC][sS]246"

**[...]** syntax says to match any SINGLE character in he square brackets. (a\|1\|c\|2) is equivalent to [a1c2].

**[^...]** matches any 1 character not in the square brackets.

"[cC][sS] ?246" allows for an optional space before the 246. ? syntax says to match 0 or 1 occurrences of the preceding expression.

\* syntax which matches 0 or more of the preceding expression. So (cs)\*246 -> 246, cs246, cscs246, cscscs246...  
cs(cs)*246 matches at least one cs at the front (eliminating the zero case)

(cs)+246 is equivalent to cs(cs)*246. The + syntax matches 1 or more of the preceding expression.

.* will match any sequence of characters

.+ will match any non-empty sequence of characters

"cs *246" matches any string starting with cs, followed by any string, followed by 246.

^ matches beginning of line

$ matches the end of line

^cs246 line starts with cs246

cs246$ line ends with cs246

Want all lines of even length

^(..)*$

The Other Section
===

Pipes allow us to hook the stdin of one program to the stdout of another. This is done using the pipe character \| between commands

    cmd1 args1 | cmd2 args2

**Regex Rules**:

+ Can use parentheses for a sub-pattern
+ Can use square brackets to match any one character in the square brackets
+ [^...] matches any one character EXCEPT those in the square brackets
+ A ? after a pattern or character represents 0 or 1 of that pattern/character
+ A * after a pattern/character represents 0 or more of that pattern/character
+ A + "1 or more"
+ . matches any SINGLE character
+ ^ and $ match the start and end of line respectively

E.g.  
.* - anything  
.+ - non-empty string  
^.+$ - all non-empty lines  
^.*$ - all lines  

^(..)*$ - grabs all lines with even number of characters

**Permissions**

* ls -l gives the long form listing of the files in the current directory  
* First 3 bits: Owner r-read w-write x-execute
* Middle 3 bits: Group
* Last 3 bits: Others
* r: ordinary files-> can be read, directories-> contents can be read, globbing workds, ls works
* w: ordinary files->can be modified, directories-> contents can be modified, add/remove
* x: file's contents can be executed as a program, directories->directories can be navigated (can cd into the directory)

**Changing Permissions**

* to change permissions use chmod

        chmod mode file

* mode is broken up to 3 parts - user, operator, and permissions
* user is either u (owner), g (group), o (other), or a (all)
* operator is either + (add), - (remove), = (set exactly)
* permissions are r, w, x

E.g.

    chmod o+r filename

gives other group read access to the file

    chmod o-r filename

is the reverse

    chmod a-r filename

then nobody can read it

    chmod u=rwx filename

then the owner can do anything with it.

**Shell Scripts**

A shell script is a file containing sequences of shell commands execueted as a program. For example if we wanted to print the date, current user, current dir.

    #!/bin/bash (this header tells the OS that this is a Bash script; allows the OS to interpret it the following as bash commands)
    date
    whoami
    pwd

.sh is the standard extension of a bash script, but you can put whatever you want. Don't forget permissions. Needs to be executable. Use chmod to give it executation rights.

**Variables**

+ Variables can be assigned with single equals.
+ x=1 (NO SPACES!!!)
+ use echo &{x} to grab the value of the variable x (parentheses run what's inside it in a "subshell") (curly braces are important: good practice)

**Shell Script Example**

Write a script that takes in a string to check if it is BAD. A string that can be found in a dict is bad.
General format of conditional statements in bash:

    if [ cond ]; then // the square brackets cannot "touch" what's inside
    ...
    elif [ cond ]; then
    ...
    else
    ...
    fi

**$?** contains the return value of the last-run command.
**$1** retrieves the first parameter

Create a .sh script as follows:

    #!/bin/bash

    egrep "^$1$" /usr/share/dict/words > /dev/null  # /dev/null is where data goes to DIE

    if [ $? -eq 0 ]; then //-eq compares
    echo Bad password
    else
    echo Maybe not the worst
    fi

And before you run it,

    chmod u+x goodpass.sh

In bash, the pound symbol (#) starts a comment.

<br />

May 10, 2016 - Lecture 3
---

Review:

    egrep pattern file

prints all lines in file that contain a match to pattern

**Shell Scripts Review**  

    #!/bin/bash  #"Shebang line"  
    date  
    whoami  
    pwd

To run the script in the current directory:

    ./myscript

**Variables**  

    x=1 #NO SPACES  
    echo $x #Use $ when fetching the value of a variable
    # No $ when setting a var ($ = "fetch the value of")
    # Good practice: ${x} - brace brackets, good style
    # All vars contain strings, e.g. x is the STRING 1, not the number/int

E.g.  
    dir = ~/cs246
    echo ${dir}
    /u/bmlushma/cs246 # get the absolute path
    ls ${dir} # contents of cs246

There are some global variables:  
    env # environment variables
    echo ${PATH} # list of directories (where the shell looks for programs)

When you type a command, the shell searches the list in order for a matching program.

    echo * # prints all files in the current directory
    echo "*" - suppresses globbing pattern
    echo '*' - suppresses globbing pattern
    echo "$PATH" # expands the quotes, $-expansion happens
    echo '$PATH' # absolutely literally

**Special Variables for Scripts**  
    $1, $2, ... # command-line arguments

E.g. check whether a word is in the dictionary

    ./isItAWord hello

    #!/bin/bash

    egrep "^$1$" /usr/share/dict/words # prints the word if found, prints nothing if not

E.g. a good password is not in the dictionary

    egrep "^$1$"/usr/share/dict/words > /dev/null # to black hole, suppress output
    # we could store the out in a variable
    x=$egrep ...

Note: every program returns a status code when finished: egrep returns 0 if found, 1 if not found (general convention in UNIX: 0 means success, non-0 means failure)

    $? # status of the most recently executed command

    if [ $? -eq 0]; then # the first square bracket is the name of a program, and what's inside the square brackets are its arguments
        echo Bad password
    else
        echo Maybe a good password
    fi

We want to verify that the user has inputted the correct number of arguments, and print a usage message if it's wrong

    #!/bin/bash

    usage() {
        echo "usage: $0 password" # $0 is the name of the script/program as it was typed
    }

    if [ $# -ne 1 ]; then # $# is the number of arguments
        usage
        exit 1
    fi

    egrep ... # as established above

Now this is a good program that can also check if the input is valid.

The general structure of conditional statements is as follows:

    if [ cond ]; then
        ...
    elif [ cond ]; then
        ...
    else
        ...
    fi

Comparisons to other conditions: Check the Linux reference sheet

**Loops**  

Loops: print the numbers from 1 to $1

    #!/bin/bash
    x=1
    while [ $x -le $1 ], do
        echo $x
        x=$((x+1)) # $(()) for arithmetic
    done

Looping over a list, e.g. rename all .cpp to .cc  

    #!/bin/bash
    for name in \*.cpp; do # for ... in sets the variable to each word in the given list
        mv ${name} ${name%cpp}cc # value of name, without trailing cpp
    done

e.g. how many times does word $1 occur in the file $2?

    #!/bin/bash
    x=0
    for word in $(cat "$2"); do #good idea - enclose vars in double quotes, prevent bad input
        if [ $word == $1 ]; then #String equality == instead of -eq
            x=$((x+1))
        fi
    done
    echo $x

e.g. Payday is the last Friday of the month. When is this month's payday?

2 tasks here: compute date and fomat the answer

    cal | awk '{print $6}' | egrep "[0-9]" | tail -1

<br />

May 11, 2016 - Tutorial 2
---

Want: stdout and stderr in the same file

  printer >> out 2> out # works
  printer > out 2>> out #doesn't work

  #Alternatives
  printer &> out
  printer > out 2>&1
  printer 2>out 1>&2

Want: Give the top 10 most commonly used words

  sort wordCollection | uniq -c | head # problem
  sort wordCollection | uniq -c | sort | tail # works
  sort wordCollection | uniq -c | sort -k1,1rn -k2,2 | head # sort takes in arguments -k as key; 1,1 = first character r = reverse order(descending) n = sort in numerical order, 2 break ties
  sort wordCollection | uniq -c | sed 's_6_12_' | sort | tail # Use sed to replace 6s with 12s and then sort lexigraphically
  sort wordCollection | uniq -c | sed 's_6_12_' | sort -k1,1nr -k2,2 | head

egrep:

^ - match beginning of line  
$ - match end of a line  
^$, ^a$  
. - matches any single character  
? - matches preceeding pattern 0 or 1 times  
\* - 0 or more  
\+ - 1 or more  

Note: abc* != (abc)*
ab, abccc, abcccccc, in comparison to abc, abcabc, abcabcabc

<br />

May 12, 2016 - Lecture 4
---
Recall: compute payday (last Friday of the month); report nicely

    #!/bin/bash

    answer() {
      if [ $1 -eq 31 ]; then # inside a fn - $1, $2 etc are the args to the function
        echo "This month: the 31st"
      else
        echo "This month: the ${1}th"
      fi
    }

    answer $(cal | awk '{print $6}' | egrep "[0-9]" | tail -1) # the whole thing after the dollar sign is ${1}

Generalize to any month:

cal June 2016 # gives calendar for June 2016  
Want: let payday June 2016 gives June 2016's payday

    #!/bin/bash

    answer() {
      if [ $2 ]; then
        preamble=${2}
      else
        preamble='This month'
      fi

      if [ $1 -eq 31 ]; then
        echo "${preamble}'s payday is on the 31st."
      else
        echo "${preamble}'s payday is on the ${1}th."
      fi
    }

    answer $(cal $1 $2 | awk '{print $6}' | egrep "[0-9]" | tail -1) $1 # if $1 and $2 are supplied, revert back to previous behaviour

## Software Engineering: Testings(aka QA lmao) ##

+ essential part of program development
+ ongoing, not just at the end
  + begins **BEFORE** coding
  + test suites - expected behaviour
+ NOT debugging - cannot debug without first testing
+ cannot guarantee correctness, can only prove wrongness
+ ideally, developer + tester should be different people

**Human Testing** - Humans look over code, find flaws, code inspection, walkthroughs  
**Machine Testing** - Run the program on selected input, check against spec, can't test everything - choose test cases carefully  

**Black/White/Grey Box Testing**: no/full/some knowledge of program implementation  
Start with black box, supplement with white box

  + various classes of input, e.g. numerical ranges, positive/negative
  + Boundaries of valid ranges (edge cases)
  + Multiple simulatenous boundaries (corner cases)
  + Intuition/Experience ("Ayy I've seen programs like that before, better try blah lmao")
  + Extreme cases (e.g. integer overflow; how large can the integer get before it breaks)

White box - executes all logical paths through the program

  + run through the true part and false branch of conditional statements
  + every way you can go from start to finish should be tested  
  + make sure every function you write actually gets called

**Performance Testing** - Is the program fast enough?  
**Regression Testing**  

  + Make sure new changes to the program don't break old tests  
  + test suites (ALWAYS ADD TESTS; NEVER SUBTRACT), testing scripts

## Module 2: C++ (ayy) ##

Hello World in C:

    #include <stdio.h>

    int main() {
      printf("Hello World!\n");
      return 0;
    }

Hello World in C++:

    #include <iostream>
    using namespace std;

    int main() {
      cout << "Hello World" << ende;
      return 0;
    }

Notes:  

+ main MUST return int in C++  
+ stdio.h, printf still available in C++
+ preferred C++ I/O: header <iostream>

Output:

    std::cout << ___ << ____ << ____  
    std::ende = end-of-line

Using namespace std lets you say cout and ende instead of std::cout and std::ende

Return statement - returns status code to the shell ($?). If left out, main returns 0

**Compiling C++ Programs**

On the school Linux environment:

        g++-5 -std=c++14 program.cc -o program
        (-o program is the name of the executable binary (if not specified: a.out))
        // OR
        g++14 program.cc -o program // if you have done A0 and made the alias
        // Run the program by
        ./program

**Input/Output**  
  3 IO streams: cout - for printing to stdout, cin - for reading from stdin, cerr - for writing to stderr

  Operators: << "put to" - Output, >> "get from" - input

      cerr << x // x flows to cerr
      cin >> x // input flows to x
      // The operator points in the direction of information flow

E.g. Add 2 numbers  

    #include <iostream>
    using namespace std;

    int main() {
      int x, y;
      cin >> x >> y; // cin ignores whitespace; gets two integers, ignoring whitespace
      cout << x+y ;
    }

If the input doesn't contain an integer next - statement fails, value of the var is undefined

What if the input is exhaustive, before we get two ints? - Same as above

If the read failed: cin.fail() will be TRUE  
If we got an EOF: cin.fail() and cin.eof() will be both TRUE; cin.eof() not until the attempted read fails

E.g. Read all ints from stdin, echo one per line to stdout. Stop on bad input or EOF

    int main() {
      int i;
      while(true) {
        cin >> i;
        if (cin.fail()) break;
        cout << i << ende;
      }
    }

<br />

May 17, 2016 - Lecture 5
---

E.g. Read all ints from stdin + echo, one per line, to stdout, stop on bad input of EOF

	int main() {
		int i;
		while (true) {
			cin >> i;
			if (cin.fail()) {
				break;
			}
			cout << i << endl;
		}
	}

Recall: if read fails, cin.fail() will be true; if EOF: cin.fail() and cin.eof() both true, but not until the attepted read fails

Note: there is an implicit conversion from cin to bool, so cin can be used as a condition. The conversion is that it's true if fail/bad/eof bits are clear, or false if fail/bad/eof set

E.g. v2.0

	int main() {
		int i;
		while (true) {
			cin >> i;
			if (!cin) { // using cin as the condition, means the same thing as the other program
				break;
			}
			cout << i << true
 		}
	}

Note: >> is C's right bitshift operator; a >> b shifts a's bits to the right by b spots

E.g. 21 >> 3; 21 in binary is 10101, push the last 3 digits off the cliff, so it becomes 10 in binary, which is 2; equivalent to dividing by 2 to the b-th power, ignoring remainders

But when the left hand side is cin, this is the "get from" operator

	operator >>
 	// inputs: LHS cin (istream), RHS data (variety of types); output: return cin (istream)
 	// This is why we can write: cin >> x >> y >> z; cin >> x produces cin, x gets populated, and now we get cin >> y >> z, and so on.

 E.g. v3.0

 	int main() {
 		int i;
 		while (true) {
 			if (!(cin >> i)) { // using it as both a condition and populating i
 				break;
 			}
 			cout << i << endl;
  		}
 	}

 E.g. v4.0

 	int main() {
 		int i;
 		while(cin >> i) { // changing the break statement into a single while loop
 			cout << i << endl
 		}
 	}

 E.g. read and echo ints until EOF, skip non-integer input

 	int main() {
 		int i;
 		while (true) {
 			if (!(cin >> i)) {
 				if (cin.eof()) {
 					break;
 				}
 				cin.clear(); // clears the fail bit, so that cin is ready to read again
 				cin.ignore(); // throws away the next character
 			} else {
 				cout << i << endl;
 			}
 		}
 	}

 Reading strings: type std::string (#include <string>)

 	int main() {
 		string s;
 		cin >> s;
 		cout << s << endl;
 	}

 	// skips leading white space;
 	// stops at whitespace (reads one word)

 What if we want the hvitespace? Use getline(cin, s), it reads from the current position to next newline, into s.

 	cout << 95 << endl; // prints 95

 What if we want to print a number in hexadecimal?

 	cout << hex << 95 << endl; // this will print 95 in hex, 5f
 	// hex is std::hex, is the I/O manipulator, reconfigures the output string, all subsequent ints are printed in hex (FOR THE REST OF ETERNITY, nah jkjk till the program terminates); A bit of an overkill?
 	cout << dec; // goes back to decimal

 	// Other manipulator, SEE NOTES, don't forget
 	#include <iomanip>

 Stream abstraction applies to other fsources of data

 **Files** - Read from a file instead of stdin  
 	std::ifstream reads from a file  
 	std::ofstream writes to a file

 File access in C:

 	#include <stdio.h>

 	int main() {
 		char s[256];
 		FILE *file = fopen("suite.txt", "r"); // r = read mode; file is a handle
 		while (true) {
 			fscanf(file, "%255s", s);
 			if (feof(file)) break;
 			printf("%s\n", s);
 		}
 		fclose(file);
 	}

 File access in C++:

 	#include <iostream>
 	#include <fstream>
 	using namespace std;

 	int main() {
 		ifstream file{"suite.txt"}; // creating and initializing an ifstream opens the file
 		string s;
 		while (file >> s) {
 			cout << s << endl;
 		}
 		// IMPORTANT: the file is closed when the variable (in this case, file), goes out of scope; when the program stops, it's popped of the runtime stack, it then closes.
 	}

 Anything you can do do with cin and cout, you can do with an ifstream or an ofstream. ANYTHING.

 E.g. string - attach a stream to a string and read/write it

	 #include <sstream> // std::istringstream and std::ostringstream read from/write to a string

	 int hi = ..., lo = ...;
	 ostringstream ss; // think of it as a sock
	 ss << "Enter a # between" << lo << "and" << hi; // stuffing the sock with string
	 string s = ss.str(); // cuts open the sock and gets the string
	 cout << s << endl;

E.g. convert a string to a #

	int n;
	while (true) {
		cout << "Enter a number" << endl;
		string s;
		cin >> s;
		istringstream ss {s};
		if (ss >> n) break; // stop if you get int
		cout << "I said,";
	}
	cout << "You entered" << n << endl;

Example revisited - echo numbers, skip non-numbers

	int main() {
		string s;
		while (cin >> s) {
			istringstream ss {s};
			int n;
			if (ss >> n) {
				cout << n << endl;
			}
		}
	}

Strings:

In C, array of char (char* or char[]), terminated by IO. Must manage own memory: get morememory when strings grow; Easy to overwrite IO and corrupt program

In C++, strings grow as needed, and thus safer

E.g. string s{"Hello"}; // it's still an array (C-style string); C++ string created from C string on initialization

String Operations: Equality Inequality, s1 == s2, s1 != s2  
Comparison: s1 <= s2 (lexicographical comparison)  
Length: s.length()  
Extract individual characters: s[0], s[1] etc.  
Concatenation: s3 = s1 + s2, s3 += s4  
More details: SEE NOTES

Default Function Parameters

	void printSuiteFile(String name = "suite.txt") { // default value
		...
	}

	printSuiteFile("suite2.txt");
	printSuiteFile(); // prints from suite.txt

Note: optional params must be last; if you leave out two parameters, they have to be the last two; 3,3 etc.

<br />

May 18, 2016 - Tutorial 2
---

##Shell Scripting##

+ Exit codes are important; non-zero return/exit value = ERROR
+ Write to the correct stream
+ Scoping for subroutines, anything defined befored a subroutine is visible(and modifiable) in the subroutine, except positional arguments (\$1, \$2, ...)

##Testing##

+ Don't have to worry about invalid inputs
+ Testing is hard
+ Try sanity checks ("No one could make this mistake")
+ Good coverage: boundary/edge and corner cases, equivalence classes, weird cases

**Possible Test Cases**  

	+ Equivalence courses: small, medium, and large values of the target
	+ Boundary/edge cases: test containing 0 as target

##C++ I/O##

+ DO NOT USE C I/O
+ 3 default streams: cout, cerr, cin
+ If a read from cin fails, **all subsequent reads will fail**

##Make I/O More Robust##

+ Reading from cin could fail in two ways
	+ EOF
	+ got unexpected input
+ When a read fails, a flag goes up in cin
	+ cin.fail() will be true
	+ Only cin.fail() will be true if it was an error
	+ Both cin.fail() and cin.eof() will be true if it was EOF
	+ How to clear: cin.clear() -> put all cin flags down and turn it into a valid state
	+ How to continue: cin.ignore(); order is important: clear then ignore
+ If you want the entire line, use getline(cin, s)

##Strings##

+ Encapsulates something like char* in C
+ Has length, insert, delete, search methods
+ Can be accessed like an array
+ include<string>
+ at(index): checks for bounds and throws an exception if out of bounds
+ [index]: does not check for bounds

<br />

May 19, 2016 - Lecture 6
---

**Overloading**  

C:

  int negInt(int n) { return -n; }
  int negBool(bool b) { return !b; }

C++: Functions with different parameter lists can share the same name

  int neg(int n) { return -n; }
  int neg(bool b) { return !b; }
  // example of overloading

Compiler uses number of types of arguments to decide which neg is being called.

Overloads must differ in number of type of arguments, not just on the return type. We've seen this before: >>, << (operators, could be right shift/left shift, or could be input and output; the behaviour depends on types of args)

**Structs**  

    struct Node {
      int data;
      Node \*next;
    }; // don't forget the semicolon

    Node n1{5, nullptr}; // nullptr is the syntax for a null pointer in C++.
    // Do not say NULL or 0 in this class!!!!!!! 0 will be always treated as a number, not pointer

    const Node n2 = n1; // constant struct means that its fields cannot be changed; n2 is an immutable copy of n1

**Parameter Passing**  

Recall:

    void inc(int n) {
      n = n + 1;
      // ...
      int x = 5;
      inc(x);
      cout << x << endl; // prints 5; call-by-value
      // inc gets a copy of x and modifies the copy, not the original
    }

Sol'n: If a function needs to modify its arugument - pass a pointer

    void inc(int n) {
      \*n = \*n + 1;
      // ...
      int x = 5;
      inc(&x); // x's address passed by value, inc changes value at that address, visible to caller
      cout << x << endl; // prints 6
    }

Question: Why cin >> x and not cin >> &x?  
Answer: C++ has another pointer-like type: references

**References (IMPORTANT!!!)**  

    int y = 10;
    int &z = y; // NEW. Ampersand after int. z is an **lvalue reference** to int ( which is y)
                // Like a constant pointer, similar to int \*const z = &y;
                // (z is a constant pointer to an int; z will always point to y implied by const)
                // (but y is not constant; you can change y however you like)

References are like constant pointers with automatic dereferencing.

    z = 12; // NOT \*z = 12
    int \*p = &z; // &z gives the address of y. No matter what you do to z, you do it y. In all cases, z behaves exactly like y. z is an alias for y.

**Things you CANNOT do with lvalue references**  

+ leave them uninitialized, because they are constant, cannot assign later
  + must be initialized with something that actually has an address (an lvalue) since references are pointers
  + E.g.
      int &x = 3; // WRONG: WONT COMPILE, because 3 is not an address
      int &x = y + z; // WRONG
      int &x = y; // GOOD
+ create pointer to a reference: int &* x; // WRONG
  + reference to a pointer is legal: int \*& x;
+ create a reference to a reference: int && x = ...; // means something different (will discuss later)
+ create an array of references: int &a[] = {x, x, x}; // given the similarity between arrays and pointers

**Things you CAN do with lvalue references**  

+ Pass as function parameters:

    void inc(int &n) { // const pointer to the argument (x), thus changes to n affect x
      n = n + 1; // no pointer dereferencing
    }
    int x = 5;
    inc(x);
    cout << x << endl; // prints 6

Why does cin >> x work? It takes x by reference

istream &operator >> (istream &in, int &n);

**Pass-by-value**

E.g.

    int f(int n) {...} // copies the argument
    // if the argument is big, copying is expensive

    struct ReallyBig{}; // Massive struct with thousands of fields
    int f(ReallyBig rb) {...} // copying would be slow

    int g(ReallyBig &rb) {...} // pass as reference, no copy, it's an alias, fast
    // this could change rb in the caller, in contrast to pass by value, which guarantees
    // no changes to rb itself after calling

    int h(const ReallyBig &rb) {...} // pass constant reference, no copy, fast, and the parameter cannot be changed

Advice: prefer pass-by-const-reference over pass-by-value for anything larger than an int, unless the function needs to make a copy anyway - then maybe pass by value. DEFAULT SHOULD BE PASS-BY-CONST-REF. Sizeof reference is same as size of a pointer

Also:

    int f(int &n) {...}
    int g(const int &n) {...}

    f(5); // LMAO FAILS WON'T COMPILE, because 5 does not have an address; can't initialize an lvalue reference (n) to a literal value;
    // if n changes, can't change the literal 5
    g(5); // OK; since n can never be changed, the compiler will allow this
    // How though? The compiler creates a temporary location to hold 5, so that n has something to point at

That's why const ref is so CRITICALLY IMPORTANT.

**Dynamic Memory Allocation**  

C:

    int \*p = malloc(n * sizeof(int));
    free(p);
    // Don't use these though

C++: new/delete

E.g.

    struct Node {
      int data;
      Node \*next;
    }

    Node \*np = new Node; // allocates a Node on the heap and np points to it
    // ...
    delete np;
    // all local variables reside on the stack
    // deallocated (popped) when their scope ends
    // Allocated memory is on the heap, it stays there until you get rid of it
    // Remains allocated until delete is called

If you don't delete - MEMORY LEAK

**Arrays on the heap**

    Node \*myArray = new Node[10];
    // ...
    delete [] myArray; // The square brackets have to be there

E.g.

    Node getMeANode() { // copy to caller's frame, expensive
        Node n;
        return n;
    }

    Node &getMeANode() { // WORST. Returns a ref (essentially a pointer) to stack-allocated data, which is dead on return
        Node n;
        return n;
    }

    Node \*getMeANode() { // fast-ish and safe, not returning pointer to dead data, caller responsible for delete when done
        Node \*np = new Node;
        return np;
    }

Considering all options, do No.1.

**Operator Overloading**  

Give our own meanings to C++ operators for types we create

    struct Vec {
        int x, y;
    }

    Vec operator+(const Vec &v1, const Vec &v2) {
      Vec v{v1.x+v2.x, v1.y+v2.y}
      return v;
    }
