---
layout: post
title: CS 246 - Object-Oriented Software Development
date: 2016-05-02 18:56:00 -0400
categories: notes
--- 

    CS 246 - Object-Oriented Software Development
    Instructor: Brad Lushman
    Section: 001
    Location: MC 4045
    Time: Tuesdays and Thursdays 10:00am - 11:20am
    Tutorials: MC 4060 Wednesdays 1:30pm - 2:20pm
    Term: Spring 2016
    

May 3, 2016 - Lecture 1
-----------------------

**Grading Scheme**

+ Assignments - 0(A0) 7 7 7 7 12(project) = 40%  
+ Midterm (4:30pm - 6:20pm, June 23 (Th), 2016) = 20%   
+ Final = 40%

This course requires you to work in Linux. There are several options:

1. Lab machines  
2. Install Linux on your own machines  
3. Make SSH connection to school machines (Use Putty (putty.exe) on Windows, winscp for file transfer, XMing for Xwindows)  
4. Download cygwin - Linux-like environment for Windows
5. Get a Mac

**4 Modules in this Course:**

* Linux Shell (2 weeks)
* C++ Language, C++14 (10 weeks)  
* Tools 
* Software Engineering (design etc.) 

"Homework": Go on Piazza -> Linux Reference Sheet -> Save and print

Module 1: Linux Shell
---------------------

A shell is an interface to the operating system, i.e. how we get the OS to do things (run programs, manage files etc.). There are two kinds of shells: graphical (with icons and clicking) and the command line. The shell we will use is Bash. Check if you are using Bash, login to shell and type in:
    
    $ echo $0
    
It should return "bash".

**Linux file system: working with files**

**cat** - short for concatenate; display contents of a file (e.g. cat user/share/dict/words). In Linux, a directory is considered a special kind of file

**ls** - list files in the current directory (non-hidden files)

**ls -a** - list all files (including hidden; hidden files start with a ".")

**pwd** - print current directory (pwd = print working directory)

What happens when we only type in "cat"? It just kind of sits there, waiting for input. It's kinda like a parrot, repeating what you typed in. If we can capture the output into a file...

    $ cat > output.txt
    
It would capture the input. NOT RECOMMENDED: ^C. It would prevent cat from doing clean-up. Let it finish on its own: ^D at the beginning of a line sends an "EOF" signal to cat.

One greater than sign replaces, two appends.  
In general, command args > file
executes command args + captures the output in file -> called **output redirection**.

Using less than sign, takes in input from the file.

    $ cat < output.txt
    
The line above displays the file. Seems to be equivalent to what we have before. Are these two things the same? NO. The reason is very important: 

* cat input.txt -> passes the NAME input.txt to cat as an argument. Cat opens input.txt and displays its contents

* cat < input.txt -> the shell opens the file and passes the contents to cat IN PLACE of keyboard input

**wc** - word count, displays numbers of lines, words, and characters of a file

**cat *.txt** - *.txt globbing pattern -> matches any sequence of characters (the shell finds all files that mathch the pattern)

**cat < *.txt** - ERROR! The shell will only attach one file to cat's input stream

Many (but not all) commands take both kinds of inputs:

**cat < input.txt > output.txt** - sends chars from input.txt to output.txt; effectively a copy-paste action

Every process is attached to 3 streams. Stdin goes into the program, stdout and stderr come out of the program. Stdin -> program -> stdout and stderr. By default, stdin = keyboard, stdout, stderr = screen. 
< connects stdin to file, > connects stdout to file, 2> stdrr. Stderr separates output stream from error messages, so that output error messages can go to different places, and that error messages don't cut/block output files.

Also, stdout may be **buffered**. System may assemble characters before displaying. However, stderr isn't buffered, because user needs to see error messages immediately. 

**Pipes**: Make one program's output(stdout) another program's input(stdin). Example: How many words occur in the first 20 lines of sample.txt? 

    head -n file
    
gives the first n lines of file

    wc -w
    
counts words (just print the word count)

so

    head -20 sample.txt | wc -w
    
Here, | (the pipe symbol) makes the output of the command before it the input of the command after it.
