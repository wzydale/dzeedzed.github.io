---
layout: post
title: CS 246 - Object-Oriented Software Development
date: 2016-05-02 18:56:00 -0400
categories: notes
---

    CS 246 - Object-Oriented Software Development
    Instructor: Brad Lushman
    Section: 001
    Location: MC 4045
    Time: Tuesdays and Thursdays 10:00am - 11:20am
    Tutorials: MC 4060 Wednesdays 1:30pm - 2:20pm
    Term: Spring 2016

**Shoutout to Brian Forbes, [Steven Yang](http://www.yufeiyang.me), and [Ziqi Zhou](http://ziqizhou.com)!**

May 3, 2016 - Lecture 1
-----------------------

**Grading Scheme**

+ Assignments - 0(A0) 7 7 7 7 12(project) = 40%  
+ Midterm (4:30pm - 6:20pm, June 23 (Th), 2016) = 20%   
+ Final = 40%

This course requires you to work in Linux. There are several options:

1. Lab machines  
2. Install Linux on your own machines  
3. Make SSH connection to school machines (Use Putty (putty.exe) on Windows, winscp for file transfer, XMing for Xwindows)  
4. Download cygwin - Linux-like environment for Windows
5. Get a Mac

**4 Modules in this Course:**

* Linux Shell (2 weeks)
* C++ Language, C++14 (10 weeks)  
* Tools
* Software Engineering (design etc.)

"Homework": Go on Piazza -> Linux Reference Sheet -> Save and print

Module 1: Linux Shell
---------------------

A shell is an interface to the operating system, i.e. how we get the OS to do things (run programs, manage files etc.). There are two kinds of shells: graphical (with icons and clicking) and the command line. The shell we will use is Bash. Check if you are using Bash, login to shell and type in:

    $ echo $0

It should return "bash".

**Linux file system: working with files**

**cat** - short for concatenate; display contents of a file (e.g. cat user/share/dict/words). In Linux, a directory is considered a special kind of file

**ls** - list files in the current directory (non-hidden files)

**ls -a** - list all files (including hidden; hidden files start with a ".")

**pwd** - print current directory (pwd = print working directory)

What happens when we only type in "cat"? It just kind of sits there, waiting for input. It's kinda like a parrot, repeating what you typed in. If we can capture the output into a file...

    $ cat > output.txt

It would capture the input. NOT RECOMMENDED: ^C. It would prevent cat from doing clean-up. Let it finish on its own: ^D at the beginning of a line sends an "EOF" signal to cat.

One greater than sign replaces, two appends.  
In general, command args > file
executes command args + captures the output in file -> called **output redirection**.

Using less than sign, takes in input from the file.

    $ cat < output.txt

The line above displays the file. Seems to be equivalent to what we have before. Are these two things the same? NO. The reason is very important:

* cat input.txt -> passes the NAME input.txt to cat as an argument. Cat opens input.txt and displays its contents

* cat < input.txt -> the shell opens the file and passes the contents to cat IN PLACE of keyboard input

**wc** - word count, displays numbers of lines, words, and characters of a file

**cat *.txt** - *.txt globbing pattern -> matches any sequence of characters (the shell finds all files that mathch the pattern)

**cat < *.txt** - ERROR! The shell will only attach one file to cat's input stream

Many (but not all) commands take both kinds of inputs:

**cat < input.txt > output.txt** - sends chars from input.txt to output.txt; effectively a copy-paste action

Every process is attached to 3 streams. Stdin goes into the program, stdout and stderr come out of the program. Stdin -> program -> stdout and stderr. By default, stdin = keyboard, stdout, stderr = screen.
< connects stdin to file, > connects stdout to file, 2> stdrr. Stderr separates output stream from error messages, so that output error messages can go to different places, and that error messages don't cut/block output files.

Also, stdout may be **buffered**. System may assemble characters before displaying. However, stderr isn't buffered, because user needs to see error messages immediately.

**Pipes**: Make one program's output(stdout) another program's input(stdin). Example: How many words occur in the first 20 lines of sample.txt?

    head -n file

gives the first n lines of file

    wc -w

counts words (just print the word count)

so

    head -20 sample.txt | wc -w

Here, | (the pipe symbol) makes the output of the command before it the input of the command after it.

<br />

May 4, 2016 - Tutorial 1
---

To zip your assignment files, do:

    zip (directory where your files are).zip *

in the directory where the files are.


    marmoset_submit cs246 (question, e.g a0) (file you want to submit, zipped)

is how you submit assignments to Marmoset.

<br />

May 5, 2016 - Lecture 2
---

Suppose we have files words1.txt, words2.txt..., and each of them has one word per line. We want: A duplicate-free list of all the words used in any of these files

We need the following:

+ sort - sorts lines (man: Write sorted concatenation of all FILES(s) to standard output)
+ uniq - remove consecutive duplicate lines from input (man: filter adjacent matching lines from INPUT, writing to OUTPUT)

One possibility:

    cat words*.txt | uniq

What's the problem with this? We must sort our input first, because for aabaacd, it would produce abacd, with duplicates.

This should work:

    cat words*.txt | sort | uniq

Sort it first, then call uniq. But there's still a problem: it's way too inefficient, beacuse it cat(s) all the files together FIRST, and then sorts it.

This is better:

    sort words*.txt | uniq

Q: Is it possible to use the output onf one program as a __parameter__ to another?

Yes. E.g.

    echo "Today is $(date) and I am $(whoami)"

The shell executes date and whoami, and subsitutes the results into the command line.

WARNING:

    echo 'Today is $(date) and I am $(whoami)'

This will print the **LITERAL** interpretation, i.e. Today is $(date) and I am $(whoami)  
Single quotes do not execute the substitution.

    echo "$(ls words*.txt)"

prints a list of names of the text files:  
words1.txt  
words2.txt  
...

**Pattern Matching in Text Files**  
Use egrep (extended global regular expression print) = grep -E

    egrep pattern file

returns all lines that contain the pattern.

E.g. print lines that contain "cs246"

    egrep cs246 index.html

What about "cs246" OR "CS246"?

    egrep "cs246|CS246" index.html

The vertical bar (\|) means "OR", and the double quotes prevent the shell from interpreting the bar as a pipe.

We can use parentheses to group subexpressions together:

    egrep "(cs|CS)246" index.html

The patterns that egrep understands are called **regular expressions**. NOT globbing patterns.

"(c\|C)(s\|S)246" is equivalent to "[cC][sS]246"

**[...]** syntax says to match any SINGLE character in he square brackets. (a\|1\|c\|2) is equivalent to [a1c2].

**[^...]** matches any 1 character not in the square brackets.

"[cC][sS] ?246" allows for an optional space before the 246. ? syntax says to match 0 or 1 occurrences of the preceding expression.

\* syntax which matches 0 or more of the preceding expression. So (cs)\*246 -> 246, cs246, cscs246, cscscs246...  
cs(cs)*246 matches at least one cs at the front (eliminating the zero case)

(cs)+246 is equivalent to cs(cs)*246. The + syntax matches 1 or more of the preceding expression.

.* will match any sequence of characters

.+ will match any non-empty sequence of characters

"cs *246" matches any string starting with cs, followed by any string, followed by 246.

^ matches beginning of line

$ matches the end of line

^cs246 line starts with cs246

cs246$ line ends with cs246

Want all lines of even length

^(..)*$

The Other Section
===

Pipes allow us to hook the stdin of one program to the stdout of another. This is done using the pipe character \| between commands

    cmd1 args1 | cmd2 args2

**Regex Rules**:

+ Can use parentheses for a sub-pattern
+ Can use square brackets to match any one character in the square brackets
+ [^...] matches any one character EXCEPT those in the square brackets
+ A ? after a pattern or character represents 0 or 1 of that pattern/character
+ A * after a pattern/character represents 0 or more of that pattern/character
+ A + "1 or more"
+ . matches any SINGLE character
+ ^ and $ match the start and end of line respectively

E.g.  
.* - anything  
.+ - non-empty string  
^.+$ - all non-empty lines  
^.*$ - all lines  

^(..)*$ - grabs all lines with even number of characters

**Permissions**

* ls -l gives the long form listing of the files in the current directory  
* First 3 bits: Owner r-read w-write x-execute
* Middle 3 bits: Group
* Last 3 bits: Others
* r: ordinary files-> can be read, directories-> contents can be read, globbing workds, ls works
* w: ordinary files->can be modified, directories-> contents can be modified, add/remove
* x: file's contents can be executed as a program, directories->directories can be navigated (can cd into the directory)

**Changing Permissions**

* to change permissions use chmod

        chmod mode file

* mode is broken up to 3 parts - user, operator, and permissions
* user is either u (owner), g (group), o (other), or a (all)
* operator is either + (add), - (remove), = (set exactly)
* permissions are r, w, x

E.g.

    chmod o+r filename

gives other group read access to the file

    chmod o-r filename

is the reverse

    chmod a-r filename

then nobody can read it

    chmod u=rwx filename

then the owner can do anything with it.

**Shell Scripts**

A shell script is a file containing sequences of shell commands execueted as a program. For example if we wanted to print the date, current user, current dir.

    #!/bin/bash (this header tells the OS that this is a Bash script; allows the OS to interpret it the following as bash commands)
    date
    whoami
    pwd

.sh is the standard extension of a bash script, but you can put whatever you want. Don't forget permissions. Needs to be executable. Use chmod to give it executation rights.

**Variables**

+ Variables can be assigned with single equals.
+ x=1 (NO SPACES!!!)
+ use echo &{x} to grab the value of the variable x (parentheses run what's inside it in a "subshell") (curly braces are important: good practice)

**Shell Script Example**

Write a script that takes in a string to check if it is BAD. A string that can be found in a dict is bad.
General format of conditional statements in bash:

    if [ cond ]; then // the square brackets cannot "touch" what's inside
    ...
    elif [ cond ]; then
    ...
    else
    ...
    fi

**$?** contains the return value of the last-run command.
**$1** retrieves the first parameter

Create a .sh script as follows:

    #!/bin/bash

    egrep "^$1$" /usr/share/dict/words > /dev/null  # /dev/null is where data goes to DIE

    if [ $? -eq 0 ]; then //-eq compares
    echo Bad password
    else
    echo Maybe not the worst
    fi

And before you run it,

    chmod u+x goodpass.sh

In bash, the pound symbol (#) starts a comment.

<br />

May 10, 2016 - Lecture 3
---

Review:

    egrep pattern file

prints all lines in file that contain a match to pattern

**Shell Scripts Review**  

    #!/bin/bash  #"Shebang line"  
    date  
    whoami  
    pwd

To run the script in the current directory:

    ./myscript

**Variables**  

    x=1 #NO SPACES  
    echo $x #Use $ when fetching the value of a variable
    # No $ when setting a var ($ = "fetch the value of")
    # Good practice: ${x} - brace brackets, good style
    # All vars contain strings, e.g. x is the STRING 1, not the number/int

E.g.  
    dir = ~/cs246
    echo ${dir}
    /u/bmlushma/cs246 # get the absolute path
    ls ${dir} # contents of cs246

There are some global variables:  
    env # environment variables
    echo ${PATH} # list of directories (where the shell looks for programs)

When you type a command, the shell searches the list in order for a matching program.

    echo * # prints all files in the current directory
    echo "*" - suppresses globbing pattern
    echo '*' - suppresses globbing pattern
    echo "$PATH" # expands the quotes, $-expansion happens
    echo '$PATH' # absolutely literally

**Special Variables for Scripts**  
    $1, $2, ... # command-line arguments

E.g. check whether a word is in the dictionary

    ./isItAWord hello

    #!/bin/bash

    egrep "^$1$" /usr/share/dict/words # prints the word if found, prints nothing if not

E.g. a good password is not in the dictionary

    egrep "^$1$"/usr/share/dict/words > /dev/null # to black hole, suppress output
    # we could store the out in a variable
    x=$egrep ...

Note: every program returns a status code when finished: egrep returns 0 if found, 1 if not found (general convention in UNIX: 0 means success, non-0 means failure)

    $? # status of the most recently executed command

    if [ $? -eq 0]; then # the first square bracket is the name of a program, and what's inside the square brackets are its arguments
        echo Bad password
    else
        echo Maybe a good password
    fi

We want to verify that the user has inputted the correct number of arguments, and print a usage message if it's wrong

    #!/bin/bash

    usage() {
        echo "usage: $0 password" # $0 is the name of the script/program as it was typed
    }

    if [ $# -ne 1 ]; then # $# is the number of arguments
        usage
        exit 1
    fi

    egrep ... # as established above

Now this is a good program that can also check if the input is valid.

The general structure of conditional statements is as follows:

    if [ cond ]; then
        ...
    elif [ cond ]; then
        ...
    else
        ...
    fi

Comparisons to other conditions: Check the Linux reference sheet

**Loops**  

Loops: print the numbers from 1 to $1

    #!/bin/bash
    x=1
    while [ $x -le $1 ], do
        echo $x
        x=$((x+1)) # $(()) for arithmetic
    done

Looping over a list, e.g. rename all .cpp to .cc  

    #!/bin/bash
    for name in \*.cpp; do # for ... in sets the variable to each word in the given list
        mv ${name} ${name%cpp}cc # value of name, without trailing cpp
    done

e.g. how many times does word $1 occur in the file $2?

    #!/bin/bash
    x=0
    for word in $(cat "$2"); do #good idea - enclose vars in double quotes, prevent bad input
        if [ $word == $1 ]; then #String equality == instead of -eq
            x=$((x+1))
        fi
    done
    echo $x

e.g. Payday is the last Friday of the month. When is this month's payday?

2 tasks here: compute date and fomat the answer

    cal | awk '{print $6}' | egrep "[0-9]" | tail -1

<br />

May 11, 2016 - Tutorial 2
---

Want: stdout and stderr in the same file

  printer >> out 2> out # works
  printer > out 2>> out #doesn't work

  #Alternatives
  printer &> out
  printer > out 2>&1
  printer 2>out 1>&2

Want: Give the top 10 most commonly used words

  sort wordCollection | uniq -c | head # problem
  sort wordCollection | uniq -c | sort | tail # works
  sort wordCollection | uniq -c | sort -k1,1rn -k2,2 | head # sort takes in arguments -k as key; 1,1 = first character r = reverse order(descending) n = sort in numerical order, 2 break ties
  sort wordCollection | uniq -c | sed 's_6_12_' | sort | tail # Use sed to replace 6s with 12s and then sort lexigraphically
  sort wordCollection | uniq -c | sed 's_6_12_' | sort -k1,1nr -k2,2 | head

egrep:

^ - match beginning of line  
$ - match end of a line  
^$, ^a$  
. - matches any single character  
? - matches preceeding pattern 0 or 1 times  
\* - 0 or more  
\+ - 1 or more  

Note: abc* != (abc)*
ab, abccc, abcccccc, in comparison to abc, abcabc, abcabcabc

<br />

May 12, 2016 - Lecture 4
---
Recall: compute payday (last Friday of the month); report nicely

    #!/bin/bash

    answer() {
      if [ $1 -eq 31 ]; then # inside a fn - $1, $2 etc are the args to the function
        echo "This month: the 31st"
      else
        echo "This month: the ${1}th"
      fi
    }

    answer $(cal | awk '{print $6}' | egrep "[0-9]" | tail -1) # the whole thing after the dollar sign is ${1}

Generalize to any month:

cal June 2016 # gives calendar for June 2016  
Want: let payday June 2016 gives June 2016's payday

    #!/bin/bash

    answer() {
      if [ $2 ]; then
        preamble=${2}
      else
        preamble='This month'
      fi

      if [ $1 -eq 31 ]; then
        echo "${preamble}'s payday is on the 31st."
      else
        echo "${preamble}'s payday is on the ${1}th."
      fi
    }

    answer $(cal $1 $2 | awk '{print $6}' | egrep "[0-9]" | tail -1) $1 # if $1 and $2 are supplied, revert back to previous behaviour

## Software Engineering: Testings(aka QA lmao) ##

+ essential part of program development
+ ongoing, not just at the end
  + begins **BEFORE** coding
  + test suites - expected behaviour
+ NOT debugging - cannot debug without first testing
+ cannot guarantee correctness, can only prove wrongness
+ ideally, developer + tester should be different people

**Human Testing** - Humans look over code, find flaws, code inspection, walkthroughs  
**Machine Testing** - Run the program on selected input, check against spec, can't test everything - choose test cases carefully  

**Black/White/Grey Box Testing**: no/full/some knowledge of program implementation  
Start with black box, supplement with white box

  + various classes of input, e.g. numerical ranges, positive/negative
  + Boundaries of valid ranges (edge cases)
  + Multiple simulatenous boundaries (corner cases)
  + Intuition/Experience ("Ayy I've seen programs like that before, better try blah lmao")
  + Extreme cases (e.g. integer overflow; how large can the integer get before it breaks)

White box - executes all logical paths through the program

  + run through the true part and false branch of conditional statements
  + every way you can go from start to finish should be tested  
  + make sure every function you write actually gets called

**Performance Testing** - Is the program fast enough?  
**Regression Testing**  

  + Make sure new changes to the program don't break old tests  
  + test suites (ALWAYS ADD TESTS; NEVER SUBTRACT), testing scripts

## Module 2: C++ (ayy) ##

Hello World in C:

    #include <stdio.h>

    int main() {
      printf("Hello World!\n");
      return 0;
    }

Hello World in C++:

    #include <iostream>
    using namespace std;

    int main() {
      cout << "Hello World" << endl;
      return 0;
    }

Notes:  

+ main MUST return int in C++  
+ stdio.h, printf still available in C++
+ preferred C++ I/O: header <iostream>

Output:

    std::cout << ___ << ____ << ____  
    std::endl = end-of-line

Using namespace std lets you say cout and endl instead of std::cout and std::endl

Return statement - returns status code to the shell ($?). If left out, main returns 0

**Compiling C++ Programs**

On the school Linux environment:

        g++-5 -std=c++14 program.cc -o program
        (-o program is the name of the executable binary (if not specified: a.out))
        // OR
        g++14 program.cc -o program // if you have done A0 and made the alias
        // Run the program by
        ./program

**Input/Output**  
  3 IO streams: cout - for printing to stdout, cin - for reading from stdin, cerr - for writing to stderr

  Operators: << "put to" - Output, >> "get from" - input

      cerr << x // x flows to cerr
      cin >> x // input flows to x
      // The operator points in the direction of information flow

E.g. Add 2 numbers  

    #include <iostream>
    using namespace std;

    int main() {
      int x, y;
      cin >> x >> y; // cin ignores whitespace; gets two integers, ignoring whitespace
      cout << x+y ;
    }

If the input doesn't contain an integer next - statement fails, value of the var is undefined

What if the input is exhaustive, before we get two ints? - Same as above

If the read failed: cin.fail() will be TRUE  
If we got an EOF: cin.fail() and cin.eof() will be both TRUE; cin.eof() not until the attempted read fails

E.g. Read all ints from stdin, echo one per line to stdout. Stop on bad input or EOF

    int main() {
      int i;
      while(true) {
        cin >> i;
        if (cin.fail()) break;
        cout << i << endl;
      }
    }

<br />

May 17, 2016 - Lecture 5
---

E.g. Read all ints from stdin + echo, one per line, to stdout, stop on bad input of EOF

	int main() {
		int i;
		while (true) {
			cin >> i;
			if (cin.fail()) {
				break;
			}
			cout << i << endl;
		}
	}

Recall: if read fails, cin.fail() will be true; if EOF: cin.fail() and cin.eof() both true, but not until the attepted read fails

Note: there is an implicit conversion from cin to bool, so cin can be used as a condition. The conversion is that it's true if fail/bad/eof bits are clear, or false if fail/bad/eof set

E.g. v2.0

```c++
int main() {
	int i;
	while (true) {
		cin >> i;
		if (!cin) { // using cin as the condition, means the same thing as the other program
			break;
		}
		cout << i << endl;
		}
}
```

Note: >> is C's right bitshift operator; a >> b shifts a's bits to the right by b spots

E.g. 21 >> 3; 21 in binary is 10101, push the last 3 digits off the cliff, so it becomes 10 in binary, which is 2; equivalent to dividing by 2 to the b-th power, ignoring remainders

But when the left hand side is cin, this is the "get from" operator

	operator >>
 	// inputs: LHS cin (istream), RHS data (variety of types); output: return cin (istream)
 	// This is why we can write: cin >> x >> y >> z; cin >> x produces cin, x gets populated, and now we get cin >> y >> z, and so on.

E.g. v3.0

```c++
int main() {
  int i;
  while (true) {
    if (!(cin >> i)) { // using it as both a condition and populating i
      break;
    }
    cout << i << endl;
  }
}
```

E.g. v4.0

```c++
int main() {
  int i;
  while(cin >> i) { // changing the break statement into a single while loop
    cout << i << endl
  }
}
```

E.g. read and echo ints until EOF, skip non-integer input

```c++
int main() {
  int i;
  while (true) {
    if (!(cin >> i)) {
      if (cin.eof()) {
        break;
      }
      cin.clear(); // clears the fail bit, so that cin is ready to read again
      cin.ignore(); // throws away the next character
    } else {
      cout << i << endl;
    }
  }
}
```

E.g. Reading strings: type std::string (#include <string>)

```c++
int main() {
  string s;
  cin >> s;
  cout << s << endl;
}
// skips leading white space;
// stops at whitespace (reads one word)
```

What if we want the hvitespace? Use getline(cin, s), it reads from the current position to next newline, into s.

```c++
cout << 95 << endl; // prints 95
```

What if we want to print a number in hexadecimal?

```c++
cout << hex << 95 << endl;
// this will print 95 in hex, 5f
// hex is std::hex, is the I/O manipulator, reconfigures the
// output string, all subsequent ints are printed in hex
// (FOR THE REST OF ETERNITY, nah jkjk till the program terminates); A bit of an overkill?
cout << dec; // goes back to decimal

// Other manipulator, SEE NOTES, don't forget #include <iomanip>
```

Stream abstraction applies to other fsources of data

**Files** - Read from a file instead of stdin  
	std::ifstream reads from a file  
	std::ofstream writes to a file

File access in C:

```c
#include <stdio.h>
int main() {
	char s[256];
	FILE *file = fopen("suite.txt", "r"); // r = read mode; file is a handle
	while (true) {
		fscanf(file, "%255s", s);
		if (feof(file)) break;
		printf("%s\n", s);
	}
	fclose(file);
}
```

File access in C++:

```c++
#include <iostream>
#include <fstream>
using namespace std;

int main() {
	ifstream file{"suite.txt"}; // creating and initializing an ifstream opens the file
	string s;
	while (file >> s) {
		cout << s << endl;
	}
	// IMPORTANT: the file is closed when the variable (in this case, file), goes out of scope; when the program stops, it's popped of the runtime stack, it then closes.
}
```

Anything you can do do with cin and cout, you can do with an ifstream or an ofstream. ANYTHING.

E.g. string - attach a stream to a string and read/write it

```c++
#include <sstream>
// std::istringstream and std::ostringstream
// read from/write to a string

int hi = ..., lo = ...;
ostringstream ss; // think of it as a sock
ss << "Enter a # between" << lo << "and" << hi; // stuffing the sock with string
string s = ss.str(); // cuts open the sock and gets the string
cout << s << endl;
```

E.g. convert a string to a #

```c++
int n;
while (true) {
  cout << "Enter a number" << endl;
  string s;
  cin >> s;
  istringstream ss {s};
  if (ss >> n) break; // stop if you get int
  cout << "I said,";
}
cout << "You entered" << n << endl;
```

Example revisited - echo numbers, skip non-numbers

```c++
int main() {
  string s;
  while (cin >> s) {
    istringstream ss {s};
    int n;
    if (ss >> n) {
      cout << n << endl;
    }
  }
}
```


## Strings ##

In C, array of char (char* or char[]), terminated by IO. Must manage own memory: get morememory when strings grow; Easy to overwrite IO and corrupt program

**In C++, strings grow as needed, and are thus safer.**

E.g.

```c++
string s{"Hello"}; // it's still an array (C-style string);
// C++ string created from C string on initialization
```

**String Operations:**

+ Equality Inequality, s1 == s2, s1 != s2  
+ Comparison: s1 <= s2 (lexicographical comparison)  
+ Length: s.length()  
+ Extract individual characters: s[0], s[1] etc.  
+ Concatenation: s3 = s1 + s2, s3 += s4  
+ More details: SEE NOTES

Default Function Parameters

```c++
void printSuiteFile(String name = "suite.txt") {
  // default value, must be last
  ...
}

printSuiteFile("suite2.txt");
printSuiteFile(); // prints from suite.txt
```

Note: optional params must be last; if you leave out two parameters, they have to be the last two; 3,3 etc.

<br />

May 18, 2016 - Tutorial 2
---

## Shell Scripting

+ Exit codes are important; non-zero return/exit value = ERROR
+ Write to the correct stream
+ Scoping for subroutines, anything defined befored a subroutine is visible(and modifiable) in the subroutine, except positional arguments (\$1, \$2, ...)

## Testing

+ Don't have to worry about invalid inputs
+ Testing is hard
+ Try sanity checks ("No one could make this mistake")
+ Good coverage: boundary/edge and corner cases, equivalence classes, weird cases

**Possible Test Cases**  

+ Equivalence courses: small, medium, and large values of the target
+ Boundary/edge cases: test containing 0 as target

## C++ I/O

+ DO NOT USE C I/O
+ 3 default streams: cout, cerr, cin
+ If a read from cin fails, **all subsequent reads will fail**

## Make I/O More Robust

+ Reading from cin could fail in two ways
	+ EOF
	+ got unexpected input
+ When a read fails, a flag goes up in cin
	+ cin.fail() will be true
	+ Only cin.fail() will be true if it was an error
	+ Both cin.fail() and cin.eof() will be true if it was EOF
	+ How to clear: cin.clear() -> put all cin flags down and turn it into a valid state
	+ How to continue: cin.ignore(); order is important: clear then ignore
+ If you want the entire line, use getline(cin, s)

## Strings

+ Encapsulates something like char* in C
+ Has length, insert, delete, search methods
+ Can be accessed like an array
+ include<string>
+ at(index): checks for bounds and throws an exception if out of bounds
+ \[index]: does not check for bounds

<br />

May 19, 2016 - Lecture 6
---

**Overloading**  

C: Functions with different parameter lists cannot share the same name

```c
int negInt(int n) { return -n; }
int negBool(bool b) { return !b; }
```

C++: Functions with different parameter lists can share the same name

```c++
int neg(int n) { return -n; }
int neg(bool b) { return !b; }
// example of overloading
```

Compiler uses number of types of arguments to decide which neg is being called.

Overloads must differ in number of type of arguments, not just on the return type. We've seen this before: >>, << (operators, could be right shift/left shift, or could be input and output; the behaviour depends on types of args)

**Structs**  

```c++
struct Node {
  int data;
  Node *next;
}; // don't forget the semicolon

Node n1{5, nullptr}; // nullptr is the syntax for a null pointer in C++.
// Do not say NULL or 0 in this class!!!!!!!
// 0 will be always treated as a number, not pointer

const Node n2 = n1; // constant struct means that its fields
// cannot be changed; n2 is an immutable copy of n1
```

**Parameter Passing**  

Recall:

```c++
void inc(int n) {
  n = n + 1;
  // ...
}
int x = 5;
inc(x);
cout << x << endl; // prints 5; call-by-value
// inc gets a copy of x and modifies the copy, not the original
```

Sol'n: If a function needs to modify its arugument - pass a pointer

```c++
void inc(int n) {
  *n = *n + 1;
  // ...
}
int x = 5;
inc(&x); // x's address passed by value, inc changes value at that address, visible to caller
cout << x << endl; // prints 6
```

Question: Why cin >> x and not cin >> &x?  
Answer: C++ has another pointer-like type: references

**References (IMPORTANT!!!)**  

```c++
int y = 10;
int &z = y; // NEW. Ampersand after int.
// z is an lvalue reference to int (which is y)
// Reference is like a constant pointer, similar to int *const z = &y;
// (z is a constant pointer to an int; z will always point to y implied by const)
// (but y is not constant; you can change y however you like)
```

References are like constant pointers with automatic dereferencing.

```c++
z = 12; // NOT *z = 12
int \*p = &z; // &z gives the address of y.
// No matter what you do to z, you do it y.
// In all cases, z behaves exactly like y. z is an alias for y.
```

**Things you CANNOT do with lvalue references**  

+ leave them uninitialized, because they are constant, cannot assign later
  + must be initialized with something that actually has an address (an lvalue) since references are pointers
  + E.g.

  ```c++
  int &x = 3; // WRONG: WONT COMPILE!
  // because 3 is not an address, it's a constant literal
  int &x = y + z; // WRONG!
  int &x = y; // GOOD
  ```

+ create pointer to a reference: int &* x; // WRONG
  + reference to a pointer is legal: int \*& x;
+ create a reference to a reference: int && x = ...; // means something different (will discuss later)
+ create an array of references: int &a[] = {x, x, x}; // given the similarity between arrays and pointers

**Things you CAN do with lvalue references**  

+ Pass as function parameters:

```c++
void inc(int &n) { // const pointer to the argument (x), thus changes to n affect x
  n = n + 1; // no pointer dereferencing
}
int x = 5;
inc(x);
cout << x << endl; // prints 6
```

Why does cin >> x work? It takes x by reference

istream &operator >> (istream &in, int &n);

**Pass-by-value**

E.g.

```c++
int f(int n) {...} // copies the argument
// if the argument is big, copying is expensive

struct ReallyBig{}; // Massive struct with thousands of fields
int f(ReallyBig rb) {...} // copying would be slow

int g(ReallyBig &rb) {...} // pass as reference, no copy, it's an alias, fast
// this could change rb in the caller, in contrast to pass by value, which guarantees
// no changes to rb itself after calling

int h(const ReallyBig &rb) {...} // pass constant reference, no copy, fast, and the parameter cannot be changed
```

Advice: prefer pass-by-const-reference over pass-by-value for anything larger than an int, unless the function needs to make a copy anyway - then maybe pass by value. DEFAULT SHOULD BE PASS-BY-CONST-REF. Sizeof reference is same as size of a pointer

Also:

```c++
int f(int &n) {...}
int g(const int &n) {...}

f(5); // LMAO FAILS WON'T COMPILE, because 5 does not have an address;
// can't initialize an lvalue reference (n) to a literal value;
// if n changes, can't change the literal 5

g(5); // OK; since n can never be changed, the compiler will allow this
// How though? The compiler creates a temporary location to hold 5, so that n has something to point at
```


That's why const ref is so CRITICALLY IMPORTANT.

**Dynamic Memory Allocation**  

C:

```c
int *p = malloc(n * sizeof(int));
free(p);
// Don't use these in this course though
```

C++: new/delete

E.g.

```c++
struct Node {
  int data;
  Node *next;
}

Node *np = new Node; // allocates a Node on the heap and np points to it
// ...
delete np;
// all local variables reside on the stack
// deallocated (popped) when their scope ends
// Allocated memory is on the heap, it stays there until you get rid of it
// Remains allocated until delete is called
```

If you don't delete - MEMORY LEAK

**Arrays on the heap**

```c++
Node *myArray = new Node[10];
// ...
delete [] myArray; // The square brackets have to be there
```

E.g.

```c++
Node getMeANode() {
  // copy to caller's frame, expensive
    Node n;
    return n;
}

Node &getMeANode() {
  // WORST. Returns a ref (essentially a pointer) to
  // stack-allocated data, which is dead on return
    Node n;
    return n;
}

Node *getMeANode() {
  // fast-ish and safe, not returning pointer to dead data
  // caller responsible for delete when done
    Node *np = new Node;
    return np;
}
```

Considering all options, do No.1.

**Operator Overloading**  
Give our own meanings to C++ operators for types we create

```c++
struct Vec {
    int x, y;
}

Vec operator+(const Vec &v1, const Vec &v2) {
  Vec v{v1.x+v2.x, v1.y+v2.y}
  return v;
}
```

<br />

May 24, 2016 - Lecture 7
---

## Preprocessor Variables

  + We can also define preprocessor symbols via the compiler; with gcc, syntax is -Dvname or -Dvname=val (-DX)
  + **ifdef** and **ifndef** directives: these check if a preprocessor variable has been defined (a use for simply defining variables); can be used to debug; #ifdef DEBUG to conditionally print stuff out to debug code; can offload run time to compile time
    + syntax:
        ```
        g++14 -DDEBUG program.cpp // set DEBUG
        ```

## Separate Compilation
  + To help readability and create modularity we can split our programs into composable modules. Each module consist of **interface** (type definitions and prototypes for functions, .h file, contains declarations, won't allocate space for the variables) and **implementation** (full details, allocates space for variables/functions, .cpp file, contains definitions)
  + Example: Let's take the vector struct and overloaded addition operator we created and put in a module so that it can be used by other files; create vec.h and vec.cpp

```c++
// vec.h
struct Vec {
  int x, y;
};

Vec operator+(const Vec &v1
              const Vec &v2); // constant reference to vectors, do not modify the originals

// ---------------------------------------
// vec.cpp
#include "vec.h"
// to get the struct definition from the interface file

Vec operator+(const Vec &v1, const Vec &v2) {
  return {v1.x + v2.x, v1.y + v2.y};
}

// main.cpp
#include "vec.h"
using namespace std;

int main() {
  Vec x {1,2};
  Vec y {3,4};
  Vec v = x + y;
  cout << v.x << ", " << v.y << endl;
  return 0;
}

```

when compiling:

```
g++14 -c vec.cpp // -c oppresses linking, creates .o (object) file
g++14 -c main.cpp
g++14 vec.o main.o -o main
./main
```

## Global Variables

+ Consider we want to want to define a global variable in a module

```c++
// abc.h
int globalNum; // Wrong - definition and declaration
// This won't work, every file that includeds abc.h
// defines a SEPARATE globalNum and the program will not link
```

+ Solution: put the variable in the .cpp file

```c++
// abc.h
extern int globalNum; // Correct, just declaration
// extern keyword
// -------------------------
// abc.cpp
int globalNum;
```

## Multiple Includes

+ Always put #include guards in .h files (ifdef, define, endif)
+ Never put using namespace std in .h files; DO NOT USE ANY NAMESPACES WHATSOEVER!

## Classes

+ The big innovation of OOP - we can put functions inside of structs
+ A class is some struct that can contain functions
+ An object is an instance of a class
+ Member functions (aka Methods) are functions inside a class
+ this = pointer to the object a member function is called on; syntax: this->var; s.grade() is like calling grade(&s)

<br />

May 26, 2016 - Lecture 8
---

## Classes Continued ##
Recall: student.cpp, implemented as struct  
This class:

## Initializing Objects ##
+ When creating an object typicaly the class will have data members that need to be assigned values - initialized
+ As shown in the student example we could use curly braces to initialize our class, and in C++ this is true for most types - this is called **Uniform Initialization**
+ Ex. Student bob {60, 70, 80} in the student.cpp example

## Constructors ##
+ Without defining how your class should be constructed C++ just takes those values and assigns them to each field in the order they were declared - this is okay, but has limitations
+ A better idea is to include in your class a method that does the initialization - called a **constructor**
+ Ex. in the student.cpp example

    Student(int assns, int mt, int final) {
      // Debug statement here
      this->assns = assns;
      this->mt = mt;
      this->final = final;
    }
    // default value given
    Student(int assns=0, int mt=0, int final=0) {
        // ...
    }

## Notes on Initialization ##
+ Sometimes variables are initialized with the assignment operator

    int x = 5;
    string s = "hello";

+ And sometimes with (), especially when invoking Constructors

  int x(5);
  string s("Hello")
  Student bob(60, 70, 80)

+ An exception to this: std::vector

  std::vector B{1,3,5} // contains elements 1,3,5
  std::vector V(5) // of size 5
  std::vector G{1} // actually contains element 1; curly brackets -> element rather than size

+ Also,

  int x = 2.0; // the decimal will get chopped off
  int x {2.0} // COMPILER ERROR

+ A class is a struct itself, an object is an actual variable of that type

## Default Constructor ##

+ Every class comes with a default (zero-argument) constructor which calls: you can create an object but set its values later
+ As soon as you declare your own constructor, you lose the default

####

+ What about if our class contains a constant field or a reference field?
+ For example let's consider adding an ID field to our student class, this should be a const value that never changes but is different for each initialized student object
+ Where to initialize them though? Struct definition (i.e. create an ID field in the struct; const int id = 0;)? In the body of the constructor?
+ Problem: const int should be initialized
+ Solution:

## Object Creation Steps ##
+ Space is allocated
+ Fields are constructed
+ Constructor body runs
+ The moddile step is the missing piece of the puzzle where our initialization must go!

## MIL ##
+ The member initialization list is part of our constructor that specifies how to initialize object and non-static data members of our class
+ Can be used for any non-static memebers
+ Initialized in order of declaration in struct
+ Is more efficient, when the constructor is doing the same thing as the MIL, when there is a class inside a class (school class in student class)
+ Ex.

    Student(): assns{assns}, mt{mt}, final{final}, id{id} {

    }

## Copy Constructor ##
+ What happens when you use the assignment opeartor to instantiate an object?
+ Ex.

```c++
Student a {60,70,80}
Student b = a;
```

+ b will be initialized via the copy constructor
+ All classes have an implicit copy constructor that just copies all regular data fields and calls copy constructors on all object fields
+ Ex.

```c++
#include "Node.h"
Node::Node(const Node &in) : data(in.data) {
  if (in.next) {
    next = new Node(*in.next);
  } else {
    next = nullptr;
  }
}
// recursively copies the nodes
```

## Implicit Methods ##
+ Every class comes with
  + A default constructor
  + A copy constructor (just copies all fields)
  + A copy assignment operator
  + A destructor
  + A move constructor
  + A move assignmenet operator

## Notes on Copy Constructor##
+ The copy constructor (implicit or otherwise) is called when
  + An object is initialized by another object
  + When an object is passed by value
  + When an object is returned by a function

## Implicit conversion ##
+ Be careful with a constructor that takes only one parameter - this will create an implicit conversion

## Destructor ##
+ Necessary if your class has any memory allocated on the heap

<br />

May 31, 2016 - Lecture 9
---

## Recall

+ Copy constructor

```c++
Node *n = new Node {1, new Node {2, new Node {3, nullptr}}};
Node m = *n; // copy ctor
Node *p = new Node {*n}; // copy ctor
```

+ Simple copy of fields -> only the first node actually copied (shallow copy)
+ If you want a deep copy (copy the whole list), must write your own copy constructor

```c++
struct Node {
	// ...
	Node (const Node &other) :
    data {other.data},
    next {other.next? new Node {*other.next} : nullptr};
    // recursively copies the rest of the list
};
```

The copy constructor is called:

  1. When an object is initialized with another object (same class)
  2. When an object is passed by value
  3. When an object is return ed by a function

There are exceptions to all 3.

Note: Careful with chars that can take ONE argument

  E.g.

```c++
struct Node {
  Node (int d): data {d}, next {nullptr} {}
  // ...
};

//Single-argument ctors create implicit conversions

Node n(4);
Node n{4};
// but also
Node n = 4;
// You can also do this now
int f (Node n) {...}
f(4);
// You can do this because 4 is implicitly converted to Node
// How converting C string to C++ string makes sense; generally not a good idea though
```

Danger: accidentally pass an int to a function expecting a Node
  + Compiler does not signal an error
  + Potential errors not caught

Good idea: disable the implicit conversion

```c++
struct Node {
  // ...
  explicit Node (int d): data {d}, next {nullptr} {}
};

// Now these are still fine
Node n(4);
Node n{4};
// But these are not
Node n = 4;
int f (Node n) {...}
f(4);
```

## Destructors

When an obect is destroyed a method called the destructor runs
  + Stack-allocated: goes out of scope
  + Heap-allocated: is deleted

**Specifically**:

  1. The destructor body runs
  2. Destructor is called on all the fields (called in reverse declaration order; if declared from top to bottom, then destroyed from bottom to top)
  3. Space is deallocated

Class comes with a destructor (just calls destructors for all fields that are objects)

When do we need to write one?

```c++
Node *np = new Node {1, new Node {2, new Node {3, nullptr}}};
```

If np goes out of scope, the pointer is reclaimed (it was on the stack), the memory is leaked.

If we say delete np; it calls \*np's destructor, which doesn't do anything (it only frees the very first node (1), 2, 3 are leaked)

Write a destructor to ensure the whole list is freed:

```c++
struct Node {
  // ...
  ~Node() { // tilda has the connotation of negation; NOT; opposite of constructor

    delete next; // recursively calls
    // *next's destructor, thus the whole list is deallocated*
    // do not need to check nullptr
  }
}
```


## Copy Assignment Operator

```c++
Student billy {60, 20, 80};
Student jane {billy}; // copy constructor
Student joey; // default constructor
joey = billy; // copy, but not construction
// Above is copy assignment operator, uses compiler-supplied default
```

You need to write your own copy assignmennt operator when there is heap-allocated memory

```c++
struct Node {
  // ...
  Node &operator=(const Node &other) {
    // returns Node & so that cascading works
    data = other.data;
    // next = other.next would be wrong (shallow copy)
    // because that's what the default one does
    delete next; // otherwise it leaks, because the old object could point to real data
    // in order to replace the old data, need to delete old data
    next = other.next? new Node {*other.next} : nullptr;
    return *this;
    // DANGEROUS STILL //*
  }
};
```

Very dangerous.  
Why?

```c++
Node n {1, new Node {2, new Node {3, nullptr}}};
n = n; // deletes n, then tries to copy n to n, UNDEFINED BEHAVIOUR

// For example:
*p = *q; // where p and q points to the same address
a[i] = a[j]
```

When writing operator=, ALWAYS watch for self-assignment

```c++
Node &operator=(const Node &other) {
  if (this == &other) {
    return *this;  //*
  }
    data = other.data;
    delete next;
    next = other.next? new Node {*other.next} : nullptr; //*
    return *this;
  }
}
```

Better:

```c++
Node &operator=(const Node &other) {
  if (this == &other) {
    return *this;
  }

  Node *tmp = next;
  next = other.next ? {new Node{*other.next} : nullptr};
  data = other.data;
  delete tmp;
  return *this;
}
```


Above works even if other is in my list, if new fails, Node will still be ain a valid state

## Alternative - idiom

```c++
#include <utility>

struct Node {
  // ...
  void swap(Node &other) {
    using std::swap;
    swap(data, other);
    swap(next, other.next);
  }

  Node &operator=(const Node &other) {
    Node tmp = other; // copy other
    swap(tmp); // swap with my old data
    return *this; // tmp deallocated, frees my old data
  }
}
```

Rvalues + Rvalue references

Recall: an levalue is anything an address, an lvalue reference (&) is always initialized by an lvalue

```c++
Node n{1, new Node{2, nullptr}};
Node m = n; // copy ctor
Node m2;
m2 = n; // copy assignment operator

Node plusOne(Node n) {
  for (Node *p = &n; p; p=p->next) {
    ++p->data;
  }
  return n;
}

Node m3 = plusOne(n); // What runs? What is other here?
// Compiler creates a temporary object to hold the result of plusOne, so other has something to point at
// copy ctor deep copies data drom the temp object
```

<br />

June 2, 2016 - Lecture 10
---

+ Need to be able to tell whether other is a reference to a temporary object or a standalone object
+ C++: rvalue reference Node&& is a reference be a temporary object (aka rvalue) of type Node
+ Version of the ctor that takes a Node&&

```c++
struct Node {
    // ...
    Node(Node &&other) { }
    // ... called a move ctor
}
```

What should it do? Steal other's data.

```c++
...
Node (Node &&other):
    data{other.data},
    next{other.next} { // steal data
        other.next = nullptr; // other will be destroyed, so point to null so that the Nodes it points to won't get destroyed
    }
```

Similarly:

```c++
Node m;
m = addOne(n); // Assignment from temporary
```

More assignment operator:

```c++
Node &operator=(Node &&other) {
    // steal other's data
    // destroy my old data
    // so we can just swap without copy

    using std::swap;
    swap(data, other.data);
    swap(next, other.next);
    return *this;

    // temp object will be destroyed and take our old data with it
}
```

If you don't define move ctor/move assignment operator, copy versions will be used.  
If the move ctor/move assignment operator is defined, it will replace calls to the copy ctor/copy assignment operator where the argument is a temporary (an rvalue).

## Copy/Move Elision

```c++
Vec makeAVec() {
    return {0,0}; // invokes basic ctor
}

Vec v = makeAvec(); // what operations run here? copy ctor? move ctor?
// Not sure, in g++: just the basic ctor, no cpy ctor, no move ctor
```

In some circumstances, the compiler is allowed to skip calling copy/move ctors (but doesn't have to). In the example above, makeAVec writes its result ({0,0}) directly into the space occupied by v in the caller, rather than copy it later

Example:
```c++
void doSomething(Vec v) { // pass-by-value copy ctor

}

doSomething(makeAVec());
```

+ result of makeAVec() written directly into the parameter - no copy
+ This is allowed, even if dropping ctor calls would change the behaviour of the program (e.g. if the ctors print something)
+ In this course, you are not expect edt oknow the eact circumstances under which copy/move elision is allowed

If you need all of the ctors to run:
```
g++14 -fno-elide-constructors
```
But this can slow down your program considerably.

In summary: **Rule of 5 (Big 5)**

If you need a custom version of any one of:
    1. copy ctor
    2. copy assignment operator
    3. destructor
    4. move ctor
    5. move assignment operator
Then you usually need a custom version of all 5. Because the circumstances you need to create one of them, will probably mean that these also apply to the other 4.

Notice: operator= is a member function, not a standalone function. When an operator is a member, "this" plays the role of the LHS argument.

```c++
struct Vec {
    int x, y;
    // ...
    Vec operator+(const Vec &other) {
        return {x+other.x, y+other.y};
    }
    Vec operator*(const int k) {
        return {k*x, k*y}; // implements v*k
    }
}
```

How do we do k*v? Can't be a member-first arg not vec. Must be a non-member (as before)

I/O operators:

```c++
struct Vec {
    // ...
    ostream &operator<< (ostream &out) {
        return out << x << '' << y;
    }
}
```

What's wrong? It makes Vec the LHS and ostream the RHS. Use as v << cout

So define <<, >> as standalone functions.

Certain operators must be members:

+ operator=
+ operator[]
+ operator()
+ operator->
+ operatorT (where T is a type)

## Arrays of Objects

```c++
struct Vec {
    int x, y;
    Vec (int x, int y):
    x{x}, y{y}
    {

    }
};

Vec *vp = new Vec[10]; // ERROR
Vec moreVectors[15]; // ERROR
```

These want to call the default ctor on each item, but there isn't one. Thus cannot initialize.

**Options:**

1. Provide a default ctor
2. For stack arrays:

```c++
Vec moreVecs[3] = {...};
```

3. For heap arrays, create an array of pointers

```c++
Vec **vp = new Vec*[5];
vp[0] = new Vec{0,0};
vp[1] = new Vec{1,3}; // etc...
// then delete

for (int i = 0; i < 5; ++i) {
    delete vp[i];
}

delete [] vp;
```

## Separate Compilation for Classes

```c++
// Node.h

#ifndef _NODE_H_
#define _NODE_H_

struct Node {
    int data;
    Node *next;
    explicit Node(int data, Node *next=nullptr);
    Node(const Node &other);
}
#endif

// Node.cc

#include "Node.h"

// Prefix with Node::
// Double colon :: = scope resolution operator

Node::Node(int data, Node *next): data{data}, next{next} {}
Node::Node(const Node &other): data{other.data}, next{} {}

// Node::___ means ____ in the context of struct Node
// :: is like . for classes
// . where LHS is a class (or namespace), not an object

```

## Const Objects

```c++
int f(const Node &n) {...}    
```

Const objects arise often, especially in params.  
What is a const object? - Fields cannot change.

Can we call methods on a const object?  
Issue: method might change fields (violate const)

A: Yes. We can call methods that promise not to mofidy fields

```c++
struct Student {
    int assns, mt, final;
    float grade() const; // doesn't modify fields, so declare it const
}
```

Compiler checks that const methods don't modify fields. Only const methods can be called on const objects.

Now consider: Want to collect usage stats on Student obj

```c++
struct Student  {
    // ...
    int numMethodCalls = 0;
    float grade () { // now can't call on const Students
        ++numMethodCalls;
        return ;
    }
}
```

But mutating numMethod calls affect only the **physical constness** of the object (actual bit pattern), not its **logical constness** (whether it acts like a constant).

Want to update numMethodCalls, even if the object is const.
Solution: Declare the field mutable

```c++
struct Student {
    // ...
    mutable int numMethodCalls = 0;
    // can be changed, even if the object is const

    float grade () {
        ++numMethodCalls;
        return 100;
    }
}
```

<br />

June 7, 2016 - Lecture 11
---

## Static Fields and Methods

```c++
struct Student {
  mutable int nCalls = 0;
  float grade() const {
    ++nCalls;
    return 0; // blah blah blah
  }
};
```

nCalls tracks the number of times a method was called on a **particular object**. What if we want the number of calls over all Student objects? Or what if we want to know how many Students were created?

### Static Members

+ Associated with the class itself, NOT any particular object

```c++
struct Student {
  // ...
  static int numInstances;
  Student() {
    ++numInstances;
  }
};

// in .cc file
int Student::numInstances = 0;
```

**NOTE**: Static fields MUST be defined external to the class

### Static Member Functions

+ Don't depend on any particular instance (no "this" parameter) (not methods)
+ Can only access static fields and call other static member functions

```c++
struct Student {
  // ...
  static int numInstances;
  static void printNumInstances() {
    cout << numInstances << endl;
  }
};

// main
Student billy {};
Student jane {};
Student::printNumInstances(); // prints 2
```

## Invariants and Encapsulation

```c++
struct Node {
  int data;
  Node *next;
  Node(int d, Node *n);
  ~Node() {
    delete next;
  }
};

// main

Node n1{1, new Node{2, nullptr}};
Node n2{3, nullptr};
Node n3{4, &n2};
```

What happens when these go out of scope? n3's destructor tries to delete &n2, which is on the stack, not on the heap! Thus, UNDEFINED BEHAVIOUR!

Class Node relies on an assumption, called an **invariant**, a statement that shold always be true. In this case, the invariant is that next is either:

+ a nullptr, or
+ a valid pointer to the heap

But we cannot guarantee this invariant. Because we cannot control the user, we cannot guarantee any invariant because the user can interfere. For example, in a stack implementation, the invaraint is: last item pushed is the first item popped. If you cannot rely on variants, it would be hard to reason about programs

To solve: Encapsulation - we want clients to treat objects as "black boxes" (or capsules)

  + Implementation details are sealed away
  + Can only interact via the provided methods
  + Can create an abstraction, regain us control

E.g.

```c++
struct Vec {
  Vec(int x, int y); // by default, public
private:
  int x, y; // can only be accessed from inside Vec
public:
  vec Operator+(const Vec &v); // anyone can access
};
```

In general, we want fields to be private, and only methods should be public. Introducing class:

```c++
class Vec { // constructors etc are public
  int x, y; // private by default now
public:
  Vec(int x, int y);
  Vec operator+(const Vec &v);
};
```

Only difference between struct and class: default visibility, otherwise completely identical

Now we fix the linked list class

```c++
// list.h

class List {
  struct Node; // private nested class
  Node *theList = nullptr;
public:
  void addToFront(int n);
  int ith(int i);
  ~List();
  // ... etc etc
};

// list.cc
#include "list.h"
struct List::Node {
  // nested class
  int data;
  Node *next;
  Node(int d, Node *n): { // MIL

  }
  ~Node() {
    delete next;
  }
};

void List::addToFront(int n) {
  theList = new Node(n, theList);
}

int List::ith(int i) {
  Node *cur = theList;
  for (int j = 0; j < i; j++) {
    cur = cur->next;
  }
  return cur->data;
}

List::~List() {
  delete theList;
}
```

Only List can create/manipulate Node objects, thus we can guarantee the invariance that next is either a nullptr or a valid pointer to the heap. BUT, now we can't traverse the entire list in linear time. Repeated calling ith(int i) to traverse the whole list -> O(n<sup>2</sup>) time. On the other hand, we can't expose the Nodes or we will lose encapsulation

## SE Topic: Design Patterns

+ Certain problems arise frequently
+ Keep track of good solutions and use them in similiar situations
+ Good Solutions Hall of Fame
+ If you have a situation like this, then this technique may solve it

In this case, we use the **Iterator Pattern**.

+ Create a class that manages access to nodes (abstraction of a pointer)
+ Walk through the list without exposing the next pointers

```c++
class List {
  struct Node; // nested inner class
  Node *theList;
public:
  class Iterator {
    Node *p;
  public:
    explicit Iterator(Node *p): p{p} {}

    int &operator*() { // reference because might want to modify data
      return p->data;
    }

    Iterator &opeartor++() {
      p = p->next;
      return *this;
    }

    bool operator==(const Iterator &other) {
      return (p == other.p);
    }

    bool operator!=(const Iterator &other) {
      return !(*this == other);
    }
  };

  // standalone functions
  Iterator begin() {
    return Iterator(theList);
  }

  Iterator end() {
    return Iterator(nullptr);
  }

  // ... other list functions follow

};

// client

int main() {
  List l;
  l.addToFront(1);
  l.addToFront(2);
  l.addToFront(3);
  for (List::Iterator it = l.begin(); it != l.end(); ++it) {
    cout << *it << endl;
  }
  // prints 1 2 3
}
```

Shortcut when writing the Iterator for loop: we can use automatic type deduction

```c++
auto x = y; // auto gives x y's type

for (auto it = l.begin(); it != l.end(); it++) {
  cout << *it << endl;
}

// "shortercut" - Range-based for loop
for (auto n : l) {
  cout << n << endl;
}
```

Range-based for loop: available for all classes with:

+ Methods begin, end that produce Iterators
+ Iterator must support !=, prefix ++, unary *

If we want to modify list items(or save copying):

```c++
for (auto &n : l) { // use reference
  ++n;
}
```

<br />

June 9, 2016 - Lecture 12
---

But List client can create Iterators directly by doing the following:

```c++
auto it = List::Iterator{nullptr};
```

This violates encapsulation as the client should be calling begin and end, which we provide.

We could preserve encapsulation by:

+ Making Iterator's constructor private
  + Then client cannot call List::Iterator
  + But then neither can List
+ **Solution**: give list privileged access to Iterator -> make it a **friend**

E.g.

```c++
class List {
  // ...
public:
  class Iterator {
    Node *p;
    explicit Iterator(Node *p);
  public:
    // ... Iterator functions
    // friend
    friend class List; // List now has access to all members of Iterator
  }
}
```

Now, List can still create Iterators, but client can only create Iterators by calling begin and end.

**NOTE**: Give your classes as few friends as possible, because it weakens encapsulation. Once again, we want to keep fields private.

What if you want to give clients access to fields? "Getters" and "Setters" methods

E.g.

```c++
class Vec {
  int x, y;
public:
  int getX() const { return x; }
  void setY(int newY) { y = newY; }
};
```

What about operator <<? It needs x and y, but it cannot be a member function

+ If getX, getY are defined, then we are ok
+ But if you don't want to provide getX and getY, make operator<< a friend function that is standalone

E.g.

```c++
// .h file

class Vec {
  // ...
public:
  // ...
  friend std::ostream &operator<<(std::ostream &out, const Vec &v);
};

// .cc file

ostream &operator<<(ostream &out, const Vec &v) {
  return out << v.x << " " << v.y;
}
```

## Tools Topic: Make

**Separate Compilation**: lectures/c++/tools/example1

```
g++14 -c list.cc
g++14 -c node.cc
g++14 -c iter.cc
g++14 -c main.cc
g++14 main.o iter.o node.o list.o -o myprogram
```

Why do we do this? So we don't have to recompile files that haven't changed.

But how do we keep track of what's changed and what hasn't? Let Linux help you with **make**. We can create a Makefile that says which files depend on which other files. Refer to /lectures/c++/tools/example1/Makefile

```
myprogram: main.o list.o node.o iter.o # (myprogram depends on these)
  g++-5 -std=c++14 main.o list.o node.o iter.o -o myprogram # (tab in the beginning)
```

Then from the command line:

```
make # builds the whole project
# Now change iter.cc
make # recompiles iter.cc and then relinks myprogram
```

Command **make**: builds the first target (myprogram) in the Makefile. And what does myprogram depend on? main.o, list.o, node.o, iter.o. So make recursively builds these if necessary. Make uses a dependency graph.

For example, iter.cc changes, then iter.cc is now newer than iter.o (by checking the last modified date and time). Thus make rebuilds iter.o. Now iter.o is newer than myprogram, thus make rebuilds myprogram

Make can also build specific targets, for example make node.o

Common practice: put a target clean: at the bottom of the Makefile to remove all binaries

```
.PHONY: clean # (to avoid a file called clean if present)
clean:
  rm *.o myprogram
```

To do a full rebuild:

```
make clean
make
```

Now we can generalize with variables. In the Makefile:

```
CXX = g++-5
CXXFLAGS = -std=c++14 -Wall # (turns on all warnings)
```

E.g.

```
iter.o: iter.cc iter.h
${CXX} ${CXXFLAGS} -c iter.cc
```

Shortcut: for any make of the form

```
x.o: x.cc a.h b.h
```

We can leave out the build command and make would guess that the build command is ${CXX} ${CXXFLAGS}, so we can just write

```c++
-c x.cc -o x.o
```

Biggest problems:

+ Writing dependencies
+ Maintaining them if they change

Can get help from g++:

```
g++14 -MMD -c iter.cc
```

This creates iter.o **and** iter.d, and iter.d contains:

```
iter.o: iter.cc list.h node.h
```

Now just include iter.d in the Makefile:

```
CXX = g++-5
CXXFLAGS = -std=c++14 -Wall -MMD
OBJECTS = main.o list.o iter.o node.o
DEPENDS = ${OBJECTS:.o=.d}
EXEC = myprogram

${EXEC}:${OBJECTS}
  ${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}

-include ${DEPENDS}
```

As the project expands, just add .o files to the Makefile

## System Modelling

Building an object-oriented system involves identifying abstractions and formalizing the relationships among items. It helps to map out relationships. A popular standard is the Unified Modelling Language (UML). Modelling a class, write its name, fields (optional), and methods (optional), and use + to denote public and - to denote private

### Relationship: Composition

```c++
class Vec {
  int x, y;
public:
  Vec(int x, int y);
};

class Basis {
  Vec v1, v2;
};

// client
Basis b;
```

This will not compile because Basis cannot initialize v1, v2, because the default constructor for b calls default constructors for v1, v2, which do not exist.

```c++
class Basis {
  Vec v1, v2;
public:
  Basis(): v1{1, 0}, v2{0, 1} {} // default constructor, now it will compile
};
```

Embedding one object (v1) into another (b), called **composition**. The relationship between Basis and Vec is called "owns-a", as a Basis "owns a" two Vecs.

If A owns a B, then typically:

+ B has no identity outside of A
+ If A is destroyed, then B is destroyed
+ If A is copied, then B is copied (deep copy)

<br />

June 14, 2016 - Lecture 13
---

A car owns 4 wheels

+ A wheel is a part of a car
+ Destroy the car -> Destroy the wheels
+ Copy the car -> Copy the wheels
+ **Implementation: Composition of classes**
+ UML: A -> B  (filled arrow), means A owns some number of B's, can annotate with multiplicities

### Relationship: Aggregation

+ Compare parts in a car ("owns a") vs. car parts in a catalogue
+ A "has a" relationship (aggregation): the catalogue contains the partsm but the parts have an independent existence
+ If "A has B", then typically:
  + B has an existence apart from its association with A
  + If A is destroyed, then B lives on
  + If A is copied, B is not (shallow copy) - copies of A share the same B
+ **Implementation: Pointer fields**

E.g. Parts in a catalogue, ducks in a pond; UML: Pond -> Duck (hollow arrow)

```c++
class Pond {
  Duck *ducks[maxDucks];
};

class Car {
  Person *driver;
}
```

## Specialization/Generalization (Inheritance)

Suppose you want to track your collection of books

```c++
class Book {
  string title, author;
  int numPages;
public:
  Book(...); // ctor
  // other functions
};
```

For textbooks, we also want the **topic**:

```c++
class Text {
  string title, author;
  int numPages;
  string topic;
public:
  Text(...); // Text ctor
  // other functions
};
```

For comic books, we want the **hero**:

```c++
class Comic {
  string title, author;
  int numPages;
  string hero;
public:
  Comic(...); // Comic ctor
  // other functions
};
```

This is okay, but it doesn't capture relationships among Book, Text, and Comic. And how do we create an array (or other collection) with a mix of these?

We could:

1. Use a union - *BAD (subverts the type system)**

```c++
union BookTypes{Book *b; Test *t; Comic *c;};
BookTypes myBooks[20];
```

2. Array of void * **BAD (pointer to anything)**

Rather, observe that Text and Comic are kinds of Books - Books with extra features.

C++ - model with Inheritance

```c++
// Base class (superclass)
class Book {
  string title, author;
  int numPages;
public:
  Book(...);
  // ...
};

// derived classes (or subclasses)
class Text : public Book {
  string topic;
public:
  Text(...);
  // ...
};

class Comic : public Book {
  string hero;
public:
  Comic(...);
  // ...
};
```

Derived classes **inherit** fields and methods from the base class, so Text, Comic get title, author, numPages fields. Any method that can be invoked on Book can be called on Text and Comic.

Who can see these members?

+ title, author, numPages - private in Book; Text and Comic cannot see them, even subclasses can't see them

How do we initialize Text? Need title, author, numPages (these are needed to initialize the Book part) and topic (specific to Text)

```c++
class Text : public Book {
  string topic;
public:
  Text(string title, string author, int numPages, string topic) :
  title{title}, author{author}, numPages{numPages}, topic{topic} {}
  // WRONG!!!
};
```

Wrong for 2 reasons:

+ title etc are not accessible to Text
+ Once again, when an object is constructed:
  1. space is allocated
  2. superclass part is constructed (NEW!)
  3. fields constructed
  4. constructor body runs

And in this case, superclass cannot be constructed because Book has no default constructor.

**Fix:** invoke Book's constructor in Text's MIL

```c++
class Text : public Book {
  string topic;
public:
  Text(string title, string author, int numPages, string topic):
  Book{title, author, numPages}, topic{topic} {}
};
```

**NOTE:** If a superclass has no default constructor, subclass must invoke a superclass constructor in its MIL. Good reasons to keep superclass's fields inaccessible to subclasses. If you want to give subclasses access to certain members, use **protected** access:

```c++
class Book {
  protected:
    string title, author;
    int numPages; // accessible to Book and its subclasses
  public:
    Book(...);
    // ...
};

// subclasses
class Text: public Book {
  // ...
  public:
    // ...
    void addAuthor(string newAuthor) {
      author += newAuthor;
    }
};
```

Note: Not a good idea to give subclasses unlimited access to fields; **Better** - make fields private, but provide protected accessors

```c++
class Book {
  string author, title;
  int numPages;
protected:
  string getTitle() const;
  void setAuthor(string newAuthor);
public:
  Book(...); // ctor
  bool isItHeavy() const;
};
```

Relationship among Book, Text, and Comic is called "is a": A Text is a Book; A Comic is a Book. UML: Text->(hollow)Book<-(hollow)Comic. Implement "is a" by public inheritance.

Now consider the method isItHeavy. When is a Book heavy?

+ For ordinary Books, > 200 pages
+ For Texts, > 500 pages
+ For Comics, > 30 pages

```c++
class Book {
  // ...
public:
  // ...
  bool isItHeavy() const {
    return numPages > 200;
  }
};

class Text {
  // ...
public:
  // ...
  bool isItHeavy() const {
    return numPages > 500;
  }
};

class Comic {
  // ...
public:
  // ...
  bool isItHeavy() const {
    return numPages > 30;
  }
};

// =====================
// client
Book b {"A small book", "1Q84", 50};
Comic c {"A big comic", "Waterloo Memers", 40, "Mr Paninos"};
cout << b.isItHeavy(); // false, it's a small Book as 50 < 200
cout << c.isItHeavy; // true, it's a big comic as 40 > 30
```

Since public inheritance means "is a", we can do:

```c++
Book b = Comic{"A big comic", "Balkan Chevaps", 40, "We Deliver"};
```

**Question:** Is b heavy? b.isItHeavy() returns true or false? Which isItHeavy() run, Book::isItHeavy or Comic::isItHeavy?

**Answer:** No, it is not heavy. Book::isItHeavy is what runs. Why? Book contains 3 fields: title, author, numPages, while Comic contains 4 fields: title, author, numPages, and hero. Thus,

```c++
Book b = Comic {...};
```

tries to create a Comic object when there's only space for a Book. Comic is then **sliced ("hero" field is chopped off)**. Comic is coerced (forced) into a Book. Basically, Book b = Comic {...} converts a Comic into a Book and Book::isItHeavy runs.

When accessing objects through pointers, **slicing is unnecessary and does not occur**.

```c++
Comic c {"friend5ever", "Sedra Smith", 40, "RealisticAFMStudent"};
Book *pb = &c;
Comic *pc = &c;
cout << pc->isItHeavy(); // true; 40 > 30, heavy Comic
cout << pb->isItHeavy(); // false, 40 < 200, not heavy Book
// same behaviour as the slicing example, Book::isItHeavy runs as pointer is Book
```

Still, Book::isItHeavy runs when we access pb->isItHeavy(). Some objects behaves differently, depending on what type of pointer points to it.

<br />

June 16, 2016 - Lecture 14
---

Compiler uses the type of the pointer (or type of the reference) to decide which isItHeavy to run. It does not consider the actual type of the object. So a Comic is a Comic only if a comic pointer points to it. Pointer >>> Actual object.

Then, how do you make Comic act like a Comic, even when pointed at by a Book pointer? **Solution: declare the method virtual**.

```c++
class Book {
  // ... fields
protected:
  int numPages;
public:
  Book(...);
  virtual bool isItHeavy() const; // use of virtual here
};

class Comic : public Book {
  // ...
public:
  bool isItHeavy() const override; // override keyword in virtual function
};

// =================
// client
Comic c {"RealisticMathStudent", "UWGo", 40, "Quest God"};
Book *pb = &c;
Book *rb = c;
Comic &pc = &c;
Book b = c;

cout << pb->isItHeavy(); // true, Comic::isItHeavy
cout << rb.isItHeavy(); // true, Comic::isItHeavy
cout << pc->isItHeavy(); // true, Comic::isItHeavy
cout << b.isItHeavy(); // FALSE, Book::isItHeavy
```

### Virtual and Polymorphism

**Virtual Methods**: chosen based on the actual types of the object at **runtime**  
**Dynamic Dispatch**: the process of virtual methods being resolved to the correct one at runtime is known as dynamic dispatch. It is the process of chossing which method to call at runtime based on the type of a value. We use this by putting **virtual** in the superclass.

E.g. My book collection

```c++
Book *myBooks[20];
for (int i = 0; i < 20; i++) {
  cout << myBooks[i]->isItHeavy << endl;
  // This uses Book::isItHeavy for Books, Text::isItHeavy for Texts
  // and Comic::isItHeavy for Comics
}
```

It accommodates multiple types under one abstraction -> **Polymorphism**

Note: This is why a function

```c++
void f(istream &in);
```

can be passed an ifstream, because ifstream is a subclass of istream.

**DANGER**

```c++
class One {
  int x, y;
public:
  One(int x = 0, int y = 0): x{x}, y{y} {}
};

class Two : public One {
  int z;
public:
  Two(int x = 0, int y = 0, int z = 0): One{x, y}, z{z} {}
};

void f(One *a) {
  a[0] = {6, 7};
  a[1] = {8, 9};
}

// ===============
// clientdas
Two myArray[] = [{1, 2, 3}, {4, 5, 6}];
f(myArray);
```

**Data Misaligned**: MyArray is originally [1 2 3][4, 5, 6]; after calling f, it becomes [6 7 8][9 5 6].

Note: NEVER use arrays of objects polymorphically. If you want polymorphism, use an array of pointers

### Destructor Revisited

```c++
class X {
  int *x;
public:
  X(int n): x{new int[n]} {}
  ~X() {
    delete [] x;
  }
}

class Y : public X {
  int *y;
public:
  Y(int m, int n): X{n}, y{new int[m]} {}
  ~Y() {
    delete [] y;
  }
}

// =================
// client
X *myX = new Y{5, 10};
delete myX; // LEAKS!
```

**Why?** The last line calls ~X, not ~Y, so only x, but not y, is freed.  
To ensure that deletion through a superclass pointer calls the subclass destructor, **declare the destructor virtual**.

```c++
class X {
  // ...
public:
  // ...
  virtual ~X();
};
```

**ALWAYS** make the destructor virtual in classes that are meant to have subclasses, even if the virtual destructor does nothing. If a class is NOT meant to have subclassses, declare the destructor **final**.

### Pure Virtual Methods and Abstract Classes

```c++
class Student { // there are 2 kinds of Students, regular and co-op
protected:
  int numCourses;
public:
  // ...
  virtual int fees() const;
};

class Regular : public Student {
public:
  int fees() const override; // virtual - override
  // regular fees
};

class Coop : public Student {
public:
  int fees() const override; // virtual - override
  // coop fees
};
```

What do we put for Student::fees? We don't know, because every Student should be either regular or co-op.

We can explicitly given Student::fees **NO implementation** -> **pure virtual method**

```c++
class Student {
  // ...
public:
  virtual int fees() const = 0; // =0, NO IMPLEMENTATION
  // Called pure virtual method = no implementation
};
```

A class with a **pure virtual method cannot be instantiated**, and the class is called an **abstract class**. Its purpose is to organize subclasses.

Subclasses of abstract classes are abstract as well, **unless they implement ALL pure virtual methods.** Non-abstract classes are called **concrete classes**.

UML: virtual and pure virtual methods: italics; abstract class: class name in italics; protected: #

### Inheritance and Copy/Move

```c++
class Book {
  // ...
public:
  // Defines all copy/move operators here
};

class Text : public Book {
  // ...
public:
  // DOES NOT define copy/move operators
};

// ===============
// client
Text t {"Algorithms", "CLRS", 500, "CS"};
Text t2 = t; // No copy ctor in Text, what happens?
// calls Book's copy ctor,
// then goes field by field (i.e. default behaviour) for the Text part
// same for other opeartors
```

To write your own:

```c++
// copy ctor
Text::Text(const Text &other) : Book{other}, topic{other.topic} {}

// copy assignment opor
Text &Text::operator=(const Text &other) {
  Book::operator=(other); // superclass copy assignment
  topic = other.topic; // assign field
  return *this;
}

// move ctor
Text::Text(Text &&other): Book{std::move(other)}, topic{std::move(other.topic)} {

}

// move assignment opor
Text &Text::operator=(Text &&other) {
  Book::operator=(std::move(other));
  topic = std::move(other.topic);
  return *this;
}
```

**Note**: Even though other "points" at an rvalue, other itself is an lvalue. std::move(x) forces lvalue x to be treated as an rvalue, so that move versions of operators can run

<br />

June 21, 2016 - Lecture 15
---

```c++
Text t1{...};
Text t2{...};
Book *pb1 = &t1;
Book *pb2 = &t2;
```

What if we do

```c++
*pb1 = *pb2; // ?
```

Then Book::operator= runs, **partial assignment** - copies only the Book part. How do we fix this? Try making operator= virtual.

```c++
class Book {
  // ...
public:
  // ...
  virtual Book &operator=(const Book &other); // make the copy assignment opor virtual
};

class Text : public Book {
  // ...
public:
  Text &operator=(const Book &other) override; // override - virtual in subclass
};
```

Note: different return types, but parameter types must be the same or it's not an override, and thus WILL NOT COMPILE.

Thus assignment of a Book object to a Text variable would be allowed.

```c++
Text t {...};
Book b {...};
Text *pt = &t;
Book *pb = &b;
*pt = *pb; // uses a book to assign to a text, BAD

// ALSO
Comic c {...};
Comic *pc = &c;
*pt = *pc; // BAD
```

If operator= is non-virtual -> partial assignment through base class pointers -> BAD  
If operator= is virtual -> compiler allows mixed assignment -> BAD

Recommendation: All superclasses should be **abstract**.

```c++
class AbstractBook {
  string title, author;
  int numPages;
protected:
  AbstractBook &opeartor=(const AbsratctBook &other);
  // prevents assignment through base class pointers from compiling
  // but implementation still available to subclasses
public:
  AbsratctBook(...);
  virtual ~AbsratctBook() = 0; // "be abstract"
  // need at least one pure virtual method to make it abstract
  // if you don't have any, make dtor pure virtual
};

class NormalBook : public AbstractBook {
public:
  NormalBook(...);
  ~NormalBook();
  NormalBook &operator=(const NormalBook &other) {
    AbstractBook::operator=(other);
    return *this;
  }
};

// ============
// client
*pb1 = *pb2; // DOES NOT COMPILE
```

**Prevents mixed & partial assignment**.  
Note: virtual destructor must always be implemented, even if it is pure virtual.

```c++
AbsratctBook::~AbstractBook() {}
```

## Templates

Huge topic - just the highlights here

```c++
class List {
  struct Node;
  Node *theList;
  // ...
};

struct List::Node {
  int data;
  Node *next;
  // ...
};
```

**Question:** what if you want to store something else? Whole new class? Nah.

**Templates**: class parameterized by a type

```c++
template <typename T> class Stack {
  int size;
  int cap;
  T *data;
public:
  // ...
};

Stack(){...}
void push(T x){...}
T top(){...}
void pop(){...}

template <typename T> class List {
  struct Node {
    T data;
    Node *next;
  };
  Node *theList;
public:
  class Iterator {
    Node *p;
    explicit Iterator(Node *p): p{p} {}
  public:
    T &operator*() {
      return p->data;
    }
    // ...
  };

  T ith(int i) {
    // ...
  }

  void addToFront(T n) {
    // ...
  }
};

// ==================
// client
List <int> l1;
List <List<int>> t2;
t1.addToFront(3);
t2.addToFront(l1);

for (List<int>::Iterator it = l1.begin(); it != l1.end(); it++) {
  // ...
}
```

Compiler specializes template at the source code level, before compilation begins. Refer to /string/istream/ostream templates.

## The Standard Template Library (STL)

Large number of useful templates

E.g. dynamic length arrays: vectors

```c++
#include <vector>
using namespace std;

vector<int> v {4, 5}; // vector<int> v(4,5) = {5,5,5,5};
v.emplace_back(6); // {4,5,6}
v.emplace_back(7); // {4,5,6,7}
```

Looping over vectors:

```c++
for (int i = 0; i < v.size(); i++) {
  cout << v[i] << endl;
}

// OR
for (vector<int>::iterator i = v.begin(); i != v.end(); i++) {
  cout << *i << endl;
}

// To iterate in reverse
for (vector<int>::reverse_iterator = v.rbegin(); it != v.end(); it++) {
  // ...
}

// To remove last element
v.pop_back();

// Use iterators to remove items from inside the vector
auto it = v.erase(v.begin()); // erase element 0
it = v.erase(v.begin() + 3); // erase element 3
// returns an iterator to first item after the erase

it = v.erase(it); // erase item pointed to by it
it = v.erase(v.end() - 1); // erase last item

v[i]; // i-th element of v; unchecked: out of bounds -> undefined behaviour
v.at(i); // checked version of v[i], what happens if i is out of bounds
```

**Question**: What should happen?

Problem: Vector can detect the error, but doesn't know whatto do about it

C Solution: function returns a status code, or set the global variable errno; encourages programmers to ignore error checks

C++ Solution: when an error condition occurs, the function raises an exception

<br />

June 23, 2016 - Lecture 16
---

## Exceptions

What happens? By default, execution stops. But we can write **handler** to **catch** exceptions and deal with them. vector <T>::at throws exception out_of_range.

```c++
#include <stdexcept>
// ...
try {
  cout << v.at(1000) << endl; // statements that may raise an exception
  // go in the try block
} catch (out_of_range) {
  cerr << "range error\n";  
}
```

Consider:

```c++
void f() {
  throw out_of_range {"f"}; // raise an exception
}

void g() {
  f();
}

void h() {
  g();
}

int main() {
  try {
    h();
  } catch (out_of_range) {
    // ...
  }
}
```

What happens?

main calls h, h calls g, g calls f, f throws, g has no handler for out_of_range, control goes back through the call chain (unwinds the stack) until a handler is found. Control goes all the way back to main, main handles the exception.

If no one handles the exception, program terminates.

What is out_of_range? It's a class.

```c++
throw out_of_range {"f"}; // invokes a ctor with arg "f" and throws it
// "f" is auxiliary information
```

To examine auxiliary information:

```c++
try {
  // ...
} catch (out_of_range ex) {
  cout << ex.what() << endl; // prints "f"
}
```

A handler might do part of the recovery job - execute some corrective code and raise another exception:

```c++
try {
  // ...
} catch (someErrorType s) {
  // ...
  throw someOtherError(...);
}
```

Or throw the same exception:

```c++
try {
  // ...
} catch (someErrorType s) {
  // ...
  throw;
}
```

The difference between throw and throw s. Throw is used when an actual type of s is retained (most cases), it rethrows the same exception object it caught; throw s: s may be a subtype of someErrorType, throw rethrows a new exception of type someErrorType.

A handler can act as a catch-all:

```c++
try {
  // ...
} catch (...) { // catches all exceptions
  // ...
}
```

You can throw anything you want - doesn't have to be objects

Define your own classes (or use appropriate existing ones) for errors. E.g.

```c++
class BadInput();

try {
  int n;
  if (!(cin >> n)) {
    throw BadInput{};
  }
} catch (BadInput &) { // catch by ref to prevent slicing
  cerr << // ...
}
```

Note:

```c++
class BaseExn{};
class DerivedExn : public BaseExn{};

void f() {
  DerivedExn d;
  BaseExn &b = d; // BaseExn type
  throw b;
}

try {
  // ...
  f();
  // ...
} catch (DerivedExn &) {
  // ... DerivedExn handler
} catch (BaseExn &) {
  // ... BaseExn handler
}
```

Which handler runs? BaseExn handler runs, as the type of the reference (i.e. the static type of the object) determines the handler.

Some standard exceptions:

+ length_error - attempting to resize strings/vectors that are too long
+ bad-alloc - new fails
+ ios::failure - I/O streams fail; refer to lectures/c++/exceptions

**NEVER NEVER NEVER let a destructor throw an exception**

+ If the dtor was executed during stack unwinding while dealing with another exception, you now have two active unhandled exceptions, and the program will terminate immediately

## Design Patterns (Continued)

**Guiding Principle**:

+ Program with interfaces not implementations
+ Abstract base classes define the interface
+ Work with pointers to an abstract base class and call their methods
+ Concrete subclasses can be swapped in and out
+ Abstracting over a variety of behaviours

```c++
class List {
  // ...
public:
  class Iterator : public AbstractIterator {
    // ...
  };
};

class Set {
  // ...
public:
  class Iterator : public AbstractIterator {
    // ...
  };
};

class AbstractIterator {
public:
  virtual int &operator*() = 0;
  virtual AbstractIterator &operator++() = 0;
  virtual bool operator==(...) = 0;
  virtual ~AbstractIterator();
};
```

Then you can write code that operates over iteartors:

```c++
template <typename T>
void foreach(AbstractIterator start, AbstractIterator end, T f) {
  while (start != end) {
    f(*start); // f must be a callible entity
    ++start;
  }
}
// this works over both Lists and Sets

List l;
foreach(l.begin(), l.end(), someFunction);
```

<br />

June 28, 2016 - Lecture 17
---

## Observer Design Pattern

aka **publish-subscribe model**

Publisher/Subject - source of data, generates data; Subscribers/Observers - receive data and react to it.

Sequence of the model calls:

1. Subject's state is updated()
2. Subject::notifyObservers() -> calls each observer's notify();
3. Each observer calls ConcreteSubject::getState() to react accordingly

E.g. horse races; subject publishes winners, observers (individual betters) declare victory when their horse wins.

```c++
class Subject {
  vector <Observers *> observers;
public:
  void attach(Observer *ob) {
    observers.emplace_back(ob); // add to observers
  }

  void detach(Observer *ob) {
    // remove
  }

  void notifyObservers() {
    for (auto &ob; observers) {
      ob->notify();
    }
  }

  virtual ~Subject() = 0; // make class abstract
};

Subject::~Subject() {} // dtor must have user-defined implementation (since declared pure virtual)

class Observer {
public:
  virtual notify() = 0;
  virtual ~Observer() = 0;
}

class Horserace : public Subject {
  ifstream in; // get data from that file
  string winner;
public:
  Horserace(string source) : in{source};
  bool race(); // true if there was a race, false if EOF
  string getState() {
    return winner;
  }
}

class Bettor : public Observer {
  Horserace *subject;
  string name, myHorse;
public:
  Bettor(...) ... {
    subject->attach(this);
  }

  void notify() {
    string winner = subject->getState();
    cout << (winner == myHorse ? "Win" : "Lose") << endl;
  }
}

// main
Horserace hr;
Bettor Larry(hr, "Larry", "Pig4");

while (hr.race()) {
  hr.notifyObservers();
}
```

**Simplifications**:

1. If only one type of subject, could merge Subject and ConcreteSubject
2. If state is trivial (so that just let notify tells you all you need to know), then don't need getState()
3. If subject = observer (e.g. cell in a grid in a spreadsheet), could merge these classes

## Decorator Pattern

+ Want to add features to an object at runtime

E.g. Operating System: basic window, then add menu, then add scrollbar, and we want to change these at runtime

class component - interface - operations

You will provide

ConcreteComponent - implements the interface

Decorators all inherit from Decorator, which inherits Component. Thus every Decorator is a Component and every Decorator has a Component

A window with a scrollbar is a window, and has a pointer to the underlying plain window. Windw with scrollbar and menu is a window and has a pointer to a pointer to a window with scrollbar, which has a pointer to a plain window


<br />

June 29, 2016 - Tutorial
---

protected: acts like private, but subclasses can access superclass fields; within the hierarchy

```c++
struct Computer {
  void makeCall() {
    cout << "Making call" << endl;
  }
  void test() {
    cout << "Testing" << endl;
  }
};

struct Smartphone : public Computer {
  void makeCall() {
    cout << "Mobile" << endl;
  }
};

void testCall(Computer& c) {
  c.test();
  c.makeCall();
}

int main() {
  Smartphone lmao;
  testCall(lmao);
  Computer *laptop = new Smartphone;
  laptop->makeCall();
  lmao.makeCall();
  lmao.test();
}
```

<br />

June 30, 2016 - Lecture 18
---

**Midterm got curved**: Original average 49%, avergae after adjustment 66%

## Design Pattern: Template Method Pattern

We want subclasses to override superclass behaviour, but some aspects must stay the same

+ A design pattern where we override some behaviour from a superclass, but not all of it - the superclass is used as a template for the subclass

E.g. There are red and green turtles.

```c++
// superclass
class Turtle {
public:
  void draw() { // method to draw turtle and its components
    drawHead();
    drawShell();
    drawFeet();
    // note not virtual as the class is not abstract
    // thus not open for overriding
    // subclasses cannot change the fact that draw must
    // draw head, shell, and feet
  }

private:
  void drawHead(); // not virtual, cannot override
  void drawFeet(); // not virtual, cannot override
  virtual void drawShell() = 0; // pure virtual
  // enables subclasses to override this method
  // gives subclasses a little bit of control
  // but not total control
};

// subclass
class RedTurtle {
  void drawShell() override; // virtual - override
  // draw red shell
};

class GreenTurtle {
  void drawShell() override; // draw green shell
};
```

Class Turtle is like a boilerplate or a template, a fill-in-the-blank form. Has absolutely nothing to do with standard template library (STL). Subclasses cannot change the way a turtle is drawn, i.e. head, shell, feet, but they **can** change the way the shell is drawn.

Note: In the Turtle class, drawShell() is a private virtual function, but it is perfectly legal to override, not to call. Subclasses have to call their own drawShell().

Extension: The Non-Virtual Interface (NVI) Idiom

A public virtual method is really two things:

+ public: thus an interface to the client
  + indicates provided behaviour with pre/post conditions
+ virtual: thus an interace to subclasses
  + a "hook" to insert specialized behaviour

Hard to separate these ideas if they are tied to the same function

What if you later want to separate the customizable behaviour into 2 functions, maybe with some unchanging code in between? Without changing the public interface?

How can you make sure overriding functions respect pre/post conditions?

**The NVI idiom says:**

+ All public methods should be non-virtual
+ All virtual methods should be private, or at least, protected
+ Exception: Destructor

Example:

```c++
class DigitalMedia {
public:
  virtual void play() = 0;
};

// In NVI:
// doPlay is a pass through function
class DigitalMedia {
public:
  void play() {
    // so we can control what happens here
    doPlay();
    // and here
    // and not gonna be any slower, because the compiler will optimize as it sees fit
  }
private:
  virtual void doPlay() = 0;
};
```

So now we can add before and after code.

E.g. Check copyright so I don't get sued, update play count after the function call, or add another hook: showArt() = 0;

Extends Template Method - puts **EVERY** virtual function inside a template method.

## STL - Maps = Dictionaries

E.g. "Arrays" that map string sto ints

```c++
#include <map>

std::map<string, int> m;
m["abc"] = 1;
m["def"] = 4;
cout << m["ghi"] << endl; // prints 0
// if key not present, it is inserted
// and value is default-constructed (for ints: 0)
cout << m["abc"] << endl; // prints 1

m.erase("abc");

if (m.count("def")) { // the number is either 0 or 1
  // 0 means not found, and 1 means found
}
```

Iterating over a map: sorted key order

```c++
for (auto &p : m) {
  cout << p.first << ' ' << p.second << endl;
  // first is key, second is value
  // p's type is std::pair<string, int>& (<utility>)
  // also, p.first and p.second are fields, not methods
  // not private fields?
  // Because no invariant, we can just expose the fields
}
```

## Tools: Debugger GDB

To use: compile with -g (enable debugging information)

```
g++14 -g myfile.cc
```

To run the debugger:

```
gdb ./a.out
```

Commands:

+ r (run):
  + runs the program
  + if the program crashes, it tells you the error
+ bt (backtrace): prints the chain of functions that got you here
+ l (list): lists the source surrounding the current point of execution; gives you context
+ p (print): prints the value of a variable or expression
+ q (quit)

Not all bugs are segfaults though.

Breakpoints: tell gdb to stop the program so you can see what is going on.

```
break f
```

This says break when entering function f. Or,

```
break myfile.cc:15
```

This says break on line 15.

+ s (step): runs one line
+ c (continue): runs until the next breakpoint

## Design Pattern: Visitor Pattern

For implementing **double dispatch**.

Virtual method - chosen based on the actual type (at runtime) of the receiving object.

What if we want to choose based on two objects?

UML: Turtle -> (hollow) Enemy <-(hollow) Bullet  
Stick -> (hollow) Weapon <-(hollow) Rock

We want something like virtual void(Enemy, Weapon)::strike(); (not C++ though)

```c++
class Enemy {
  virtual void beStruckBy(Weapon &w);
};

class Weapon {
  virtual void strike(Enemy &e);
};

// each of these only does half the job
```

Trick to get dispatch on both:

+ Combine overriding with overloading

**Override** the virtual beStruckBy function:

```c++
class Enemy {
public:
  virtual void beStruckBy(Weapon &w) = 0; // pure virtual
};

class Turtle : public Enemy {
public:
  void beStruckBy(Weapon &w) override {
    w.strike(*this); // compiler knows *this is a Turtle
  }
};

class Bullet : public Enemy {
public:
  void beStruckBy(Weapon &w) override {
    w.strike(*this); // compiler knows *this is a Bullet
  }
};
```

Now **overload** strike that takes in both Turtle ref and a Bullet ref:

```c++
class Weapon {
public:
  virtual void strike(Turtle &t) = 0;
  virtual void strike(Bullet &b) = 0;
};

class Stick : public Weapon {
public:
  void strike(Turtle &t) {
    // strike a Turtle with a Stick
  }

  void strike(Bullet &b) {
    // strike a Bullet with a Stick
  }
};

class Rock : public Weapon {
public:
  void strike(Turtle &t) {
    // strike a Turtle with a Rock
  }

  void strike(Bullet &b) {
    // strike a Turtle with a Rock
  }
};

// ===================
// client
Enemy *e = new Bullet;
Weapon *w = new Rock;
e->beStruckBy(*w); // strike a Bullet with a Rock
```

beStruckBy is a **virtual method**, so Bullet::beStruckBy() runs. That calls Weapon::strike, and *this is bullet, so Bullet version gets chosen by compiler. The virtual method resolves to Rock::strike(Bullet &).
