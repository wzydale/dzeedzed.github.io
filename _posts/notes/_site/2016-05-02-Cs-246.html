<div class="highlighter-rouge"><pre class="highlight"><code>CS 246 - Object-Oriented Software Development
Instructor: Brad Lushman
Section: 001
Location: MC 4045
Time: Tuesdays and Thursdays 10:00am - 11:20am
Tutorials: MC 4060 Wednesdays 1:30pm - 2:20pm
Term: Spring 2016
</code></pre>
</div>

<p><strong>Shoutout to Brian Forbes, <a href="http://www.yufeiyang.me">Steven Yang</a>, and <a href="http://ziqizhou.com">Ziqi Zhou</a>!</strong></p>

<h2 id="may-3-2016---lecture-1">May 3, 2016 - Lecture 1</h2>

<p><strong>Grading Scheme</strong></p>

<ul>
  <li>Assignments - 0(A0) 7 7 7 7 12(project) = 40%</li>
  <li>Midterm (4:30pm - 6:20pm, June 23 (Th), 2016) = 20%</li>
  <li>Final = 40%</li>
</ul>

<p>This course requires you to work in Linux. There are several options:</p>

<ol>
  <li>Lab machines</li>
  <li>Install Linux on your own machines</li>
  <li>Make SSH connection to school machines (Use Putty (putty.exe) on Windows, winscp for file transfer, XMing for Xwindows)</li>
  <li>Download cygwin - Linux-like environment for Windows</li>
  <li>Get a Mac</li>
</ol>

<p><strong>4 Modules in this Course:</strong></p>

<ul>
  <li>Linux Shell (2 weeks)</li>
  <li>C++ Language, C++14 (10 weeks)</li>
  <li>Tools</li>
  <li>Software Engineering (design etc.)</li>
</ul>

<p>“Homework”: Go on Piazza -&gt; Linux Reference Sheet -&gt; Save and print</p>

<h2 id="module-1-linux-shell">Module 1: Linux Shell</h2>

<p>A shell is an interface to the operating system, i.e. how we get the OS to do things (run programs, manage files etc.). There are two kinds of shells: graphical (with icons and clicking) and the command line. The shell we will use is Bash. Check if you are using Bash, login to shell and type in:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ echo $0
</code></pre>
</div>

<p>It should return “bash”.</p>

<p><strong>Linux file system: working with files</strong></p>

<p><strong>cat</strong> - short for concatenate; display contents of a file (e.g. cat user/share/dict/words). In Linux, a directory is considered a special kind of file</p>

<p><strong>ls</strong> - list files in the current directory (non-hidden files)</p>

<p><strong>ls -a</strong> - list all files (including hidden; hidden files start with a “.”)</p>

<p><strong>pwd</strong> - print current directory (pwd = print working directory)</p>

<p>What happens when we only type in “cat”? It just kind of sits there, waiting for input. It’s kinda like a parrot, repeating what you typed in. If we can capture the output into a file…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ cat &gt; output.txt
</code></pre>
</div>

<p>It would capture the input. NOT RECOMMENDED: ^C. It would prevent cat from doing clean-up. Let it finish on its own: ^D at the beginning of a line sends an “EOF” signal to cat.</p>

<p>One greater than sign replaces, two appends.<br />
In general, command args &gt; file
executes command args + captures the output in file -&gt; called <strong>output redirection</strong>.</p>

<p>Using less than sign, takes in input from the file.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ cat &lt; output.txt
</code></pre>
</div>

<p>The line above displays the file. Seems to be equivalent to what we have before. Are these two things the same? NO. The reason is very important:</p>

<ul>
  <li>
    <p>cat input.txt -&gt; passes the NAME input.txt to cat as an argument. Cat opens input.txt and displays its contents</p>
  </li>
  <li>
    <p>cat &lt; input.txt -&gt; the shell opens the file and passes the contents to cat IN PLACE of keyboard input</p>
  </li>
</ul>

<p><strong>wc</strong> - word count, displays numbers of lines, words, and characters of a file</p>

<p><strong>cat *.txt</strong> - *.txt globbing pattern -&gt; matches any sequence of characters (the shell finds all files that mathch the pattern)</p>

<p><strong>cat &lt; *.txt</strong> - ERROR! The shell will only attach one file to cat’s input stream</p>

<p>Many (but not all) commands take both kinds of inputs:</p>

<p><strong>cat &lt; input.txt &gt; output.txt</strong> - sends chars from input.txt to output.txt; effectively a copy-paste action</p>

<p>Every process is attached to 3 streams. Stdin goes into the program, stdout and stderr come out of the program. Stdin -&gt; program -&gt; stdout and stderr. By default, stdin = keyboard, stdout, stderr = screen.
&lt; connects stdin to file, &gt; connects stdout to file, 2&gt; stdrr. Stderr separates output stream from error messages, so that output error messages can go to different places, and that error messages don’t cut/block output files.</p>

<p>Also, stdout may be <strong>buffered</strong>. System may assemble characters before displaying. However, stderr isn’t buffered, because user needs to see error messages immediately.</p>

<p><strong>Pipes</strong>: Make one program’s output(stdout) another program’s input(stdin). Example: How many words occur in the first 20 lines of sample.txt?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>head -n file
</code></pre>
</div>

<p>gives the first n lines of file</p>

<div class="highlighter-rouge"><pre class="highlight"><code>wc -w
</code></pre>
</div>

<p>counts words (just print the word count)</p>

<p>so</p>

<div class="highlighter-rouge"><pre class="highlight"><code>head -20 sample.txt | wc -w
</code></pre>
</div>

<table>
  <tbody>
    <tr>
      <td>Here,</td>
      <td>(the pipe symbol) makes the output of the command before it the input of the command after it.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h2 id="may-4-2016---tutorial-1">May 4, 2016 - Tutorial 1</h2>

<p>To zip your assignment files, do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>zip (directory where your files are).zip *
</code></pre>
</div>

<p>in the directory where the files are.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>marmoset_submit cs246 (question, e.g a0) (file you want to submit, zipped)
</code></pre>
</div>

<p>is how you submit assignments to Marmoset.</p>

<p><br /></p>

<h2 id="may-5-2016---lecture-2">May 5, 2016 - Lecture 2</h2>

<p>Suppose we have files words1.txt, words2.txt…, and each of them has one word per line. We want: A duplicate-free list of all the words used in any of these files</p>

<p>We need the following:</p>

<ul>
  <li>sort - sorts lines (man: Write sorted concatenation of all FILES(s) to standard output)</li>
  <li>uniq - remove consecutive duplicate lines from input (man: filter adjacent matching lines from INPUT, writing to OUTPUT)</li>
</ul>

<p>One possibility:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat words*.txt | uniq
</code></pre>
</div>

<p>What’s the problem with this? We must sort our input first, because for aabaacd, it would produce abacd, with duplicates.</p>

<p>This should work:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat words*.txt | sort | uniq
</code></pre>
</div>

<p>Sort it first, then call uniq. But there’s still a problem: it’s way too inefficient, beacuse it cat(s) all the files together FIRST, and then sorts it.</p>

<p>This is better:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sort words*.txt | uniq
</code></pre>
</div>

<p>Q: Is it possible to use the output onf one program as a <strong>parameter</strong> to another?</p>

<p>Yes. E.g.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo "Today is $(date) and I am $(whoami)"
</code></pre>
</div>

<p>The shell executes date and whoami, and subsitutes the results into the command line.</p>

<p>WARNING:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo 'Today is $(date) and I am $(whoami)'
</code></pre>
</div>

<p>This will print the <strong>LITERAL</strong> interpretation, i.e. Today is $(date) and I am $(whoami)<br />
Single quotes do not execute the substitution.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo "$(ls words*.txt)"
</code></pre>
</div>

<p>prints a list of names of the text files:<br />
words1.txt<br />
words2.txt<br />
…</p>

<p><strong>Pattern Matching in Text Files</strong><br />
Use egrep (extended global regular expression print) = grep -E</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep pattern file
</code></pre>
</div>

<p>returns all lines that contain the pattern.</p>

<p>E.g. print lines that contain “cs246”</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep cs246 index.html
</code></pre>
</div>

<p>What about “cs246” OR “CS246”?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep "cs246|CS246" index.html
</code></pre>
</div>

<p>The vertical bar (|) means “OR”, and the double quotes prevent the shell from interpreting the bar as a pipe.</p>

<p>We can use parentheses to group subexpressions together:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep "(cs|CS)246" index.html
</code></pre>
</div>

<p>The patterns that egrep understands are called <strong>regular expressions</strong>. NOT globbing patterns.</p>

<p>“(c|C)(s|S)246” is equivalent to “[cC][sS]246”</p>

<p><strong>[…]</strong> syntax says to match any SINGLE character in he square brackets. (a|1|c|2) is equivalent to [a1c2].</p>

<p><strong>[^…]</strong> matches any 1 character not in the square brackets.</p>

<p>“[cC][sS] ?246” allows for an optional space before the 246. ? syntax says to match 0 or 1 occurrences of the preceding expression.</p>

<p>* syntax which matches 0 or more of the preceding expression. So (cs)*246 -&gt; 246, cs246, cscs246, cscscs246…<br />
cs(cs)*246 matches at least one cs at the front (eliminating the zero case)</p>

<p>(cs)+246 is equivalent to cs(cs)*246. The + syntax matches 1 or more of the preceding expression.</p>

<p>.* will match any sequence of characters</p>

<p>.+ will match any non-empty sequence of characters</p>

<p>“cs *246” matches any string starting with cs, followed by any string, followed by 246.</p>

<p>^ matches beginning of line</p>

<p>$ matches the end of line</p>

<p>^cs246 line starts with cs246</p>

<p>cs246$ line ends with cs246</p>

<p>Want all lines of even length</p>

<p>^(..)*$</p>

<h1 id="the-other-section">The Other Section</h1>

<p>Pipes allow us to hook the stdin of one program to the stdout of another. This is done using the pipe character | between commands</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cmd1 args1 | cmd2 args2
</code></pre>
</div>

<p><strong>Regex Rules</strong>:</p>

<ul>
  <li>Can use parentheses for a sub-pattern</li>
  <li>Can use square brackets to match any one character in the square brackets</li>
  <li>[^…] matches any one character EXCEPT those in the square brackets</li>
  <li>A ? after a pattern or character represents 0 or 1 of that pattern/character</li>
  <li>A * after a pattern/character represents 0 or more of that pattern/character</li>
  <li>A + “1 or more”</li>
  <li>. matches any SINGLE character</li>
  <li>^ and $ match the start and end of line respectively</li>
</ul>

<p>E.g.<br />
.* - anything<br />
.+ - non-empty string<br />
^.+$ - all non-empty lines<br />
^.*$ - all lines</p>

<p>^(..)*$ - grabs all lines with even number of characters</p>

<p><strong>Permissions</strong></p>

<ul>
  <li>ls -l gives the long form listing of the files in the current directory</li>
  <li>First 3 bits: Owner r-read w-write x-execute</li>
  <li>Middle 3 bits: Group</li>
  <li>Last 3 bits: Others</li>
  <li>r: ordinary files-&gt; can be read, directories-&gt; contents can be read, globbing workds, ls works</li>
  <li>w: ordinary files-&gt;can be modified, directories-&gt; contents can be modified, add/remove</li>
  <li>x: file’s contents can be executed as a program, directories-&gt;directories can be navigated (can cd into the directory)</li>
</ul>

<p><strong>Changing Permissions</strong></p>

<ul>
  <li>
    <p>to change permissions use chmod</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  chmod mode file
</code></pre>
    </div>
  </li>
  <li>mode is broken up to 3 parts - user, operator, and permissions</li>
  <li>user is either u (owner), g (group), o (other), or a (all)</li>
  <li>operator is either + (add), - (remove), = (set exactly)</li>
  <li>permissions are r, w, x</li>
</ul>

<p>E.g.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod o+r filename
</code></pre>
</div>

<p>gives other group read access to the file</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod o-r filename
</code></pre>
</div>

<p>is the reverse</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod a-r filename
</code></pre>
</div>

<p>then nobody can read it</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod u=rwx filename
</code></pre>
</div>

<p>then the owner can do anything with it.</p>

<p><strong>Shell Scripts</strong></p>

<p>A shell script is a file containing sequences of shell commands execueted as a program. For example if we wanted to print the date, current user, current dir.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash (this header tells the OS that this is a Bash script; allows the OS to interpret it the following as bash commands)</span>
date
whoami
<span class="nb">pwd</span>
</code></pre>
</div>

<p>.sh is the standard extension of a bash script, but you can put whatever you want. Don’t forget permissions. Needs to be executable. Use chmod to give it executation rights.</p>

<p><strong>Variables</strong></p>

<ul>
  <li>Variables can be assigned with single equals.</li>
  <li>x=1 (NO SPACES!!!)</li>
  <li>use echo &amp;{x} to grab the value of the variable x (parentheses run what’s inside it in a “subshell”) (curly braces are important: good practice)</li>
</ul>

<p><strong>Shell Script Example</strong></p>

<p>Write a script that takes in a string to check if it is BAD. A string that can be found in a dict is bad.
General format of conditional statements in bash:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>if [ cond ]; then // the square brackets cannot "touch" what's inside
...
elif [ cond ]; then
...
else
...
fi
</code></pre>
</div>

<p><strong>$?</strong> contains the return value of the last-run command.
<strong>$1</strong> retrieves the first parameter</p>

<p>Create a .sh script as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

egrep <span class="s2">"^</span><span class="nv">$1</span><span class="s2">$"</span> /usr/share/dict/words &gt; /dev/null  <span class="c"># /dev/null is where data goes to DIE</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -eq 0 <span class="o">]</span>; <span class="k">then</span> //-eq compares
<span class="nb">echo </span>Bad password
<span class="k">else
</span><span class="nb">echo </span>Maybe not the worst
<span class="k">fi</span>
</code></pre>
</div>

<p>And before you run it,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>chmod u+x goodpass.sh
</code></pre>
</div>

<p>In bash, the pound symbol (#) starts a comment.</p>

<p><br /></p>

<h2 id="may-10-2016---lecture-3">May 10, 2016 - Lecture 3</h2>

<p>Review:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep pattern file
</code></pre>
</div>

<p>prints all lines in file that contain a match to pattern</p>

<p><strong>Shell Scripts Review</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash  #"Shebang line"  </span>
date  
whoami  
<span class="nb">pwd</span>
</code></pre>
</div>

<p>To run the script in the current directory:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./myscript
</code></pre>
</div>

<p><strong>Variables</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>x=1 #NO SPACES  
echo $x #Use $ when fetching the value of a variable
# No $ when setting a var ($ = "fetch the value of")
# Good practice: ${x} - brace brackets, good style
# All vars contain strings, e.g. x is the STRING 1, not the number/int
</code></pre>
</div>

<p>E.g.<br />
    dir = ~/cs246
    echo ${dir}
    /u/bmlushma/cs246 # get the absolute path
    ls ${dir} # contents of cs246</p>

<p>There are some global variables:<br />
    env # environment variables
    echo ${PATH} # list of directories (where the shell looks for programs)</p>

<p>When you type a command, the shell searches the list in order for a matching program.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo * # prints all files in the current directory
echo "*" - suppresses globbing pattern
echo '*' - suppresses globbing pattern
echo "$PATH" # expands the quotes, $-expansion happens
echo '$PATH' # absolutely literally
</code></pre>
</div>

<p><strong>Special Variables for Scripts</strong><br />
    $1, $2, … # command-line arguments</p>

<p>E.g. check whether a word is in the dictionary</p>

<div class="highlighter-rouge"><pre class="highlight"><code>./isItAWord hello

#!/bin/bash

egrep "^$1$" /usr/share/dict/words # prints the word if found, prints nothing if not
</code></pre>
</div>

<p>E.g. a good password is not in the dictionary</p>

<div class="highlighter-rouge"><pre class="highlight"><code>egrep "^$1$"/usr/share/dict/words &gt; /dev/null # to black hole, suppress output
# we could store the out in a variable
x=$egrep ...
</code></pre>
</div>

<p>Note: every program returns a status code when finished: egrep returns 0 if found, 1 if not found (general convention in UNIX: 0 means success, non-0 means failure)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$? # status of the most recently executed command

if [ $? -eq 0]; then # the first square bracket is the name of a program, and what's inside the square brackets are its arguments
    echo Bad password
else
    echo Maybe a good password
fi
</code></pre>
</div>

<p>We want to verify that the user has inputted the correct number of arguments, and print a usage message if it’s wrong</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

usage<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"usage: </span><span class="nv">$0</span><span class="s2"> password"</span> <span class="c"># $0 is the name of the script/program as it was typed</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>-ne 1 <span class="o">]</span>; <span class="k">then</span> <span class="c"># $# is the number of arguments</span>
    usage
    <span class="nb">exit </span>1
<span class="k">fi

</span>egrep ... <span class="c"># as established above</span>
</code></pre>
</div>

<p>Now this is a good program that can also check if the input is valid.</p>

<p>The general structure of conditional statements is as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>if [ cond ]; then
    ...
elif [ cond ]; then
    ...
else
    ...
fi
</code></pre>
</div>

<p>Comparisons to other conditions: Check the Linux reference sheet</p>

<p><strong>Loops</strong></p>

<p>Loops: print the numbers from 1 to $1</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">x</span><span class="o">=</span>1
<span class="k">while</span> <span class="o">[</span> <span class="nv">$x</span> -le <span class="nv">$1</span> <span class="o">]</span>, <span class="k">do
    </span><span class="nb">echo</span> <span class="nv">$x</span>
    <span class="nv">x</span><span class="o">=</span><span class="k">$((</span>x+1<span class="k">))</span> <span class="c"># $(()) for arithmetic</span>
<span class="k">done</span>
</code></pre>
</div>

<p>Looping over a list, e.g. rename all .cpp to .cc</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="k">for </span>name <span class="k">in</span> <span class="se">\*</span>.cpp; <span class="k">do</span> <span class="c"># for ... in sets the variable to each word in the given list</span>
    mv <span class="k">${</span><span class="nv">name</span><span class="k">}</span> <span class="k">${</span><span class="nv">name</span><span class="p">%cpp</span><span class="k">}</span>cc <span class="c"># value of name, without trailing cpp</span>
<span class="k">done</span>
</code></pre>
</div>

<p>e.g. how many times does word $1 occur in the file $2?</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">x</span><span class="o">=</span>0
<span class="k">for </span>word <span class="k">in</span> <span class="k">$(</span>cat <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span><span class="k">)</span>; <span class="k">do</span> <span class="c">#good idea - enclose vars in double quotes, prevent bad input</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$word</span> <span class="o">==</span> <span class="nv">$1</span> <span class="o">]</span>; <span class="k">then</span> <span class="c">#String equality == instead of -eq</span>
        <span class="nv">x</span><span class="o">=</span><span class="k">$((</span>x+1<span class="k">))</span>
    <span class="k">fi
done
</span><span class="nb">echo</span> <span class="nv">$x</span>
</code></pre>
</div>

<p>e.g. Payday is the last Friday of the month. When is this month’s payday?</p>

<p>2 tasks here: compute date and fomat the answer</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cal | awk '{print $6}' | egrep "[0-9]" | tail -1
</code></pre>
</div>

<p><br /></p>

<h2 id="may-11-2016---tutorial-2">May 11, 2016 - Tutorial 2</h2>

<p>Want: stdout and stderr in the same file</p>

<p>printer » out 2&gt; out # works
  printer &gt; out 2» out #doesn’t work</p>

<p>#Alternatives
  printer &amp;&gt; out
  printer &gt; out 2&gt;&amp;1
  printer 2&gt;out 1&gt;&amp;2</p>

<p>Want: Give the top 10 most commonly used words</p>

<table>
  <tbody>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>head # problem</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>sort</td>
      <td>tail # works</td>
      <td> </td>
    </tr>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>sort -k1,1rn -k2,2</td>
      <td>head # sort takes in arguments -k as key; 1,1 = first character r = reverse order(descending) n = sort in numerical order, 2 break ties</td>
      <td> </td>
    </tr>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>sed ‘s_6<em>12</em>’</td>
      <td>sort</td>
      <td>tail # Use sed to replace 6s with 12s and then sort lexigraphically</td>
    </tr>
    <tr>
      <td>sort wordCollection</td>
      <td>uniq -c</td>
      <td>sed ‘s_6<em>12</em>’</td>
      <td>sort -k1,1nr -k2,2</td>
      <td>head</td>
    </tr>
  </tbody>
</table>

<p>egrep:</p>

<p>^ - match beginning of line<br />
$ - match end of a line<br />
^$, ^a$<br />
. - matches any single character<br />
? - matches preceeding pattern 0 or 1 times<br />
* - 0 or more<br />
+ - 1 or more</p>

<p>Note: abc* != (abc)*
ab, abccc, abcccccc, in comparison to abc, abcabc, abcabcabc</p>

<p><br /></p>

<h2 id="may-12-2016---lecture-4">May 12, 2016 - Lecture 4</h2>
<p>Recall: compute payday (last Friday of the month); report nicely</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

answer<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$1</span> -eq 31 <span class="o">]</span>; <span class="k">then</span> <span class="c"># inside a fn - $1, $2 etc are the args to the function</span>
    <span class="nb">echo</span> <span class="s2">"This month: the 31st"</span>
  <span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"This month: the </span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="s2">th"</span>
  <span class="k">fi</span>
<span class="o">}</span>

answer <span class="k">$(</span>cal | awk <span class="s1">'{print $6}'</span> | egrep <span class="s2">"[0-9]"</span> | tail -1<span class="k">)</span> <span class="c"># the whole thing after the dollar sign is ${1}</span>
</code></pre>
</div>

<p>Generalize to any month:</p>

<p>cal June 2016 # gives calendar for June 2016<br />
Want: let payday June 2016 gives June 2016’s payday</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

answer<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$2</span> <span class="o">]</span>; <span class="k">then
    </span><span class="nv">preamble</span><span class="o">=</span><span class="k">${</span><span class="nv">2</span><span class="k">}</span>
  <span class="k">else
    </span><span class="nv">preamble</span><span class="o">=</span><span class="s1">'This month'</span>
  <span class="k">fi

  if</span> <span class="o">[</span> <span class="nv">$1</span> -eq 31 <span class="o">]</span>; <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">preamble</span><span class="k">}</span><span class="s2">'s payday is on the 31st."</span>
  <span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">preamble</span><span class="k">}</span><span class="s2">'s payday is on the </span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="s2">th."</span>
  <span class="k">fi</span>
<span class="o">}</span>

answer <span class="k">$(</span>cal <span class="nv">$1</span> <span class="nv">$2</span> | awk <span class="s1">'{print $6}'</span> | egrep <span class="s2">"[0-9]"</span> | tail -1<span class="k">)</span> <span class="nv">$1</span> <span class="c"># if $1 and $2 are supplied, revert back to previous behaviour</span>
</code></pre>
</div>

<h2 id="software-engineering-testingsaka-qa-lmao">Software Engineering: Testings(aka QA lmao)</h2>

<ul>
  <li>essential part of program development</li>
  <li>ongoing, not just at the end
    <ul>
      <li>begins <strong>BEFORE</strong> coding</li>
      <li>test suites - expected behaviour</li>
    </ul>
  </li>
  <li>NOT debugging - cannot debug without first testing</li>
  <li>cannot guarantee correctness, can only prove wrongness</li>
  <li>ideally, developer + tester should be different people</li>
</ul>

<p><strong>Human Testing</strong> - Humans look over code, find flaws, code inspection, walkthroughs<br />
<strong>Machine Testing</strong> - Run the program on selected input, check against spec, can’t test everything - choose test cases carefully</p>

<p><strong>Black/White/Grey Box Testing</strong>: no/full/some knowledge of program implementation<br />
Start with black box, supplement with white box</p>

<ul>
  <li>various classes of input, e.g. numerical ranges, positive/negative</li>
  <li>Boundaries of valid ranges (edge cases)</li>
  <li>Multiple simulatenous boundaries (corner cases)</li>
  <li>Intuition/Experience (“Ayy I’ve seen programs like that before, better try blah lmao”)</li>
  <li>Extreme cases (e.g. integer overflow; how large can the integer get before it breaks)</li>
</ul>

<p>White box - executes all logical paths through the program</p>

<ul>
  <li>run through the true part and false branch of conditional statements</li>
  <li>every way you can go from start to finish should be tested</li>
  <li>make sure every function you write actually gets called</li>
</ul>

<p><strong>Performance Testing</strong> - Is the program fast enough?<br />
<strong>Regression Testing</strong></p>

<ul>
  <li>Make sure new changes to the program don’t break old tests</li>
  <li>test suites (ALWAYS ADD TESTS; NEVER SUBTRACT), testing scripts</li>
</ul>

<h2 id="module-2-c-ayy">Module 2: C++ (ayy)</h2>

<p>Hello World in C:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main() {
  printf("Hello World!\n");
  return 0;
}
</code></pre>
</div>

<p>Hello World in C++:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;iostream&gt;
using namespace std;

int main() {
  cout &lt;&lt; "Hello World" &lt;&lt; endl;
  return 0;
}
</code></pre>
</div>

<p>Notes:</p>

<ul>
  <li>main MUST return int in C++</li>
  <li>stdio.h, printf still available in C++</li>
  <li>preferred C++ I/O: header <iostream></iostream></li>
</ul>

<p>Output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>std::cout &lt;&lt; ___ &lt;&lt; ____ &lt;&lt; ____  
std::endl = end-of-line
</code></pre>
</div>

<p>Using namespace std lets you say cout and endl instead of std::cout and std::endl</p>

<p>Return statement - returns status code to the shell ($?). If left out, main returns 0</p>

<p><strong>Compiling C++ Programs</strong></p>

<p>On the school Linux environment:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    g++-5 -std=c++14 program.cc -o program
    (-o program is the name of the executable binary (if not specified: a.out))
    // OR
    g++14 program.cc -o program // if you have done A0 and made the alias
    // Run the program by
    ./program
</code></pre>
</div>

<p><strong>Input/Output</strong><br />
  3 IO streams: cout - for printing to stdout, cin - for reading from stdin, cerr - for writing to stderr</p>

<p>Operators: « “put to” - Output, » “get from” - input</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  cerr &lt;&lt; x // x flows to cerr
  cin &gt;&gt; x // input flows to x
  // The operator points in the direction of information flow
</code></pre>
</div>

<p>E.g. Add 2 numbers</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;iostream&gt;
using namespace std;

int main() {
  int x, y;
  cin &gt;&gt; x &gt;&gt; y; // cin ignores whitespace; gets two integers, ignoring whitespace
  cout &lt;&lt; x+y ;
}
</code></pre>
</div>

<p>If the input doesn’t contain an integer next - statement fails, value of the var is undefined</p>

<p>What if the input is exhaustive, before we get two ints? - Same as above</p>

<p>If the read failed: cin.fail() will be TRUE<br />
If we got an EOF: cin.fail() and cin.eof() will be both TRUE; cin.eof() not until the attempted read fails</p>

<p>E.g. Read all ints from stdin, echo one per line to stdout. Stop on bad input or EOF</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int main() {
  int i;
  while(true) {
    cin &gt;&gt; i;
    if (cin.fail()) break;
    cout &lt;&lt; i &lt;&lt; endl;
  }
}
</code></pre>
</div>

<p><br /></p>

<h2 id="may-17-2016---lecture-5">May 17, 2016 - Lecture 5</h2>

<p>E.g. Read all ints from stdin + echo, one per line, to stdout, stop on bad input of EOF</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int main() {
	int i;
	while (true) {
		cin &gt;&gt; i;
		if (cin.fail()) {
			break;
		}
		cout &lt;&lt; i &lt;&lt; endl;
	}
}
</code></pre>
</div>

<p>Recall: if read fails, cin.fail() will be true; if EOF: cin.fail() and cin.eof() both true, but not until the attepted read fails</p>

<p>Note: there is an implicit conversion from cin to bool, so cin can be used as a condition. The conversion is that it’s true if fail/bad/eof bits are clear, or false if fail/bad/eof set</p>

<p>E.g. v2.0</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cin</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// using cin as the condition, means the same thing as the other program
</span>			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Note: » is C’s right bitshift operator; a » b shifts a’s bits to the right by b spots</p>

<p>E.g. 21 » 3; 21 in binary is 10101, push the last 3 digits off the cliff, so it becomes 10 in binary, which is 2; equivalent to dividing by 2 to the b-th power, ignoring remainders</p>

<p>But when the left hand side is cin, this is the “get from” operator</p>

<div class="highlighter-rouge"><pre class="highlight"><code>operator &gt;&gt;
 	// inputs: LHS cin (istream), RHS data (variety of types); output: return cin (istream)
 	// This is why we can write: cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; cin &gt;&gt; x produces cin, x gets populated, and now we get cin &gt;&gt; y &gt;&gt; z, and so on.
</code></pre>
</div>

<p>E.g. v3.0</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// using it as both a condition and populating i
</span>      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>E.g. v4.0</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// changing the break statement into a single while loop
</span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>E.g. read and echo ints until EOF, skip non-integer input</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">eof</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// clears the fail bit, so that cin is ready to read again
</span>      <span class="n">cin</span><span class="p">.</span><span class="n">ignore</span><span class="p">();</span> <span class="c1">// throws away the next character
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>E.g. Reading strings: type std::string (#include <string>)</string></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// skips leading white space;
// stops at whitespace (reads one word)
</span></code></pre>
</div>

<p>What if we want the hvitespace? Use getline(cin, s), it reads from the current position to next newline, into s.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">95</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 95
</span></code></pre>
</div>

<p>What if we want to print a number in hexadecimal?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="mi">95</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="c1">// this will print 95 in hex, 5f
// hex is std::hex, is the I/O manipulator, reconfigures the
// output string, all subsequent ints are printed in hex
// (FOR THE REST OF ETERNITY, nah jkjk till the program terminates); A bit of an overkill?
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span><span class="p">;</span> <span class="c1">// goes back to decimal
</span>
<span class="c1">// Other manipulator, SEE NOTES, don't forget #include &lt;iomanip&gt;
</span></code></pre>
</div>

<p>Stream abstraction applies to other fsources of data</p>

<p><strong>Files</strong> - Read from a file instead of stdin<br />
	std::ifstream reads from a file<br />
	std::ofstream writes to a file</p>

<p>File access in C:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"suite.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span> <span class="c1">// r = read mode; file is a handle
</span>	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fscanf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"%255s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">feof</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>File access in C++:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ifstream</span> <span class="n">file</span><span class="p">{</span><span class="s">"suite.txt"</span><span class="p">};</span> <span class="c1">// creating and initializing an ifstream opens the file
</span>	<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">file</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// IMPORTANT: the file is closed when the variable (in this case, file), goes out of scope; when the program stops, it's popped of the runtime stack, it then closes.
</span><span class="p">}</span>
</code></pre>
</div>

<p>Anything you can do do with cin and cout, you can do with an ifstream or an ofstream. ANYTHING.</p>

<p>E.g. string - attach a stream to a string and read/write it</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;sstream&gt;
</span><span class="c1">// std::istringstream and std::ostringstream
// read from/write to a string
</span>
<span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">...,</span> <span class="n">lo</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">ostringstream</span> <span class="n">ss</span><span class="p">;</span> <span class="c1">// think of it as a sock
</span><span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a # between"</span> <span class="o">&lt;&lt;</span> <span class="n">lo</span> <span class="o">&lt;&lt;</span> <span class="s">"and"</span> <span class="o">&lt;&lt;</span> <span class="n">hi</span><span class="p">;</span> <span class="c1">// stuffing the sock with string
</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> <span class="c1">// cuts open the sock and gets the string
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>

<p>E.g. convert a string to a #</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a number"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">istringstream</span> <span class="n">ss</span> <span class="p">{</span><span class="n">s</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// stop if you get int
</span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I said,"</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"You entered"</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>

<p>Example revisited - echo numbers, skip non-numbers</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">istringstream</span> <span class="n">ss</span> <span class="p">{</span><span class="n">s</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="strings">Strings</h2>

<p>In C, array of char (char* or char[]), terminated by IO. Must manage own memory: get morememory when strings grow; Easy to overwrite IO and corrupt program</p>

<p><strong>In C++, strings grow as needed, and are thus safer.</strong></p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">string</span> <span class="n">s</span><span class="p">{</span><span class="s">"Hello"</span><span class="p">};</span> <span class="c1">// it's still an array (C-style string);
// C++ string created from C string on initialization
</span></code></pre>
</div>

<p><strong>String Operations:</strong></p>

<ul>
  <li>Equality Inequality, s1 == s2, s1 != s2</li>
  <li>Comparison: s1 &lt;= s2 (lexicographical comparison)</li>
  <li>Length: s.length()</li>
  <li>Extract individual characters: s[0], s[1] etc.</li>
  <li>Concatenation: s3 = s1 + s2, s3 += s4</li>
  <li>More details: SEE NOTES</li>
</ul>

<p>Default Function Parameters</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printSuiteFile</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"suite.txt"</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// default value, must be last
</span>  <span class="p">...</span>
<span class="p">}</span>

<span class="n">printSuiteFile</span><span class="p">(</span><span class="s">"suite2.txt"</span><span class="p">);</span>
<span class="n">printSuiteFile</span><span class="p">();</span> <span class="c1">// prints from suite.txt
</span></code></pre>
</div>

<p>Note: optional params must be last; if you leave out two parameters, they have to be the last two; 3,3 etc.</p>

<p><br /></p>

<h2 id="may-18-2016---tutorial-2">May 18, 2016 - Tutorial 2</h2>

<h2 id="shell-scripting">Shell Scripting</h2>

<ul>
  <li>Exit codes are important; non-zero return/exit value = ERROR</li>
  <li>Write to the correct stream</li>
  <li>Scoping for subroutines, anything defined befored a subroutine is visible(and modifiable) in the subroutine, except positional arguments ($1, $2, …)</li>
</ul>

<h2 id="testing">Testing</h2>

<ul>
  <li>Don’t have to worry about invalid inputs</li>
  <li>Testing is hard</li>
  <li>Try sanity checks (“No one could make this mistake”)</li>
  <li>Good coverage: boundary/edge and corner cases, equivalence classes, weird cases</li>
</ul>

<p><strong>Possible Test Cases</strong></p>

<ul>
  <li>Equivalence courses: small, medium, and large values of the target</li>
  <li>Boundary/edge cases: test containing 0 as target</li>
</ul>

<h2 id="c-io">C++ I/O</h2>

<ul>
  <li>DO NOT USE C I/O</li>
  <li>3 default streams: cout, cerr, cin</li>
  <li>If a read from cin fails, <strong>all subsequent reads will fail</strong></li>
</ul>

<h2 id="make-io-more-robust">Make I/O More Robust</h2>

<ul>
  <li>Reading from cin could fail in two ways
    <ul>
      <li>EOF</li>
      <li>got unexpected input</li>
    </ul>
  </li>
  <li>When a read fails, a flag goes up in cin
    <ul>
      <li>cin.fail() will be true</li>
      <li>Only cin.fail() will be true if it was an error</li>
      <li>Both cin.fail() and cin.eof() will be true if it was EOF</li>
      <li>How to clear: cin.clear() -&gt; put all cin flags down and turn it into a valid state</li>
      <li>How to continue: cin.ignore(); order is important: clear then ignore</li>
    </ul>
  </li>
  <li>If you want the entire line, use getline(cin, s)</li>
</ul>

<h2 id="strings-1">Strings</h2>

<ul>
  <li>Encapsulates something like char* in C</li>
  <li>Has length, insert, delete, search methods</li>
  <li>Can be accessed like an array</li>
  <li>include<string></string></li>
  <li>at(index): checks for bounds and throws an exception if out of bounds</li>
  <li>[index]: does not check for bounds</li>
</ul>

<p><br /></p>

<h2 id="may-19-2016---lecture-6">May 19, 2016 - Lecture 6</h2>

<p><strong>Overloading</strong></p>

<p>C: Functions with different parameter lists cannot share the same name</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">negInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">n</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">negBool</span><span class="p">(</span><span class="n">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</code></pre>
</div>

<p>C++: Functions with different parameter lists can share the same name</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">neg</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">n</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">neg</span><span class="p">(</span><span class="n">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// example of overloading
</span></code></pre>
</div>

<p>Compiler uses number of types of arguments to decide which neg is being called.</p>

<p>Overloads must differ in number of type of arguments, not just on the return type. We’ve seen this before: », « (operators, could be right shift/left shift, or could be input and output; the behaviour depends on types of args)</p>

<p><strong>Structs</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// don't forget the semicolon
</span>
<span class="n">Node</span> <span class="n">n1</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">};</span> <span class="c1">// nullptr is the syntax for a null pointer in C++.
// Do not say NULL or 0 in this class!!!!!!!
// 0 will be always treated as a number, not pointer
</span>
<span class="k">const</span> <span class="n">Node</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span> <span class="c1">// constant struct means that its fields
// cannot be changed; n2 is an immutable copy of n1
</span></code></pre>
</div>

<p><strong>Parameter Passing</strong></p>

<p>Recall:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">inc</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 5; call-by-value
// inc gets a copy of x and modifies the copy, not the original
</span></code></pre>
</div>

<p>Sol’n: If a function needs to modify its arugument - pass a pointer</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x's address passed by value, inc changes value at that address, visible to caller
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 6
</span></code></pre>
</div>

<p>Question: Why cin » x and not cin » &amp;x?<br />
Answer: C++ has another pointer-like type: references</p>

<p><strong>References (IMPORTANT!!!)</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// NEW. Ampersand after int.
// z is an lvalue reference to int (which is y)
// Reference is like a constant pointer, similar to int *const z = &amp;y;
// (z is a constant pointer to an int; z will always point to y implied by const)
// (but y is not constant; you can change y however you like)
</span></code></pre>
</div>

<p>References are like constant pointers with automatic dereferencing.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">z</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// NOT *z = 12
</span><span class="kt">int</span> <span class="err">\</span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">;</span> <span class="c1">// &amp;z gives the address of y.
// No matter what you do to z, you do it y.
// In all cases, z behaves exactly like y. z is an alias for y.
</span></code></pre>
</div>

<p><strong>Things you CANNOT do with lvalue references</strong></p>

<ul>
  <li>leave them uninitialized, because they are constant, cannot assign later
    <ul>
      <li>must be initialized with something that actually has an address (an lvalue) since references are pointers</li>
      <li>E.g.</li>
    </ul>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// WRONG: WONT COMPILE!
// because 3 is not an address, it's a constant literal
</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// WRONG!
</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// GOOD
</span></code></pre>
    </div>
  </li>
  <li>create pointer to a reference: int &amp;* x; // WRONG
    <ul>
      <li>reference to a pointer is legal: int *&amp; x;</li>
    </ul>
  </li>
  <li>create a reference to a reference: int &amp;&amp; x = …; // means something different (will discuss later)</li>
  <li>create an array of references: int &amp;a[] = {x, x, x}; // given the similarity between arrays and pointers</li>
</ul>

<p><strong>Things you CAN do with lvalue references</strong></p>

<ul>
  <li>Pass as function parameters:</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// const pointer to the argument (x), thus changes to n affect x
</span>  <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// no pointer dereferencing
</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">inc</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 6
</span></code></pre>
</div>

<p>Why does cin » x work? It takes x by reference</p>

<p>istream &amp;operator » (istream &amp;in, int &amp;n);</p>

<p><strong>Pass-by-value</strong></p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// copies the argument
// if the argument is big, copying is expensive
</span>
<span class="k">struct</span> <span class="n">ReallyBig</span><span class="p">{};</span> <span class="c1">// Massive struct with thousands of fields
</span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="n">ReallyBig</span> <span class="n">rb</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// copying would be slow
</span>
<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="n">ReallyBig</span> <span class="o">&amp;</span><span class="n">rb</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// pass as reference, no copy, it's an alias, fast
// this could change rb in the caller, in contrast to pass by value, which guarantees
// no changes to rb itself after calling
</span>
<span class="kt">int</span> <span class="nf">h</span><span class="p">(</span><span class="k">const</span> <span class="n">ReallyBig</span> <span class="o">&amp;</span><span class="n">rb</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// pass constant reference, no copy, fast, and the parameter cannot be changed
</span></code></pre>
</div>

<p>Advice: prefer pass-by-const-reference over pass-by-value for anything larger than an int, unless the function needs to make a copy anyway - then maybe pass by value. DEFAULT SHOULD BE PASS-BY-CONST-REF. Sizeof reference is same as size of a pointer</p>

<p>Also:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>
<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>

<span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// LMAO FAILS WON'T COMPILE, because 5 does not have an address;
// can't initialize an lvalue reference (n) to a literal value;
// if n changes, can't change the literal 5
</span>
<span class="n">g</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// OK; since n can never be changed, the compiler will allow this
// How though? The compiler creates a temporary location to hold 5, so that n has something to point at
</span></code></pre>
</div>

<p>That’s why const ref is so CRITICALLY IMPORTANT.</p>

<p><strong>Dynamic Memory Allocation</strong></p>

<p>C:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="c1">// Don't use these in this course though
</span></code></pre>
</div>

<p>C++: new/delete</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span> <span class="c1">// allocates a Node on the heap and np points to it
// ...
</span><span class="k">delete</span> <span class="n">np</span><span class="p">;</span>
<span class="c1">// all local variables reside on the stack
// deallocated (popped) when their scope ends
// Allocated memory is on the heap, it stays there until you get rid of it
// Remains allocated until delete is called
</span></code></pre>
</div>

<p>If you don’t delete - MEMORY LEAK</p>

<p><strong>Arrays on the heap</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">*</span><span class="n">myArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">// ...
</span><span class="k">delete</span> <span class="p">[]</span> <span class="n">myArray</span><span class="p">;</span> <span class="c1">// The square brackets have to be there
</span></code></pre>
</div>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="nf">getMeANode</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// copy to caller's frame, expensive
</span>    <span class="n">Node</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="o">&amp;</span><span class="n">getMeANode</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// WORST. Returns a ref (essentially a pointer) to
</span>  <span class="c1">// stack-allocated data, which is dead on return
</span>    <span class="n">Node</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="o">*</span><span class="n">getMeANode</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// fast-ish and safe, not returning pointer to dead data
</span>  <span class="c1">// caller responsible for delete when done
</span>    <span class="n">Node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Considering all options, do No.1.</p>

<p><strong>Operator Overloading</strong><br />
Give our own meanings to C++ operators for types we create</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">v</span><span class="p">{</span><span class="n">v1</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">v2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">v2</span><span class="p">.</span><span class="n">y</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="may-24-2016---lecture-7">May 24, 2016 - Lecture 7</h2>

<h2 id="preprocessor-variables">Preprocessor Variables</h2>

<ul>
  <li>We can also define preprocessor symbols via the compiler; with gcc, syntax is -Dvname or -Dvname=val (-DX)</li>
  <li><strong>ifdef</strong> and <strong>ifndef</strong> directives: these check if a preprocessor variable has been defined (a use for simply defining variables); can be used to debug; #ifdef DEBUG to conditionally print stuff out to debug code; can offload run time to compile time
    <ul>
      <li>syntax:
  <code class="highlighter-rouge">
  g++14 -DDEBUG program.cpp // set DEBUG
 </code></li>
    </ul>
  </li>
</ul>

<h2 id="separate-compilation">Separate Compilation</h2>
<ul>
  <li>To help readability and create modularity we can split our programs into composable modules. Each module consist of <strong>interface</strong> (type definitions and prototypes for functions, .h file, contains declarations, won’t allocate space for the variables) and <strong>implementation</strong> (full details, allocates space for variables/functions, .cpp file, contains definitions)</li>
  <li>Example: Let’s take the vector struct and overloaded addition operator we created and put in a module so that it can be used by other files; create vec.h and vec.cpp</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// vec.h
</span><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v1</span>
              <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span> <span class="c1">// constant reference to vectors, do not modify the originals
</span>
<span class="c1">// ---------------------------------------
// vec.cpp
</span><span class="cp">#include "vec.h"
</span><span class="c1">// to get the struct definition from the interface file
</span>
<span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">v1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">y</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// main.cpp
</span><span class="cp">#include "vec.h"
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">x</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>
  <span class="n">Vec</span> <span class="n">y</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
  <span class="n">Vec</span> <span class="n">v</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<p>when compiling:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>g++14 -c vec.cpp // -c oppresses linking, creates .o (object) file
g++14 -c main.cpp
g++14 vec.o main.o -o main
./main
</code></pre>
</div>

<h2 id="global-variables">Global Variables</h2>

<ul>
  <li>Consider we want to want to define a global variable in a module</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// abc.h
</span><span class="kt">int</span> <span class="n">globalNum</span><span class="p">;</span> <span class="c1">// Wrong - definition and declaration
// This won't work, every file that includeds abc.h
// defines a SEPARATE globalNum and the program will not link
</span></code></pre>
</div>

<ul>
  <li>Solution: put the variable in the .cpp file</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// abc.h
</span><span class="k">extern</span> <span class="kt">int</span> <span class="n">globalNum</span><span class="p">;</span> <span class="c1">// Correct, just declaration
// extern keyword
// -------------------------
// abc.cpp
</span><span class="kt">int</span> <span class="n">globalNum</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="multiple-includes">Multiple Includes</h2>

<ul>
  <li>Always put #include guards in .h files (ifdef, define, endif)</li>
  <li>Never put using namespace std in .h files; DO NOT USE ANY NAMESPACES WHATSOEVER!</li>
</ul>

<h2 id="classes">Classes</h2>

<ul>
  <li>The big innovation of OOP - we can put functions inside of structs</li>
  <li>A class is some struct that can contain functions</li>
  <li>An object is an instance of a class</li>
  <li>Member functions (aka Methods) are functions inside a class</li>
  <li>this = pointer to the object a member function is called on; syntax: this-&gt;var; s.grade() is like calling grade(&amp;s)</li>
</ul>

<p><br /></p>

<h2 id="may-26-2016---lecture-8">May 26, 2016 - Lecture 8</h2>

<h2 id="classes-continued">Classes Continued</h2>
<p>Recall: student.cpp, implemented as struct<br />
This class:</p>

<h2 id="initializing-objects">Initializing Objects</h2>
<ul>
  <li>When creating an object typicaly the class will have data members that need to be assigned values - initialized</li>
  <li>As shown in the student example we could use curly braces to initialize our class, and in C++ this is true for most types - this is called <strong>Uniform Initialization</strong></li>
  <li>Ex. Student bob {60, 70, 80} in the student.cpp example</li>
</ul>

<h2 id="constructors">Constructors</h2>
<ul>
  <li>Without defining how your class should be constructed C++ just takes those values and assigns them to each field in the order they were declared - this is okay, but has limitations</li>
  <li>A better idea is to include in your class a method that does the initialization - called a <strong>constructor</strong></li>
  <li>
    <p>Ex. in the student.cpp example</p>

    <p>Student(int assns, int mt, int final) {
    // Debug statement here
    this-&gt;assns = assns;
    this-&gt;mt = mt;
    this-&gt;final = final;
  }
  // default value given
  Student(int assns=0, int mt=0, int final=0) {
      // …
  }</p>
  </li>
</ul>

<h2 id="notes-on-initialization">Notes on Initialization</h2>
<ul>
  <li>
    <p>Sometimes variables are initialized with the assignment operator</p>

    <p>int x = 5;
  string s = “hello”;</p>
  </li>
  <li>
    <p>And sometimes with (), especially when invoking Constructors</p>

    <p>int x(5);
string s(“Hello”)
Student bob(60, 70, 80)</p>
  </li>
  <li>
    <p>An exception to this: std::vector</p>

    <p>std::vector B{1,3,5} // contains elements 1,3,5
std::vector V(5) // of size 5
std::vector G{1} // actually contains element 1; curly brackets -&gt; element rather than size</p>
  </li>
  <li>
    <p>Also,</p>

    <p>int x = 2.0; // the decimal will get chopped off
int x {2.0} // COMPILER ERROR</p>
  </li>
  <li>
    <p>A class is a struct itself, an object is an actual variable of that type</p>
  </li>
</ul>

<h2 id="default-constructor">Default Constructor</h2>

<ul>
  <li>Every class comes with a default (zero-argument) constructor which calls: you can create an object but set its values later</li>
  <li>As soon as you declare your own constructor, you lose the default</li>
</ul>

<h3 id="section">#</h3>

<ul>
  <li>What about if our class contains a constant field or a reference field?</li>
  <li>For example let’s consider adding an ID field to our student class, this should be a const value that never changes but is different for each initialized student object</li>
  <li>Where to initialize them though? Struct definition (i.e. create an ID field in the struct; const int id = 0;)? In the body of the constructor?</li>
  <li>Problem: const int should be initialized</li>
  <li>Solution:</li>
</ul>

<h2 id="object-creation-steps">Object Creation Steps</h2>
<ul>
  <li>Space is allocated</li>
  <li>Fields are constructed</li>
  <li>Constructor body runs</li>
  <li>The moddile step is the missing piece of the puzzle where our initialization must go!</li>
</ul>

<h2 id="mil">MIL</h2>
<ul>
  <li>The member initialization list is part of our constructor that specifies how to initialize object and non-static data members of our class</li>
  <li>Can be used for any non-static memebers</li>
  <li>Initialized in order of declaration in struct</li>
  <li>Is more efficient, when the constructor is doing the same thing as the MIL, when there is a class inside a class (school class in student class)</li>
  <li>
    <p>Ex.</p>

    <p>Student(): assns{assns}, mt{mt}, final{final}, id{id} {</p>

    <p>}</p>
  </li>
</ul>

<h2 id="copy-constructor">Copy Constructor</h2>
<ul>
  <li>What happens when you use the assignment opeartor to instantiate an object?</li>
  <li>Ex.</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Student</span> <span class="n">a</span> <span class="p">{</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">80</span><span class="p">}</span>
<span class="n">Student</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre>
</div>

<ul>
  <li>b will be initialized via the copy constructor</li>
  <li>All classes have an implicit copy constructor that just copies all regular data fields and calls copy constructors on all object fields</li>
  <li>Ex.</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include "Node.h"
</span><span class="n">Node</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// recursively copies the nodes
</span></code></pre>
</div>

<h2 id="implicit-methods">Implicit Methods</h2>
<ul>
  <li>Every class comes with
    <ul>
      <li>A default constructor</li>
      <li>A copy constructor (just copies all fields)</li>
      <li>A copy assignment operator</li>
      <li>A destructor</li>
      <li>A move constructor</li>
      <li>A move assignmenet operator</li>
    </ul>
  </li>
</ul>

<h2 id="notes-on-copy-constructor">Notes on Copy Constructor</h2>
<ul>
  <li>The copy constructor (implicit or otherwise) is called when
    <ul>
      <li>An object is initialized by another object</li>
      <li>When an object is passed by value</li>
      <li>When an object is returned by a function</li>
    </ul>
  </li>
</ul>

<h2 id="implicit-conversion">Implicit conversion</h2>
<ul>
  <li>Be careful with a constructor that takes only one parameter - this will create an implicit conversion</li>
</ul>

<h2 id="destructor">Destructor</h2>
<ul>
  <li>Necessary if your class has any memory allocated on the heap</li>
</ul>

<p><br /></p>

<h2 id="may-31-2016---lecture-9">May 31, 2016 - Lecture 9</h2>

<h2 id="recall">Recall</h2>

<ul>
  <li>Copy constructor</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}}};</span>
<span class="n">Node</span> <span class="n">m</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="c1">// copy ctor
</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="o">*</span><span class="n">n</span><span class="p">};</span> <span class="c1">// copy ctor
</span></code></pre>
</div>

<ul>
  <li>Simple copy of fields -&gt; only the first node actually copied (shallow copy)</li>
  <li>If you want a deep copy (copy the whole list), must write your own copy constructor</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
	<span class="c1">// ...
</span>	<span class="n">Node</span> <span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">data</span> <span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">},</span>
    <span class="n">next</span> <span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="o">?</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">};</span>
    <span class="c1">// recursively copies the rest of the list
</span><span class="p">};</span>
</code></pre>
</div>

<p>The copy constructor is called:</p>

<ol>
  <li>When an object is initialized with another object (same class)</li>
  <li>When an object is passed by value</li>
  <li>When an object is return ed by a function</li>
</ol>

<p>There are exceptions to all 3.</p>

<p>Note: Careful with chars that can take ONE argument</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span> <span class="p">{</span><span class="n">d</span><span class="p">},</span> <span class="n">next</span> <span class="p">{</span><span class="n">nullptr</span><span class="p">}</span> <span class="p">{}</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="c1">//Single-argument ctors create implicit conversions
</span>
<span class="n">Node</span> <span class="n">n</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">Node</span> <span class="n">n</span><span class="p">{</span><span class="mi">4</span><span class="p">};</span>
<span class="c1">// but also
</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">// You can also do this now
</span><span class="kt">int</span> <span class="nf">f</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>
<span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="c1">// You can do this because 4 is implicitly converted to Node
// How converting C string to C++ string makes sense; generally not a good idea though
</span></code></pre>
</div>

<p>Danger: accidentally pass an int to a function expecting a Node
  + Compiler does not signal an error
  + Potential errors not caught</p>

<p>Good idea: disable the implicit conversion</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">explicit</span> <span class="n">Node</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span> <span class="p">{</span><span class="n">d</span><span class="p">},</span> <span class="n">next</span> <span class="p">{</span><span class="n">nullptr</span><span class="p">}</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// Now these are still fine
</span><span class="n">Node</span> <span class="n">n</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">Node</span> <span class="n">n</span><span class="p">{</span><span class="mi">4</span><span class="p">};</span>
<span class="c1">// But these are not
</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">f</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>
<span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="destructors">Destructors</h2>

<p>When an obect is destroyed a method called the destructor runs
  + Stack-allocated: goes out of scope
  + Heap-allocated: is deleted</p>

<p><strong>Specifically</strong>:</p>

<ol>
  <li>The destructor body runs</li>
  <li>Destructor is called on all the fields (called in reverse declaration order; if declared from top to bottom, then destroyed from bottom to top)</li>
  <li>Space is deallocated</li>
</ol>

<p>Class comes with a destructor (just calls destructors for all fields that are objects)</p>

<p>When do we need to write one?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}}};</span>
</code></pre>
</div>

<p>If np goes out of scope, the pointer is reclaimed (it was on the stack), the memory is leaked.</p>

<p>If we say delete np; it calls *np’s destructor, which doesn’t do anything (it only frees the very first node (1), 2, 3 are leaked)</p>

<p>Write a destructor to ensure the whole list is freed:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// tilda has the connotation of negation; NOT; opposite of constructor
</span>
    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// recursively calls
</span>    <span class="c1">// *next's destructor, thus the whole list is deallocated*
</span>    <span class="c1">// do not need to check nullptr
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="copy-assignment-operator">Copy Assignment Operator</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Student</span> <span class="n">billy</span> <span class="p">{</span><span class="mi">60</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">80</span><span class="p">};</span>
<span class="n">Student</span> <span class="n">jane</span> <span class="p">{</span><span class="n">billy</span><span class="p">};</span> <span class="c1">// copy constructor
</span><span class="n">Student</span> <span class="n">joey</span><span class="p">;</span> <span class="c1">// default constructor
</span><span class="n">joey</span> <span class="o">=</span> <span class="n">billy</span><span class="p">;</span> <span class="c1">// copy, but not construction
// Above is copy assignment operator, uses compiler-supplied default
</span></code></pre>
</div>

<p>You need to write your own copy assignmennt operator when there is heap-allocated memory</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// returns Node &amp; so that cascading works
</span>    <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="c1">// next = other.next would be wrong (shallow copy)
</span>    <span class="c1">// because that's what the default one does
</span>    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// otherwise it leaks, because the old object could point to real data
</span>    <span class="c1">// in order to replace the old data, need to delete old data
</span>    <span class="n">next</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="o">?</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="c1">// DANGEROUS STILL //*
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Very dangerous.<br />
Why?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="n">n</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}}};</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// deletes n, then tries to copy n to n, UNDEFINED BEHAVIOUR
</span>
<span class="c1">// For example:
</span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span> <span class="c1">// where p and q points to the same address
</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</code></pre>
</div>

<p>When writing operator=, ALWAYS watch for self-assignment</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c1">//*
</span>  <span class="p">}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="o">?</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">;</span> <span class="c1">//*
</span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Better:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">next</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span> <span class="o">?</span> <span class="p">{</span><span class="k">new</span> <span class="n">Node</span><span class="p">{</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">};</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
  <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Above works even if other is in my list, if new fails, Node will still be ain a valid state</p>

<h2 id="alternative---idiom">Alternative - idiom</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;utility&gt;
</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span> <span class="c1">// copy other
</span>    <span class="n">swap</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span> <span class="c1">// swap with my old data
</span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="c1">// tmp deallocated, frees my old data
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Rvalues + Rvalue references</p>

<p>Recall: an levalue is anything an address, an lvalue reference (&amp;) is always initialized by an lvalue</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="n">n</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}};</span>
<span class="n">Node</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// copy ctor
</span><span class="n">Node</span> <span class="n">m2</span><span class="p">;</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// copy assignment operator
</span>
<span class="n">Node</span> <span class="nf">plusOne</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">plusOne</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// What runs? What is other here?
// Compiler creates a temporary object to hold the result of plusOne, so other has something to point at
// copy ctor deep copies data drom the temp object
</span></code></pre>
</div>

<p><br /></p>

<h2 id="june-2-2016---lecture-10">June 2, 2016 - Lecture 10</h2>

<ul>
  <li>Need to be able to tell whether other is a reference to a temporary object or a standalone object</li>
  <li>C++: rvalue reference Node&amp;&amp; is a reference be a temporary object (aka rvalue) of type Node</li>
  <li>Version of the ctor that takes a Node&amp;&amp;</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="n">Node</span><span class="p">(</span><span class="n">Node</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// ... called a move ctor
</span><span class="p">}</span>
</code></pre>
</div>

<p>What should it do? Steal other’s data.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">...</span>
<span class="n">Node</span> <span class="p">(</span><span class="n">Node</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span><span class="o">:</span>
    <span class="n">data</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">},</span>
    <span class="n">next</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">}</span> <span class="p">{</span> <span class="c1">// steal data
</span>        <span class="n">other</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="c1">// other will be destroyed, so point to null so that the Nodes it points to won't get destroyed
</span>    <span class="p">}</span>
</code></pre>
</div>

<p>Similarly:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="n">m</span><span class="p">;</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">addOne</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// Assignment from temporary
</span></code></pre>
</div>

<p>More assignment operator:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Node</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// steal other's data
</span>    <span class="c1">// destroy my old data
</span>    <span class="c1">// so we can just swap without copy
</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

    <span class="c1">// temp object will be destroyed and take our old data with it
</span><span class="p">}</span>
</code></pre>
</div>

<p>If you don’t define move ctor/move assignment operator, copy versions will be used.<br />
If the move ctor/move assignment operator is defined, it will replace calls to the copy ctor/copy assignment operator where the argument is a temporary (an rvalue).</p>

<h2 id="copymove-elision">Copy/Move Elision</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Vec</span> <span class="nf">makeAVec</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// invokes basic ctor
</span><span class="p">}</span>

<span class="n">Vec</span> <span class="n">v</span> <span class="o">=</span> <span class="n">makeAvec</span><span class="p">();</span> <span class="c1">// what operations run here? copy ctor? move ctor?
// Not sure, in g++: just the basic ctor, no cpy ctor, no move ctor
</span></code></pre>
</div>

<p>In some circumstances, the compiler is allowed to skip calling copy/move ctors (but doesn’t have to). In the example above, makeAVec writes its result ({0,0}) directly into the space occupied by v in the caller, rather than copy it later</p>

<p>Example:
```c++
void doSomething(Vec v) { // pass-by-value copy ctor</p>

<p>}</p>

<p>doSomething(makeAVec());
```</p>

<ul>
  <li>result of makeAVec() written directly into the parameter - no copy</li>
  <li>This is allowed, even if dropping ctor calls would change the behaviour of the program (e.g. if the ctors print something)</li>
  <li>In this course, you are not expect edt oknow the eact circumstances under which copy/move elision is allowed</li>
</ul>

<p>If you need all of the ctors to run:
<code class="highlighter-rouge">
g++14 -fno-elide-constructors
</code>
But this can slow down your program considerably.</p>

<p>In summary: <strong>Rule of 5 (Big 5)</strong></p>

<p>If you need a custom version of any one of:
    1. copy ctor
    2. copy assignment operator
    3. destructor
    4. move ctor
    5. move assignment operator
Then you usually need a custom version of all 5. Because the circumstances you need to create one of them, will probably mean that these also apply to the other 4.</p>

<p>Notice: operator= is a member function, not a standalone function. When an operator is a member, “this” plays the role of the LHS argument.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="c1">// ...
</span>    <span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="o">+</span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">};</span>
    <span class="p">}</span>
    <span class="n">Vec</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="n">y</span><span class="p">};</span> <span class="c1">// implements v*k
</span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>How do we do k*v? Can’t be a member-first arg not vec. Must be a non-member (as before)</p>

<p>I/O operators:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="err">''</span> <span class="o">&lt;&lt;</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>What’s wrong? It makes Vec the LHS and ostream the RHS. Use as v « cout</p>

<p>So define «, » as standalone functions.</p>

<p>Certain operators must be members:</p>

<ul>
  <li>operator=</li>
  <li>operator[]</li>
  <li>operator()</li>
  <li>operator-&gt;</li>
  <li>operatorT (where T is a type)</li>
</ul>

<h2 id="arrays-of-objects">Arrays of Objects</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">Vec</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
    <span class="n">x</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">y</span><span class="p">}</span>
    <span class="p">{</span>

    <span class="p">}</span>
<span class="p">};</span>

<span class="n">Vec</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// ERROR
</span><span class="n">Vec</span> <span class="n">moreVectors</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span> <span class="c1">// ERROR
</span></code></pre>
</div>

<p>These want to call the default ctor on each item, but there isn’t one. Thus cannot initialize.</p>

<p><strong>Options:</strong></p>

<ol>
  <li>Provide a default ctor</li>
  <li>For stack arrays:</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Vec</span> <span class="n">moreVecs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{...};</span>
</code></pre>
</div>

<ol>
  <li>For heap arrays, create an array of pointers</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Vec</span> <span class="o">**</span><span class="n">vp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec</span><span class="o">*</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">vp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="n">vp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// etc...
// then delete
</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">vp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">delete</span> <span class="p">[]</span> <span class="n">vp</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="separate-compilation-for-classes">Separate Compilation for Classes</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Node.h
</span>
<span class="cp">#ifndef _NODE_H_
#define _NODE_H_
</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="o">=</span><span class="n">nullptr</span><span class="p">);</span>
    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif
</span>
<span class="c1">// Node.cc
</span>
<span class="cp">#include "Node.h"
</span>
<span class="c1">// Prefix with Node::
// Double colon :: = scope resolution operator
</span>
<span class="n">Node</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span><span class="p">{</span><span class="n">data</span><span class="p">},</span> <span class="n">next</span><span class="p">{</span><span class="n">next</span><span class="p">}</span> <span class="p">{}</span>
<span class="n">Node</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">},</span> <span class="n">next</span><span class="p">{}</span> <span class="p">{}</span>

<span class="c1">// Node::___ means ____ in the context of struct Node
// :: is like . for classes
// . where LHS is a class (or namespace), not an object
</span>
</code></pre>
</div>

<h2 id="const-objects">Const Objects</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{...}</span>    
</code></pre>
</div>

<p>Const objects arise often, especially in params.<br />
What is a const object? - Fields cannot change.</p>

<p>Can we call methods on a const object?<br />
Issue: method might change fields (violate const)</p>

<p>A: Yes. We can call methods that promise not to mofidy fields</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">assns</span><span class="p">,</span> <span class="n">mt</span><span class="p">,</span> <span class="n">final</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">grade</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// doesn't modify fields, so declare it const
</span><span class="p">}</span>
</code></pre>
</div>

<p>Compiler checks that const methods don’t modify fields. Only const methods can be called on const objects.</p>

<p>Now consider: Want to collect usage stats on Student obj</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span>  <span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="kt">int</span> <span class="n">numMethodCalls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="nf">grade</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// now can't call on const Students
</span>        <span class="o">++</span><span class="n">numMethodCalls</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>But mutating numMethod calls affect only the <strong>physical constness</strong> of the object (actual bit pattern), not its <strong>logical constness</strong> (whether it acts like a constant).</p>

<p>Want to update numMethodCalls, even if the object is const.
Solution: Declare the field mutable</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="k">mutable</span> <span class="kt">int</span> <span class="n">numMethodCalls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// can be changed, even if the object is const
</span>
    <span class="kt">float</span> <span class="nf">grade</span> <span class="p">()</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">numMethodCalls</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="june-7-2016---lecture-11">June 7, 2016 - Lecture 11</h2>

<h2 id="static-fields-and-methods">Static Fields and Methods</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
  <span class="k">mutable</span> <span class="kt">int</span> <span class="n">nCalls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">grade</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">nCalls</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// blah blah blah
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>nCalls tracks the number of times a method was called on a <strong>particular object</strong>. What if we want the number of calls over all Student objects? Or what if we want to know how many Students were created?</p>

<h3 id="static-members">Static Members</h3>

<ul>
  <li>Associated with the class itself, NOT any particular object</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">static</span> <span class="kt">int</span> <span class="n">numInstances</span><span class="p">;</span>
  <span class="n">Student</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">numInstances</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// in .cc file
</span><span class="kt">int</span> <span class="n">Student</span><span class="o">::</span><span class="n">numInstances</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>NOTE</strong>: Static fields MUST be defined external to the class</p>

<h3 id="static-member-functions">Static Member Functions</h3>

<ul>
  <li>Don’t depend on any particular instance (no “this” parameter) (not methods)</li>
  <li>Can only access static fields and call other static member functions</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">static</span> <span class="kt">int</span> <span class="n">numInstances</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">printNumInstances</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">numInstances</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// main
</span><span class="n">Student</span> <span class="n">billy</span> <span class="p">{};</span>
<span class="n">Student</span> <span class="n">jane</span> <span class="p">{};</span>
<span class="n">Student</span><span class="o">::</span><span class="n">printNumInstances</span><span class="p">();</span> <span class="c1">// prints 2
</span></code></pre>
</div>

<h2 id="invariants-and-encapsulation">Invariants and Encapsulation</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// main
</span>
<span class="n">Node</span> <span class="n">n1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Node</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">}};</span>
<span class="n">Node</span> <span class="n">n2</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">};</span>
<span class="n">Node</span> <span class="n">n3</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n2</span><span class="p">};</span>
</code></pre>
</div>

<p>What happens when these go out of scope? n3’s destructor tries to delete &amp;n2, which is on the stack, not on the heap! Thus, UNDEFINED BEHAVIOUR!</p>

<p>Class Node relies on an assumption, called an <strong>invariant</strong>, a statement that shold always be true. In this case, the invariant is that next is either:</p>

<ul>
  <li>a nullptr, or</li>
  <li>a valid pointer to the heap</li>
</ul>

<p>But we cannot guarantee this invariant. Because we cannot control the user, we cannot guarantee any invariant because the user can interfere. For example, in a stack implementation, the invaraint is: last item pushed is the first item popped. If you cannot rely on variants, it would be hard to reason about programs</p>

<p>To solve: Encapsulation - we want clients to treat objects as “black boxes” (or capsules)</p>

<ul>
  <li>Implementation details are sealed away</li>
  <li>Can only interact via the provided methods</li>
  <li>Can create an abstraction, regain us control</li>
</ul>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec</span> <span class="p">{</span>
  <span class="n">Vec</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// by default, public
</span><span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// can only be accessed from inside Vec
</span><span class="nl">public:</span>
  <span class="n">vec</span> <span class="n">Operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span> <span class="c1">// anyone can access
</span><span class="p">};</span>
</code></pre>
</div>

<p>In general, we want fields to be private, and only methods should be public. Introducing class:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span> <span class="c1">// constructors etc are public
</span>  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// private by default now
</span><span class="nl">public:</span>
  <span class="n">Vec</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">Vec</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Only difference between struct and class: default visibility, otherwise completely identical</p>

<p>Now we fix the linked list class</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// list.h
</span>
<span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span><span class="p">;</span> <span class="c1">// private nested class
</span>  <span class="n">Node</span> <span class="o">*</span><span class="n">theList</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">addToFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ith</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
  <span class="o">~</span><span class="n">List</span><span class="p">();</span>
  <span class="c1">// ... etc etc
</span><span class="p">};</span>

<span class="c1">// list.cc
</span><span class="cp">#include "list.h"
</span><span class="k">struct</span> <span class="n">List</span><span class="o">::</span><span class="n">Node</span> <span class="p">{</span>
  <span class="c1">// nested class
</span>  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span> <span class="c1">// MIL
</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">List</span><span class="o">::</span><span class="n">addToFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">theList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theList</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">List</span><span class="o">::</span><span class="n">ith</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">theList</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">List</span><span class="o">::~</span><span class="n">List</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">delete</span> <span class="n">theList</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Only List can create/manipulate Node objects, thus we can guarantee the invariance that next is either a nullptr or a valid pointer to the heap. BUT, now we can’t traverse the entire list in linear time. Repeated calling ith(int i) to traverse the whole list -&gt; O(n<sup>2</sup>) time. On the other hand, we can’t expose the Nodes or we will lose encapsulation</p>

<h2 id="se-topic-design-patterns">SE Topic: Design Patterns</h2>

<ul>
  <li>Certain problems arise frequently</li>
  <li>Keep track of good solutions and use them in similiar situations</li>
  <li>Good Solutions Hall of Fame</li>
  <li>If you have a situation like this, then this technique may solve it</li>
</ul>

<p>In this case, we use the <strong>Iterator Pattern</strong>.</p>

<ul>
  <li>Create a class that manages access to nodes (abstraction of a pointer)</li>
  <li>Walk through the list without exposing the next pointers</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span><span class="p">;</span> <span class="c1">// nested inner class
</span>  <span class="n">Node</span> <span class="o">*</span><span class="n">theList</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">p</span><span class="p">{</span><span class="n">p</span><span class="p">}</span> <span class="p">{}</span>

    <span class="kt">int</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// reference because might want to modify data
</span>      <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Iterator</span> <span class="o">&amp;</span><span class="n">opeartor</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// standalone functions
</span>  <span class="n">Iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">theList</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ... other list functions follow
</span>
<span class="p">};</span>

<span class="c1">// client
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">List</span> <span class="n">l</span><span class="p">;</span>
  <span class="n">l</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">l</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">l</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">List</span><span class="o">::</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// prints 1 2 3
</span><span class="p">}</span>
</code></pre>
</div>

<p>Shortcut when writing the Iterator for loop: we can use automatic type deduction</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// auto gives x y's type
</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// "shortercut" - Range-based for loop
</span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">:</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Range-based for loop: available for all classes with:</p>

<ul>
  <li>Methods begin, end that produce Iterators</li>
  <li>Iterator must support !=, prefix ++, unary *</li>
</ul>

<p>If we want to modify list items(or save copying):</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">n</span> <span class="o">:</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// use reference
</span>  <span class="o">++</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="june-9-2016---lecture-12">June 9, 2016 - Lecture 12</h2>

<p>But List client can create Iterators directly by doing the following:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">List</span><span class="o">::</span><span class="n">Iterator</span><span class="p">{</span><span class="n">nullptr</span><span class="p">};</span>
</code></pre>
</div>

<p>This violates encapsulation as the client should be calling begin and end, which we provide.</p>

<p>We could preserve encapsulation by:</p>

<ul>
  <li>Making Iterator’s constructor private
    <ul>
      <li>Then client cannot call List::Iterator</li>
      <li>But then neither can List</li>
    </ul>
  </li>
  <li><strong>Solution</strong>: give list privileged access to Iterator -&gt; make it a <strong>friend</strong></li>
</ul>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="c1">// ... Iterator functions
</span>    <span class="c1">// friend
</span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">List</span><span class="p">;</span> <span class="c1">// List now has access to all members of Iterator
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Now, List can still create Iterators, but client can only create Iterators by calling begin and end.</p>

<p><strong>NOTE</strong>: Give your classes as few friends as possible, because it weakens encapsulation. Once again, we want to keep fields private.</p>

<p>What if you want to give clients access to fields? “Getters” and “Setters” methods</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">getX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setY</span><span class="p">(</span><span class="kt">int</span> <span class="n">newY</span><span class="p">)</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>What about operator «? It needs x and y, but it cannot be a member function</p>

<ul>
  <li>If getX, getY are defined, then we are ok</li>
  <li>But if you don’t want to provide getX and getY, make operator« a friend function that is standalone</li>
</ul>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// .h file
</span>
<span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// .cc file
</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="tools-topic-make">Tools Topic: Make</h2>

<p><strong>Separate Compilation</strong>: lectures/c++/tools/example1</p>

<div class="highlighter-rouge"><pre class="highlight"><code>g++14 -c list.cc
g++14 -c node.cc
g++14 -c iter.cc
g++14 -c main.cc
g++14 main.o iter.o node.o list.o -o myprogram
</code></pre>
</div>

<p>Why do we do this? So we don’t have to recompile files that haven’t changed.</p>

<p>But how do we keep track of what’s changed and what hasn’t? Let Linux help you with <strong>make</strong>. We can create a Makefile that says which files depend on which other files. Refer to /lectures/c++/tools/example1/Makefile</p>

<div class="highlighter-rouge"><pre class="highlight"><code>myprogram: main.o list.o node.o iter.o # (myprogram depends on these)
  g++-5 -std=c++14 main.o list.o node.o iter.o -o myprogram # (tab in the beginning)
</code></pre>
</div>

<p>Then from the command line:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>make # builds the whole project
# Now change iter.cc
make # recompiles iter.cc and then relinks myprogram
</code></pre>
</div>

<p>Command <strong>make</strong>: builds the first target (myprogram) in the Makefile. And what does myprogram depend on? main.o, list.o, node.o, iter.o. So make recursively builds these if necessary. Make uses a dependency graph.</p>

<p>For example, iter.cc changes, then iter.cc is now newer than iter.o (by checking the last modified date and time). Thus make rebuilds iter.o. Now iter.o is newer than myprogram, thus make rebuilds myprogram</p>

<p>Make can also build specific targets, for example make node.o</p>

<p>Common practice: put a target clean: at the bottom of the Makefile to remove all binaries</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">clean </span><span class="c">#</span><span class="nf"> (to avoid a file called clean if present)</span>
<span class="nl">clean</span><span class="o">:</span>
  <span class="err">rm</span> <span class="err">*.o</span> <span class="err">myprogram</span>
</code></pre>
</div>

<p>To do a full rebuild:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>make clean
make
</code></pre>
</div>

<p>Now we can generalize with variables. In the Makefile:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CXX = g++-5
CXXFLAGS = -std=c++14 -Wall # (turns on all warnings)
</code></pre>
</div>

<p>E.g.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iter.o: iter.cc iter.h
${CXX} ${CXXFLAGS} -c iter.cc
</code></pre>
</div>

<p>Shortcut: for any make of the form</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x.o: x.cc a.h b.h
</code></pre>
</div>

<p>We can leave out the build command and make would guess that the build command is ${CXX} ${CXXFLAGS}, so we can just write</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="o">-</span><span class="n">c</span> <span class="n">x</span><span class="p">.</span><span class="n">cc</span> <span class="o">-</span><span class="n">o</span> <span class="n">x</span><span class="p">.</span><span class="n">o</span>
</code></pre>
</div>

<p>Biggest problems:</p>

<ul>
  <li>Writing dependencies</li>
  <li>Maintaining them if they change</li>
</ul>

<p>Can get help from g++:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>g++14 -MMD -c iter.cc
</code></pre>
</div>

<p>This creates iter.o <strong>and</strong> iter.d, and iter.d contains:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iter.o: iter.cc list.h node.h
</code></pre>
</div>

<p>Now just include iter.d in the Makefile:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CXX = g++-5
CXXFLAGS = -std=c++14 -Wall -MMD
OBJECTS = main.o list.o iter.o node.o
DEPENDS = ${OBJECTS:.o=.d}
EXEC = myprogram

${EXEC}:${OBJECTS}
  ${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}

-include ${DEPENDS}
</code></pre>
</div>

<p>As the project expands, just add .o files to the Makefile</p>

<h2 id="system-modelling">System Modelling</h2>

<p>Building an object-oriented system involves identifying abstractions and formalizing the relationships among items. It helps to map out relationships. A popular standard is the Unified Modelling Language (UML). Modelling a class, write its name, fields (optional), and methods (optional), and use + to denote public and - to denote private</p>

<h3 id="relationship-composition">Relationship: Composition</h3>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Vec</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Basis</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// client
</span><span class="n">Basis</span> <span class="n">b</span><span class="p">;</span>
</code></pre>
</div>

<p>This will not compile because Basis cannot initialize v1, v2, because the default constructor for b calls default constructors for v1, v2, which do not exist.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Basis</span> <span class="p">{</span>
  <span class="n">Vec</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Basis</span><span class="p">()</span><span class="o">:</span> <span class="n">v1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">v2</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{}</span> <span class="c1">// default constructor, now it will compile
</span><span class="p">};</span>
</code></pre>
</div>

<p>Embedding one object (v1) into another (b), called <strong>composition</strong>. The relationship between Basis and Vec is called “owns-a”, as a Basis “owns a” two Vecs.</p>

<p>If A owns a B, then typically:</p>

<ul>
  <li>B has no identity outside of A</li>
  <li>If A is destroyed, then B is destroyed</li>
  <li>If A is copied, then B is copied (deep copy)</li>
</ul>

<p><br /></p>

<h2 id="june-14-2016---lecture-13">June 14, 2016 - Lecture 13</h2>

<p>A car owns 4 wheels</p>

<ul>
  <li>A wheel is a part of a car</li>
  <li>Destroy the car -&gt; Destroy the wheels</li>
  <li>Copy the car -&gt; Copy the wheels</li>
  <li><strong>Implementation: Composition of classes</strong></li>
  <li>UML: A -&gt; B  (filled arrow), means A owns some number of B’s, can annotate with multiplicities</li>
</ul>

<h3 id="relationship-aggregation">Relationship: Aggregation</h3>

<ul>
  <li>Compare parts in a car (“owns a”) vs. car parts in a catalogue</li>
  <li>A “has a” relationship (aggregation): the catalogue contains the partsm but the parts have an independent existence</li>
  <li>If “A has B”, then typically:
    <ul>
      <li>B has an existence apart from its association with A</li>
      <li>If A is destroyed, then B lives on</li>
      <li>If A is copied, B is not (shallow copy) - copies of A share the same B</li>
    </ul>
  </li>
  <li><strong>Implementation: Pointer fields</strong></li>
</ul>

<p>E.g. Parts in a catalogue, ducks in a pond; UML: Pond -&gt; Duck (hollow arrow)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Pond</span> <span class="p">{</span>
  <span class="n">Duck</span> <span class="o">*</span><span class="n">ducks</span><span class="p">[</span><span class="n">maxDucks</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
  <span class="n">Person</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="specializationgeneralization-inheritance">Specialization/Generalization (Inheritance)</h2>

<p>Suppose you want to track your collection of books</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">(...);</span> <span class="c1">// ctor
</span>  <span class="c1">// other functions
</span><span class="p">};</span>
</code></pre>
</div>

<p>For textbooks, we also want the <strong>topic</strong>:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Text</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">topic</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Text</span><span class="p">(...);</span> <span class="c1">// Text ctor
</span>  <span class="c1">// other functions
</span><span class="p">};</span>
</code></pre>
</div>

<p>For comic books, we want the <strong>hero</strong>:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comic</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">hero</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Comic</span><span class="p">(...);</span> <span class="c1">// Comic ctor
</span>  <span class="c1">// other functions
</span><span class="p">};</span>
</code></pre>
</div>

<p>This is okay, but it doesn’t capture relationships among Book, Text, and Comic. And how do we create an array (or other collection) with a mix of these?</p>

<p>We could:</p>

<ol>
  <li>Use a union - *BAD (subverts the type system)**</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">union</span> <span class="n">BookTypes</span><span class="p">{</span><span class="n">Book</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span> <span class="n">Test</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span> <span class="n">Comic</span> <span class="o">*</span><span class="n">c</span><span class="p">;};</span>
<span class="n">BookTypes</span> <span class="n">myBooks</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</code></pre>
</div>

<ol>
  <li>Array of void * <strong>BAD (pointer to anything)</strong></li>
</ol>

<p>Rather, observe that Text and Comic are kinds of Books - Books with extra features.</p>

<p>C++ - model with Inheritance</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Base class (superclass)
</span><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">(...);</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="c1">// derived classes (or subclasses)
</span><span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">topic</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Text</span><span class="p">(...);</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Comic</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">hero</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Comic</span><span class="p">(...);</span>
  <span class="c1">// ...
</span><span class="p">};</span>
</code></pre>
</div>

<p>Derived classes <strong>inherit</strong> fields and methods from the base class, so Text, Comic get title, author, numPages fields. Any method that can be invoked on Book can be called on Text and Comic.</p>

<p>Who can see these members?</p>

<ul>
  <li>title, author, numPages - private in Book; Text and Comic cannot see them, even subclasses can’t see them</li>
</ul>

<p>How do we initialize Text? Need title, author, numPages (these are needed to initialize the Book part) and topic (specific to Text)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">topic</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Text</span><span class="p">(</span><span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numPages</span><span class="p">,</span> <span class="n">string</span> <span class="n">topic</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">title</span><span class="p">{</span><span class="n">title</span><span class="p">},</span> <span class="n">author</span><span class="p">{</span><span class="n">author</span><span class="p">},</span> <span class="n">numPages</span><span class="p">{</span><span class="n">numPages</span><span class="p">},</span> <span class="n">topic</span><span class="p">{</span><span class="n">topic</span><span class="p">}</span> <span class="p">{}</span>
  <span class="c1">// WRONG!!!
</span><span class="p">};</span>
</code></pre>
</div>

<p>Wrong for 2 reasons:</p>

<ul>
  <li>title etc are not accessible to Text</li>
  <li>Once again, when an object is constructed:
    <ol>
      <li>space is allocated</li>
      <li>superclass part is constructed (NEW!)</li>
      <li>fields constructed</li>
      <li>constructor body runs</li>
    </ol>
  </li>
</ul>

<p>And in this case, superclass cannot be constructed because Book has no default constructor.</p>

<p><strong>Fix:</strong> invoke Book’s constructor in Text’s MIL</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">topic</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Text</span><span class="p">(</span><span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numPages</span><span class="p">,</span> <span class="n">string</span> <span class="n">topic</span><span class="p">)</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">{</span><span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="n">numPages</span><span class="p">},</span> <span class="n">topic</span><span class="p">{</span><span class="n">topic</span><span class="p">}</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre>
</div>

<p><strong>NOTE:</strong> If a superclass has no default constructor, subclass must invoke a superclass constructor in its MIL. Good reasons to keep superclass’s fields inaccessible to subclasses. If you want to give subclasses access to certain members, use <strong>protected</strong> access:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="k">protected</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span> <span class="c1">// accessible to Book and its subclasses
</span>  <span class="nl">public:</span>
    <span class="n">Book</span><span class="p">(...);</span>
    <span class="c1">// ...
</span><span class="p">};</span>

<span class="c1">// subclasses
</span><span class="k">class</span> <span class="nc">Text</span><span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="nl">public:</span>
    <span class="c1">// ...
</span>    <span class="kt">void</span> <span class="n">addAuthor</span><span class="p">(</span><span class="n">string</span> <span class="n">newAuthor</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">author</span> <span class="o">+=</span> <span class="n">newAuthor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Note: Not a good idea to give subclasses unlimited access to fields; <strong>Better</strong> - make fields private, but provide protected accessors</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="n">title</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">string</span> <span class="n">getTitle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">setAuthor</span><span class="p">(</span><span class="n">string</span> <span class="n">newAuthor</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">(...);</span> <span class="c1">// ctor
</span>  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Relationship among Book, Text, and Comic is called “is a”: A Text is a Book; A Comic is a Book. UML: Text-&gt;(hollow)Book&lt;-(hollow)Comic. Implement “is a” by public inheritance.</p>

<p>Now consider the method isItHeavy. When is a Book heavy?</p>

<ul>
  <li>For ordinary Books, &gt; 200 pages</li>
  <li>For Texts, &gt; 500 pages</li>
  <li>For Comics, &gt; 30 pages</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">numPages</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Text</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">numPages</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Comic</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">numPages</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// =====================
// client
</span><span class="n">Book</span> <span class="n">b</span> <span class="p">{</span><span class="s">"A small book"</span><span class="p">,</span> <span class="s">"1Q84"</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
<span class="n">Comic</span> <span class="n">c</span> <span class="p">{</span><span class="s">"A big comic"</span><span class="p">,</span> <span class="s">"Waterloo Memers"</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Mr Paninos"</span><span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// false, it's a small Book as 50 &lt; 200
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">isItHeavy</span><span class="p">;</span> <span class="c1">// true, it's a big comic as 40 &gt; 30
</span></code></pre>
</div>

<p>Since public inheritance means “is a”, we can do:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Comic</span><span class="p">{</span><span class="s">"A big comic"</span><span class="p">,</span> <span class="s">"Balkan Chevaps"</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"We Deliver"</span><span class="p">};</span>
</code></pre>
</div>

<p><strong>Question:</strong> Is b heavy? b.isItHeavy() returns true or false? Which isItHeavy() run, Book::isItHeavy or Comic::isItHeavy?</p>

<p><strong>Answer:</strong> No, it is not heavy. Book::isItHeavy is what runs. Why? Book contains 3 fields: title, author, numPages, while Comic contains 4 fields: title, author, numPages, and hero. Thus,</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Comic</span> <span class="p">{...};</span>
</code></pre>
</div>

<p>tries to create a Comic object when there’s only space for a Book. Comic is then <strong>sliced (“hero” field is chopped off)</strong>. Comic is coerced (forced) into a Book. Basically, Book b = Comic {…} converts a Comic into a Book and Book::isItHeavy runs.</p>

<p>When accessing objects through pointers, <strong>slicing is unnecessary and does not occur</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Comic</span> <span class="n">c</span> <span class="p">{</span><span class="s">"friend5ever"</span><span class="p">,</span> <span class="s">"Sedra Smith"</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"RealisticAFMStudent"</span><span class="p">};</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">Comic</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// true; 40 &gt; 30, heavy Comic
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// false, 40 &lt; 200, not heavy Book
// same behaviour as the slicing example, Book::isItHeavy runs as pointer is Book
</span></code></pre>
</div>

<p>Still, Book::isItHeavy runs when we access pb-&gt;isItHeavy(). Some objects behaves differently, depending on what type of pointer points to it.</p>

<p><br /></p>

<h2 id="june-16-2016---lecture-14">June 16, 2016 - Lecture 14</h2>

<p>Compiler uses the type of the pointer (or type of the reference) to decide which isItHeavy to run. It does not consider the actual type of the object. So a Comic is a Comic only if a comic pointer points to it. Pointer »&gt; Actual object.</p>

<p>Then, how do you make Comic act like a Comic, even when pointed at by a Book pointer? <strong>Solution: declare the method virtual</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="c1">// ... fields
</span><span class="nl">protected:</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Book</span><span class="p">(...);</span>
  <span class="k">virtual</span> <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// use of virtual here
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Comic</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="n">bool</span> <span class="n">isItHeavy</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// override keyword in virtual function
</span><span class="p">};</span>

<span class="c1">// =================
// client
</span><span class="n">Comic</span> <span class="n">c</span> <span class="p">{</span><span class="s">"RealisticMathStudent"</span><span class="p">,</span> <span class="s">"UWGo"</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Quest God"</span><span class="p">};</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">rb</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="n">Comic</span> <span class="o">&amp;</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">Book</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// true, Comic::isItHeavy
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rb</span><span class="p">.</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// true, Comic::isItHeavy
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// true, Comic::isItHeavy
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">isItHeavy</span><span class="p">();</span> <span class="c1">// FALSE, Book::isItHeavy
</span></code></pre>
</div>

<h3 id="virtual-and-polymorphism">Virtual and Polymorphism</h3>

<p><strong>Virtual Methods</strong>: chosen based on the actual types of the object at <strong>runtime</strong><br />
<strong>Dynamic Dispatch</strong>: the process of virtual methods being resolved to the correct one at runtime is known as dynamic dispatch. It is the process of chossing which method to call at runtime based on the type of a value. We use this by putting <strong>virtual</strong> in the superclass.</p>

<p>E.g. My book collection</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="o">*</span><span class="n">myBooks</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myBooks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">isItHeavy</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">// This uses Book::isItHeavy for Books, Text::isItHeavy for Texts
</span>  <span class="c1">// and Comic::isItHeavy for Comics
</span><span class="p">}</span>
</code></pre>
</div>

<p>It accommodates multiple types under one abstraction -&gt; <strong>Polymorphism</strong></p>

<p>Note: This is why a function</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
</code></pre>
</div>

<p>can be passed an ifstream, because ifstream is a subclass of istream.</p>

<p><strong>DANGER</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">One</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">One</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Two</span> <span class="o">:</span> <span class="k">public</span> <span class="n">One</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Two</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">One</span><span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">},</span> <span class="n">z</span><span class="p">{</span><span class="n">z</span><span class="p">}</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">One</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// ===============
// clientdas
</span><span class="n">Two</span> <span class="n">myArray</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}];</span>
<span class="n">f</span><span class="p">(</span><span class="n">myArray</span><span class="p">);</span>
</code></pre>
</div>

<p><strong>Data Misaligned</strong>: MyArray is originally [1 2 3][4, 5, 6]; after calling f, it becomes [6 7 8][9 5 6].</p>

<p>Note: NEVER use arrays of objects polymorphically. If you want polymorphism, use an array of pointers</p>

<h3 id="destructor-revisited">Destructor Revisited</h3>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]}</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Y</span> <span class="o">:</span> <span class="k">public</span> <span class="n">X</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Y</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">X</span><span class="p">{</span><span class="n">n</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">]}</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">Y</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// =================
// client
</span><span class="n">X</span> <span class="o">*</span><span class="n">myX</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Y</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
<span class="k">delete</span> <span class="n">myX</span><span class="p">;</span> <span class="c1">// LEAKS!
</span></code></pre>
</div>

<p><strong>Why?</strong> The last line calls ~X, not ~Y, so only x, but not y, is freed.<br />
To ensure that deletion through a superclass pointer calls the subclass destructor, <strong>declare the destructor virtual</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="k">virtual</span> <span class="o">~</span><span class="n">X</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
</div>

<p><strong>ALWAYS</strong> make the destructor virtual in classes that are meant to have subclasses, even if the virtual destructor does nothing. If a class is NOT meant to have subclassses, declare the destructor <strong>final</strong>.</p>

<h3 id="pure-virtual-methods-and-abstract-classes">Pure Virtual Methods and Abstract Classes</h3>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span> <span class="c1">// there are 2 kinds of Students, regular and co-op
</span><span class="nl">protected:</span>
  <span class="kt">int</span> <span class="n">numCourses</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// ...
</span>  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">fees</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Regular</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Student</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">fees</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// virtual - override
</span>  <span class="c1">// regular fees
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Coop</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Student</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">fees</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// virtual - override
</span>  <span class="c1">// coop fees
</span><span class="p">};</span>
</code></pre>
</div>

<p>What do we put for Student::fees? We don’t know, because every Student should be either regular or co-op.</p>

<p>We can explicitly given Student::fees <strong>NO implementation</strong> -&gt; <strong>pure virtual method</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">fees</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =0, NO IMPLEMENTATION
</span>  <span class="c1">// Called pure virtual method = no implementation
</span><span class="p">};</span>
</code></pre>
</div>

<p>A class with a <strong>pure virtual method cannot be instantiated</strong>, and the class is called an <strong>abstract class</strong>. Its purpose is to organize subclasses.</p>

<p>Subclasses of abstract classes are abstract as well, <strong>unless they implement ALL pure virtual methods.</strong> Non-abstract classes are called <strong>concrete classes</strong>.</p>

<p>UML: virtual and pure virtual methods: italics; abstract class: class name in italics; protected: #</p>

<h3 id="inheritance-and-copymove">Inheritance and Copy/Move</h3>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// Defines all copy/move operators here
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// DOES NOT define copy/move operators
</span><span class="p">};</span>

<span class="c1">// ===============
// client
</span><span class="n">Text</span> <span class="n">t</span> <span class="p">{</span><span class="s">"Algorithms"</span><span class="p">,</span> <span class="s">"CLRS"</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="s">"CS"</span><span class="p">};</span>
<span class="n">Text</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// No copy ctor in Text, what happens?
// calls Book's copy ctor,
// then goes field by field (i.e. default behaviour) for the Text part
// same for other opeartors
</span></code></pre>
</div>

<p>To write your own:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// copy ctor
</span><span class="n">Text</span><span class="o">::</span><span class="n">Text</span><span class="p">(</span><span class="k">const</span> <span class="n">Text</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">Book</span><span class="p">{</span><span class="n">other</span><span class="p">},</span> <span class="n">topic</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">}</span> <span class="p">{}</span>

<span class="c1">// copy assignment opor
</span><span class="n">Text</span> <span class="o">&amp;</span><span class="n">Text</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Text</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Book</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="c1">// superclass copy assignment
</span>  <span class="n">topic</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">;</span> <span class="c1">// assign field
</span>  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// move ctor
</span><span class="n">Text</span><span class="o">::</span><span class="n">Text</span><span class="p">(</span><span class="n">Text</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">Book</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">)},</span> <span class="n">topic</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">)}</span> <span class="p">{</span>

<span class="p">}</span>

<span class="c1">// move assignment opor
</span><span class="n">Text</span> <span class="o">&amp;</span><span class="n">Text</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Text</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Book</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">));</span>
  <span class="n">topic</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Note</strong>: Even though other “points” at an rvalue, other itself is an lvalue. std::move(x) forces lvalue x to be treated as an rvalue, so that move versions of operators can run</p>

<p><br /></p>

<h2 id="june-21-2016---lecture-15">June 21, 2016 - Lecture 15</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Text</span> <span class="n">t1</span><span class="p">{...};</span>
<span class="n">Text</span> <span class="n">t2</span><span class="p">{...};</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t1</span><span class="p">;</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">;</span>
</code></pre>
</div>

<p>What if we do</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="o">*</span><span class="n">pb1</span> <span class="o">=</span> <span class="o">*</span><span class="n">pb2</span><span class="p">;</span> <span class="c1">// ?
</span></code></pre>
</div>

<p>Then Book::operator= runs, <strong>partial assignment</strong> - copies only the Book part. How do we fix this? Try making operator= virtual.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="c1">// ...
</span>  <span class="k">virtual</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span> <span class="c1">// make the copy assignment opor virtual
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="n">Text</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// override - virtual in subclass
</span><span class="p">};</span>
</code></pre>
</div>

<p>Note: different return types, but parameter types must be the same or it’s not an override, and thus WILL NOT COMPILE.</p>

<p>Thus assignment of a Book object to a Text variable would be allowed.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Text</span> <span class="n">t</span> <span class="p">{...};</span>
<span class="n">Book</span> <span class="n">b</span> <span class="p">{...};</span>
<span class="n">Text</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span>
<span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="o">*</span><span class="n">pb</span><span class="p">;</span> <span class="c1">// uses a book to assign to a text, BAD
</span>
<span class="c1">// ALSO
</span><span class="n">Comic</span> <span class="n">c</span> <span class="p">{...};</span>
<span class="n">Comic</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span> <span class="c1">// BAD
</span></code></pre>
</div>

<p>If operator= is non-virtual -&gt; partial assignment through base class pointers -&gt; BAD<br />
If operator= is virtual -&gt; compiler allows mixed assignment -&gt; BAD</p>

<p>Recommendation: All superclasses should be <strong>abstract</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AbstractBook</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numPages</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">AbstractBook</span> <span class="o">&amp;</span><span class="n">opeartor</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">AbsratctBook</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span>
  <span class="c1">// prevents assignment through base class pointers from compiling
</span>  <span class="c1">// but implementation still available to subclasses
</span><span class="nl">public:</span>
  <span class="n">AbsratctBook</span><span class="p">(...);</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">AbsratctBook</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// "be abstract"
</span>  <span class="c1">// need at least one pure virtual method to make it abstract
</span>  <span class="c1">// if you don't have any, make dtor pure virtual
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">NormalBook</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractBook</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">NormalBook</span><span class="p">(...);</span>
  <span class="o">~</span><span class="n">NormalBook</span><span class="p">();</span>
  <span class="n">NormalBook</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NormalBook</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AbstractBook</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ============
// client
</span><span class="o">*</span><span class="n">pb1</span> <span class="o">=</span> <span class="o">*</span><span class="n">pb2</span><span class="p">;</span> <span class="c1">// DOES NOT COMPILE
</span></code></pre>
</div>

<p><strong>Prevents mixed &amp; partial assignment</strong>.<br />
Note: virtual destructor must always be implemented, even if it is pure virtual.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">AbsratctBook</span><span class="o">::~</span><span class="n">AbstractBook</span><span class="p">()</span> <span class="p">{}</span>
</code></pre>
</div>

<h2 id="templates">Templates</h2>

<p>Huge topic - just the highlights here</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">theList</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">List</span><span class="o">::</span><span class="n">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">};</span>
</code></pre>
</div>

<p><strong>Question:</strong> what if you want to store something else? Whole new class? Nah.</p>

<p><strong>Templates</strong>: class parameterized by a type</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Stack</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
  <span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="n">Stack</span><span class="p">(){...}</span>
<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">){...}</span>
<span class="n">T</span> <span class="n">top</span><span class="p">(){...}</span>
<span class="kt">void</span> <span class="n">pop</span><span class="p">(){...}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">theList</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="nf">Iterator</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">p</span><span class="p">{</span><span class="n">p</span><span class="p">}</span> <span class="p">{}</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...
</span>  <span class="p">};</span>

  <span class="n">T</span> <span class="nf">ith</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">addToFront</span><span class="p">(</span><span class="n">T</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ==================
// client
</span><span class="n">List</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l1</span><span class="p">;</span>
<span class="n">List</span> <span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">t2</span><span class="p">;</span>
<span class="n">t1</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">t2</span><span class="p">.</span><span class="n">addToFront</span><span class="p">(</span><span class="n">l1</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">l1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span>
</code></pre>
</div>

<p>Compiler specializes template at the source code level, before compilation begins. Refer to /string/istream/ostream templates.</p>

<h2 id="the-standard-template-library-stl">The Standard Template Library (STL)</h2>

<p>Large number of useful templates</p>

<p>E.g. dynamic length arrays: vectors</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span> <span class="c1">// vector&lt;int&gt; v(4,5) = {5,5,5,5};
</span><span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">// {4,5,6}
</span><span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// {4,5,6,7}
</span></code></pre>
</div>

<p>Looping over vectors:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OR
</span><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// To iterate in reverse
</span><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span>

<span class="c1">// To remove last element
</span><span class="n">v</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

<span class="c1">// Use iterators to remove items from inside the vector
</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="c1">// erase element 0
</span><span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// erase element 3
// returns an iterator to first item after the erase
</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="c1">// erase item pointed to by it
</span><span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// erase last item
</span>
<span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// i-th element of v; unchecked: out of bounds -&gt; undefined behaviour
</span><span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// checked version of v[i], what happens if i is out of bounds
</span></code></pre>
</div>

<p><strong>Question</strong>: What should happen?</p>

<p>Problem: Vector can detect the error, but doesn’t know whatto do about it</p>

<p>C Solution: function returns a status code, or set the global variable errno; encourages programmers to ignore error checks</p>

<p>C++ Solution: when an error condition occurs, the function raises an exception</p>

<p><br /></p>

<h2 id="june-23-2016---lecture-16">June 23, 2016 - Lecture 16</h2>

<h2 id="exceptions">Exceptions</h2>

<p>What happens? By default, execution stops. But we can write <strong>handler</strong> to <strong>catch</strong> exceptions and deal with them. vector <T>::at throws exception out_of_range.</T></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdexcept&gt;
</span><span class="c1">// ...
</span><span class="n">try</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// statements that may raise an exception
</span>  <span class="c1">// go in the try block
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">out_of_range</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"range error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre>
</div>

<p>Consider:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="n">out_of_range</span> <span class="p">{</span><span class="s">"f"</span><span class="p">};</span> <span class="c1">// raise an exception
</span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">h</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">g</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">h</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">out_of_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>What happens?</p>

<p>main calls h, h calls g, g calls f, f throws, g has no handler for out_of_range, control goes back through the call chain (unwinds the stack) until a handler is found. Control goes all the way back to main, main handles the exception.</p>

<p>If no one handles the exception, program terminates.</p>

<p>What is out_of_range? It’s a class.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">throw</span> <span class="n">out_of_range</span> <span class="p">{</span><span class="s">"f"</span><span class="p">};</span> <span class="c1">// invokes a ctor with arg "f" and throws it
// "f" is auxiliary information
</span></code></pre>
</div>

<p>To examine auxiliary information:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">out_of_range</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints "f"
</span><span class="p">}</span>
</code></pre>
</div>

<p>A handler might do part of the recovery job - execute some corrective code and raise another exception:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">someErrorType</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">throw</span> <span class="n">someOtherError</span><span class="p">(...);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Or throw the same exception:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">someErrorType</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The difference between throw and throw s. Throw is used when an actual type of s is retained (most cases), it rethrows the same exception object it caught; throw s: s may be a subtype of someErrorType, throw rethrows a new exception of type someErrorType.</p>

<p>A handler can act as a catch-all:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span> <span class="c1">// catches all exceptions
</span>  <span class="c1">// ...
</span><span class="p">}</span>
</code></pre>
</div>

<p>You can throw anything you want - doesn’t have to be objects</p>

<p>Define your own classes (or use appropriate existing ones) for errors. E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BadInput</span><span class="p">();</span>

<span class="n">try</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">BadInput</span><span class="p">{};</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">BadInput</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// catch by ref to prevent slicing
</span>  <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="c1">// ...
</span><span class="p">}</span>
</code></pre>
</div>

<p>Note:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BaseExn</span><span class="p">{};</span>
<span class="k">class</span> <span class="nc">DerivedExn</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseExn</span><span class="p">{};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DerivedExn</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">BaseExn</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// BaseExn type
</span>  <span class="k">throw</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">try</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="n">f</span><span class="p">();</span>
  <span class="c1">// ...
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">DerivedExn</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... DerivedExn handler
</span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">BaseExn</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... BaseExn handler
</span><span class="p">}</span>
</code></pre>
</div>

<p>Which handler runs? BaseExn handler runs, as the type of the reference (i.e. the static type of the object) determines the handler.</p>

<p>Some standard exceptions:</p>

<ul>
  <li>length_error - attempting to resize strings/vectors that are too long</li>
  <li>bad-alloc - new fails</li>
  <li>ios::failure - I/O streams fail; refer to lectures/c++/exceptions</li>
</ul>

<p><strong>NEVER NEVER NEVER let a destructor throw an exception</strong></p>

<ul>
  <li>If the dtor was executed during stack unwinding while dealing with another exception, you now have two active unhandled exceptions, and the program will terminate immediately</li>
</ul>

<h2 id="design-patterns-continued">Design Patterns (Continued)</h2>

<p><strong>Guiding Principle</strong>:</p>

<ul>
  <li>Program with interfaces not implementations</li>
  <li>Abstract base classes define the interface</li>
  <li>Work with pointers to an abstract base class and call their methods</li>
  <li>Concrete subclasses can be swapped in and out</li>
  <li>Abstracting over a variety of behaviours</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractIterator</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Set</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="k">class</span> <span class="nc">Iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractIterator</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AbstractIterator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">AbstractIterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(...)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractIterator</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Then you can write code that operates over iteartors:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foreach</span><span class="p">(</span><span class="n">AbstractIterator</span> <span class="n">start</span><span class="p">,</span> <span class="n">AbstractIterator</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">);</span> <span class="c1">// f must be a callible entity
</span>    <span class="o">++</span><span class="n">start</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// this works over both Lists and Sets
</span>
<span class="n">List</span> <span class="n">l</span><span class="p">;</span>
<span class="n">foreach</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">someFunction</span><span class="p">);</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="june-28-2016---lecture-17">June 28, 2016 - Lecture 17</h2>

<h2 id="observer-design-pattern">Observer Design Pattern</h2>

<p>aka <strong>publish-subscribe model</strong></p>

<p>Publisher/Subject - source of data, generates data; Subscribers/Observers - receive data and react to it.</p>

<p>Sequence of the model calls:</p>

<ol>
  <li>Subject’s state is updated()</li>
  <li>Subject::notifyObservers() -&gt; calls each observer’s notify();</li>
  <li>Each observer calls ConcreteSubject::getState() to react accordingly</li>
</ol>

<p>E.g. horse races; subject publishes winners, observers (individual betters) declare victory when their horse wins.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Subject</span> <span class="p">{</span>
  <span class="n">vector</span> <span class="o">&lt;</span><span class="n">Observers</span> <span class="o">*&gt;</span> <span class="n">observers</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">attach</span><span class="p">(</span><span class="n">Observer</span> <span class="o">*</span><span class="n">ob</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">observers</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">ob</span><span class="p">);</span> <span class="c1">// add to observers
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">detach</span><span class="p">(</span><span class="n">Observer</span> <span class="o">*</span><span class="n">ob</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// remove
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">notifyObservers</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">ob</span><span class="p">;</span> <span class="n">observers</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ob</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Subject</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// make class abstract
</span><span class="p">};</span>

<span class="n">Subject</span><span class="o">::~</span><span class="n">Subject</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// dtor must have user-defined implementation (since declared pure virtual)
</span>
<span class="k">class</span> <span class="nc">Observer</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="n">notify</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Horserace</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Subject</span> <span class="p">{</span>
  <span class="n">ifstream</span> <span class="n">in</span><span class="p">;</span> <span class="c1">// get data from that file
</span>  <span class="n">string</span> <span class="n">winner</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Horserace</span><span class="p">(</span><span class="n">string</span> <span class="n">source</span><span class="p">)</span> <span class="o">:</span> <span class="n">in</span><span class="p">{</span><span class="n">source</span><span class="p">};</span>
  <span class="n">bool</span> <span class="n">race</span><span class="p">();</span> <span class="c1">// true if there was a race, false if EOF
</span>  <span class="n">string</span> <span class="nf">getState</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">winner</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Bettor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span> <span class="p">{</span>
  <span class="n">Horserace</span> <span class="o">*</span><span class="n">subject</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">myHorse</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Bettor</span><span class="p">(...)</span> <span class="p">...</span> <span class="p">{</span>
    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">notify</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">winner</span> <span class="o">=</span> <span class="n">subject</span><span class="o">-&gt;</span><span class="n">getState</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">winner</span> <span class="o">==</span> <span class="n">myHorse</span> <span class="o">?</span> <span class="s">"Win"</span> <span class="o">:</span> <span class="s">"Lose"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// main
</span><span class="n">Horserace</span> <span class="n">hr</span><span class="p">;</span>
<span class="n">Bettor</span> <span class="n">Larry</span><span class="p">(</span><span class="n">hr</span><span class="p">,</span> <span class="s">"Larry"</span><span class="p">,</span> <span class="s">"Pig4"</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="n">hr</span><span class="p">.</span><span class="n">race</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">hr</span><span class="p">.</span><span class="n">notifyObservers</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Simplifications</strong>:</p>

<ol>
  <li>If only one type of subject, could merge Subject and ConcreteSubject</li>
  <li>If state is trivial (so that just let notify tells you all you need to know), then don’t need getState()</li>
  <li>If subject = observer (e.g. cell in a grid in a spreadsheet), could merge these classes</li>
</ol>

<h2 id="decorator-pattern">Decorator Pattern</h2>

<ul>
  <li>Want to add features to an object at runtime</li>
</ul>

<p>E.g. Operating System: basic window, then add menu, then add scrollbar, and we want to change these at runtime</p>

<p>class component - interface - operations</p>

<p>You will provide</p>

<p>ConcreteComponent - implements the interface</p>

<p>Decorators all inherit from Decorator, which inherits Component. Thus every Decorator is a Component and every Decorator has a Component</p>

<p>A window with a scrollbar is a window, and has a pointer to the underlying plain window. Windw with scrollbar and menu is a window and has a pointer to a pointer to a window with scrollbar, which has a pointer to a plain window</p>

<p><br /></p>

<h2 id="june-29-2016---tutorial">June 29, 2016 - Tutorial</h2>

<p>protected: acts like private, but subclasses can access superclass fields; within the hierarchy</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Computer</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">makeCall</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Making call"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Testing"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Smartphone</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Computer</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">makeCall</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Mobile"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">testCall</span><span class="p">(</span><span class="n">Computer</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">c</span><span class="p">.</span><span class="n">test</span><span class="p">();</span>
  <span class="n">c</span><span class="p">.</span><span class="n">makeCall</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Smartphone</span> <span class="n">lmao</span><span class="p">;</span>
  <span class="n">testCall</span><span class="p">(</span><span class="n">lmao</span><span class="p">);</span>
  <span class="n">Computer</span> <span class="o">*</span><span class="n">laptop</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Smartphone</span><span class="p">;</span>
  <span class="n">laptop</span><span class="o">-&gt;</span><span class="n">makeCall</span><span class="p">();</span>
  <span class="n">lmao</span><span class="p">.</span><span class="n">makeCall</span><span class="p">();</span>
  <span class="n">lmao</span><span class="p">.</span><span class="n">test</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p><br /></p>

<h2 id="june-30-2016---lecture-18">June 30, 2016 - Lecture 18</h2>

<p><strong>Midterm got curved</strong>: Original average 49%, avergae after adjustment 66%</p>

<h2 id="design-pattern-template-method-pattern">Design Pattern: Template Method Pattern</h2>

<p>We want subclasses to override superclass behaviour, but some aspects must stay the same</p>

<ul>
  <li>A design pattern where we override some behaviour from a superclass, but not all of it - the superclass is used as a template for the subclass</li>
</ul>

<p>E.g. There are red and green turtles.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// superclass
</span><span class="k">class</span> <span class="nc">Turtle</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// method to draw turtle and its components
</span>    <span class="n">drawHead</span><span class="p">();</span>
    <span class="n">drawShell</span><span class="p">();</span>
    <span class="n">drawFeet</span><span class="p">();</span>
    <span class="c1">// note not virtual as the class is not abstract
</span>    <span class="c1">// thus not open for overriding
</span>    <span class="c1">// subclasses cannot change the fact that draw must
</span>    <span class="c1">// draw head, shell, and feet
</span>  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">drawHead</span><span class="p">();</span> <span class="c1">// not virtual, cannot override
</span>  <span class="kt">void</span> <span class="n">drawFeet</span><span class="p">();</span> <span class="c1">// not virtual, cannot override
</span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">drawShell</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// pure virtual
</span>  <span class="c1">// enables subclasses to override this method
</span>  <span class="c1">// gives subclasses a little bit of control
</span>  <span class="c1">// but not total control
</span><span class="p">};</span>

<span class="c1">// subclass
</span><span class="k">class</span> <span class="nc">RedTurtle</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">drawShell</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// virtual - override
</span>  <span class="c1">// draw red shell
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">GreenTurtle</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">drawShell</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span> <span class="c1">// draw green shell
</span><span class="p">};</span>
</code></pre>
</div>

<p>Class Turtle is like a boilerplate or a template, a fill-in-the-blank form. Has absolutely nothing to do with standard template library (STL). Subclasses cannot change the way a turtle is drawn, i.e. head, shell, feet, but they <strong>can</strong> change the way the shell is drawn.</p>

<p>Note: In the Turtle class, drawShell() is a private virtual function, but it is perfectly legal to override, not to call. Subclasses have to call their own drawShell().</p>

<p>Extension: The Non-Virtual Interface (NVI) Idiom</p>

<p>A public virtual method is really two things:</p>

<ul>
  <li>public: thus an interface to the client
    <ul>
      <li>indicates provided behaviour with pre/post conditions</li>
    </ul>
  </li>
  <li>virtual: thus an interace to subclasses
    <ul>
      <li>a “hook” to insert specialized behaviour</li>
    </ul>
  </li>
</ul>

<p>Hard to separate these ideas if they are tied to the same function</p>

<p>What if you later want to separate the customizable behaviour into 2 functions, maybe with some unchanging code in between? Without changing the public interface?</p>

<p>How can you make sure overriding functions respect pre/post conditions?</p>

<p><strong>The NVI idiom says:</strong></p>

<ul>
  <li>All public methods should be non-virtual</li>
  <li>All virtual methods should be private, or at least, protected</li>
  <li>Exception: Destructor</li>
</ul>

<p>Example:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DigitalMedia</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">play</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// In NVI:
// doPlay is a pass through function
</span><span class="k">class</span> <span class="nc">DigitalMedia</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">play</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// so we can control what happens here
</span>    <span class="n">doPlay</span><span class="p">();</span>
    <span class="c1">// and here
</span>    <span class="c1">// and not gonna be any slower, because the compiler will optimize as it sees fit
</span>  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doPlay</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>So now we can add before and after code.</p>

<p>E.g. Check copyright so I don’t get sued, update play count after the function call, or add another hook: showArt() = 0;</p>

<p>Extends Template Method - puts <strong>EVERY</strong> virtual function inside a template method.</p>

<h2 id="stl---maps--dictionaries">STL - Maps = Dictionaries</h2>

<p>E.g. “Arrays” that map string sto ints</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;map&gt;
</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="n">m</span><span class="p">[</span><span class="s">"abc"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">m</span><span class="p">[</span><span class="s">"def"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">[</span><span class="s">"ghi"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 0
// if key not present, it is inserted
// and value is default-constructed (for ints: 0)
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">[</span><span class="s">"abc"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 1
</span>
<span class="n">m</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="s">"abc"</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">"def"</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// the number is either 0 or 1
</span>  <span class="c1">// 0 means not found, and 1 means found
</span><span class="p">}</span>
</code></pre>
</div>

<p>Iterating over a map: sorted key order</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">// first is key, second is value
</span>  <span class="c1">// p's type is std::pair&lt;string, int&gt;&amp; (&lt;utility&gt;)
</span>  <span class="c1">// also, p.first and p.second are fields, not methods
</span>  <span class="c1">// not private fields?
</span>  <span class="c1">// Because no invariant, we can just expose the fields
</span><span class="p">}</span>
</code></pre>
</div>

<h2 id="tools-debugger-gdb">Tools: Debugger GDB</h2>

<p>To use: compile with -g (enable debugging information)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>g++14 -g myfile.cc
</code></pre>
</div>

<p>To run the debugger:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>gdb ./a.out
</code></pre>
</div>

<p>Commands:</p>

<ul>
  <li>r (run):
    <ul>
      <li>runs the program</li>
      <li>if the program crashes, it tells you the error</li>
    </ul>
  </li>
  <li>bt (backtrace): prints the chain of functions that got you here</li>
  <li>l (list): lists the source surrounding the current point of execution; gives you context</li>
  <li>p (print): prints the value of a variable or expression</li>
  <li>q (quit)</li>
</ul>

<p>Not all bugs are segfaults though.</p>

<p>Breakpoints: tell gdb to stop the program so you can see what is going on.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>break f
</code></pre>
</div>

<p>This says break when entering function f. Or,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>break myfile.cc:15
</code></pre>
</div>

<p>This says break on line 15.</p>

<ul>
  <li>s (step): runs one line</li>
  <li>c (continue): runs until the next breakpoint</li>
</ul>

<h2 id="design-pattern-visitor-pattern">Design Pattern: Visitor Pattern</h2>

<p>For implementing <strong>double dispatch</strong>.</p>

<p>Virtual method - chosen based on the actual type (at runtime) of the receiving object.</p>

<p>What if we want to choose based on two objects?</p>

<p>UML: Turtle -&gt; (hollow) Enemy &lt;-(hollow) Bullet<br />
Stick -&gt; (hollow) Weapon &lt;-(hollow) Rock</p>

<p>We want something like virtual void(Enemy, Weapon)::strike(); (not C++ though)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Enemy</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">beStruckBy</span><span class="p">(</span><span class="n">Weapon</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Weapon</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Enemy</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// each of these only does half the job
</span></code></pre>
</div>

<p>Trick to get dispatch on both:</p>

<ul>
  <li>Combine overriding with overloading</li>
</ul>

<p><strong>Override</strong> the virtual beStruckBy function:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Enemy</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">beStruckBy</span><span class="p">(</span><span class="n">Weapon</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// pure virtual
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Turtle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Enemy</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">beStruckBy</span><span class="p">(</span><span class="n">Weapon</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">w</span><span class="p">.</span><span class="n">strike</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// compiler knows *this is a Turtle
</span>  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Bullet</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Enemy</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">beStruckBy</span><span class="p">(</span><span class="n">Weapon</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">w</span><span class="p">.</span><span class="n">strike</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// compiler knows *this is a Bullet
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Now <strong>overload</strong> strike that takes in both Turtle ref and a Bullet ref:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Weapon</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Turtle</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Bullet</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Stick</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Weapon</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Turtle</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// strike a Turtle with a Stick
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Bullet</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// strike a Bullet with a Stick
</span>  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Rock</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Weapon</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Turtle</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// strike a Turtle with a Rock
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Bullet</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// strike a Turtle with a Rock
</span>  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ===================
// client
</span><span class="n">Enemy</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bullet</span><span class="p">;</span>
<span class="n">Weapon</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rock</span><span class="p">;</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">beStruckBy</span><span class="p">(</span><span class="o">*</span><span class="n">w</span><span class="p">);</span> <span class="c1">// strike a Bullet with a Rock
</span></code></pre>
</div>

<p>beStruckBy is a <strong>virtual method</strong>, so Bullet::beStruckBy() runs. That calls Weapon::strike, and *this is bullet, so Bullet version gets chosen by compiler. The virtual method resolves to Rock::strike(Bullet &amp;).</p>

<p><br /></p>

<h2 id="july-5-2016---lecture-19">July 5, 2016 - Lecture 19</h2>

<p>Recall: <strong>Visitor Pattern</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Enemy</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">beStruckBy</span><span class="p">(</span><span class="n">Weapon</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Turtle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Enemy</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">beStruckBy</span><span class="p">(</span><span class="n">Weapon</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">w</span><span class="p">.</span><span class="n">strike</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Weapon</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Turtle</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Bullet</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Stick</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Weapon</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Turtle</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="c1">// strike Turtle with Stick
</span>  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">strike</span><span class="p">(</span><span class="n">Bullet</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="c1">// strike Bullet with Stick
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Note:</strong> Visitor can be used to add functionality to existing classes without changing or recompiling the classes themselves.</p>

<p>E.g. Add a visitor to the Book hierarchy</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">BookVisitor</span> <span class="o">&amp;</span><span class="n">bv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bv</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Text</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">BookVisitor</span> <span class="o">&amp;</span><span class="n">bv</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">bv</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Comic</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Book</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">BookVisitor</span> <span class="o">&amp;</span><span class="n">bv</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">bv</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// BookVisitor
</span>
<span class="k">class</span> <span class="nc">BookVisitor</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Book</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Text</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Comic</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>In this example</strong>, accept is beStruckBy, visit is strike, Book is Enemy, and BookVisitor is Weapon.</p>

<p>Application: Track how many of each kind of book I have: Books (by author), Texts (by topic), and Comics (by hero). Use a <strong>map&lt;string, int&gt;</strong>.</p>

<p>Could add virtual void updateMap(…) to each class. Valid.</p>

<p>Or write a visitor:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Catalogue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BookVisitor</span> <span class="p">{</span>
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">theCat</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">getCatalogue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">theCat</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Book</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">theCat</span><span class="p">[</span><span class="n">b</span><span class="p">.</span><span class="n">getAuthor</span><span class="p">()];</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Text</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">theCat</span><span class="p">[</span><span class="n">t</span><span class="p">.</span><span class="n">getTopic</span><span class="p">()];</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Comic</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">theCat</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">getHero</span><span class="p">()];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Won't compile
</span></code></pre>
</div>

<p>Won’t compile! Why?</p>

<p>Book includes BookVisitor -&gt; includes Text -&gt; includes Book</p>

<ul>
  <li>Circular include dependency</li>
  <li>Book has an #include guard - won’t be included</li>
  <li>Text doesn’t know what Book is</li>
  <li>Are these includes really needed?</li>
</ul>

<h2 id="compilation-dependencies">Compilation Dependencies</h2>

<p>When does a compilantion dependency exist? (i.e. when do you need an include?)</p>

<p>Consider:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="n">A</span> <span class="n">myA</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="n">A</span> <span class="o">*</span><span class="n">myA</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">E</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span> <span class="n">x</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
</div>

<p><strong>IMPORTANT DISCUSSION</strong>: Which of them requires an include? Which of them can get away with a forward declaration?</p>

<p>Answer: B and C need an include (#include “a.h”), D and E do not. Compiler needs to know how big A is to know how big B and C is (B has an A inside it, C also has an A inside it).</p>

<p>For B and C, there is a compilation dependency. We need to know how big A is to know how big B and C are.</p>

<p>For D, you can forware declare (class A;), because all pointers are the same size. The compiler knows how big D is, it does not need to know how big A is.</p>

<p>For E, you can forward declare (class A;). Functions don’t contribute to the size of E. The function declaration is good enough for type checking. A is just mentioned for type checking.</p>

<p>If there is no compilation dependency necessitated by the code, then do not create one with extra #includes.</p>

<p>When class A changes, only A, B, C need to recompile.</p>

<p>Different story when you look at .cc implementation files. In the implementations of D and E:</p>

<p>d.cc</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include "a.h"
</span>
<span class="kt">void</span> <span class="n">D</span><span class="o">::</span><span class="n">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">myA</span><span class="o">-&gt;</span><span class="n">someMethod</span><span class="p">();</span>
  <span class="c1">// need to know about class A here - a true compilation dependency
</span>  <span class="c1">// needs to include a.h here, but not in E's header.
</span><span class="p">}</span>
</code></pre>
</div>

<p>Do the #include in the .cc, not in .h, where possible. Because including .h files in .cc, there would never be a cycle, because you never include .cc files. Reduces compilation cycle errors.</p>

<p>Now we will fix the visitor.</p>

<p>Now consider the XWindow class:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">XWindow</span> <span class="p">{</span>
  <span class="n">Display</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
  <span class="n">Window</span> <span class="n">w</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">GC</span> <span class="n">gc</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">colours</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

  <span class="c1">// private data above
</span>  <span class="c1">// Yet we can look at it
</span>  <span class="c1">// Do we know what it all means? Nei.
</span>  <span class="c1">// Do we care? Nei.
</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">//...
</span><span class="p">};</span>
</code></pre>
</div>

<p>What if I add or change a private member? Then all clients would have to recompile. That’s cumbersome! Would be better to hide these details away.</p>

<p><strong>Solution:</strong> pimpl idiom (pointer to implementation): create a second class XWindowImpl.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// XWindowImpl.h
</span><span class="cp">#include &lt;X11/Xlib.h&gt;
</span>
<span class="k">struct</span> <span class="n">XWindowImpl</span> <span class="p">{</span>
  <span class="n">Display</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
  <span class="n">Window</span> <span class="n">w</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">GC</span> <span class="n">gc</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">colours</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">};</span>


<span class="c1">// window.h
</span><span class="k">class</span> <span class="nc">XWindowImpl</span><span class="p">;</span> <span class="c1">// forward declare the Impl class
</span>
<span class="k">class</span> <span class="nc">XWindow</span> <span class="p">{</span>
  <span class="c1">// No need to include Xlib or X11
</span>  <span class="n">XWindowImpl</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span> <span class="c1">// No compilation dependency on XWindowImpl.h
</span>  <span class="c1">// and clients also don't depend on XWindowImpl.h
</span><span class="nl">public:</span>
  <span class="c1">// ... no change
</span><span class="p">};</span>


<span class="c1">// window.cc
</span><span class="cp">#include "window.h"
#include "XWindowImpl.h"
</span>
<span class="n">XWindow</span><span class="o">::</span><span class="n">XWindow</span><span class="p">(...)</span> <span class="o">:</span> <span class="n">pImpl</span><span class="p">{</span><span class="k">new</span> <span class="n">XWindowImpl</span><span class="p">}</span> <span class="p">{</span>
  <span class="c1">// MIL: need to allocate space for the pointer
</span>  <span class="c1">// Also need to destroy pImpl in the dtor
</span>  <span class="c1">// Other methods: replace fields (d, w, s, etc.) with pImpl-&gt;d, pImpl-&gt;w, pImpl-&gt;s, etc.
</span><span class="p">}</span>
</code></pre>
</div>

<p><strong>Note:</strong> If you confine all private fields to XWindowImpl, then only window.cc needs to recompile if you change XWindow’s implementation.</p>

<p>Generalization: What if there are several possible window implementations? Say XWindows and YWindows. Then make Impl struct a class.</p>

<p>Window (solid diamond) (pointer)-&gt; WindowImpl &lt;- (hollow diamond) XWindowImpl, YWindowImpl</p>

<p>pImpl idiom with hierarchy of implementations</p>

<ul>
  <li>called the <strong>Bridge pattern</strong></li>
</ul>

<p><br /></p>

<h2 id="july-7-2016---lecture-20">July 7, 2016 - Lecture 20</h2>

<h2 id="measure-of-design-quality">Measure of Design Quality</h2>

<ul>
  <li>Coupling and cohesion</li>
  <li>Coupling: The degree to which distinct program modules depend on each other</li>
  <li>Low: Modules communicate via function clalls with basic params/results
    <ul>
      <li>Modules pass arrays/structs back and forth</li>
      <li>Modules affect each other’s control flow</li>
      <li>Modules share global data</li>
    </ul>
  </li>
  <li>High: modules have access to each other’s implementation (friends)
    <ul>
      <li>High: changes to one module require greater changes to other modules</li>
      <li>Harder to reuse individual modules</li>
    </ul>
  </li>
  <li>Cohesion: how closely elements of a module are related to each other
    <ul>
      <li>Low
        <ul>
          <li>arbitrary grouping of unrelated elements (e.g. <utility>)</utility></li>
          <li>Elements share a common theme, otherwise unrelated</li>
          <li>Perhaps share the sane base code (e.g. <algorithm>)</algorithm></li>
          <li>Elements manipulate state over the lifetime of an object (e.g. open/read/close a file)</li>
          <li>Elements pass data to each other</li>
        </ul>
      </li>
      <li>High
        <ul>
          <li>Elements cooperate to perform exactly one task</li>
          <li>Perfect cohesion: put every single function in its separate module</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Low cohesion -&gt; poorly organized code -&gt; hard to understand and maintain</p>

<p>Goal: Low coupling, high cohesion</p>

<h2 id="decoupling-the-interface-mvc">Decoupling the Interface (MVC)</h2>

<p>Your primary program classes should not be printing things</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chessboard</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="c1">// there's a line of code like this
</span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Your move"</span><span class="p">;</span>
  <span class="c1">// BAD DESIGN
</span>  <span class="c1">// inhibits code reuse
</span><span class="p">};</span>
</code></pre>
</div>

<p>What if we want to reuse ChessBoard, but not have it communicate via stdout?</p>

<p>One solution: give the class <strong>stream</strong> objects, where it can perform input and output (I/O)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chessboard</span> <span class="p">{</span>
  <span class="n">istream</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">;</span>
  <span class="n">ostrema</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ChessBoard</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">in</span><span class="p">{</span><span class="n">in</span><span class="p">},</span> <span class="n">out</span><span class="p">{</span><span class="n">out</span><span class="p">}</span> <span class="p">{}</span>
  <span class="c1">// and now we will have this code instead:
</span>  <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"Your move"</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>What if we don’t want to use streams at all?</p>

<p>But ChessBoard shouldn’t be talking or doing any communication at all. Its job is to play chess.</p>

<h2 id="single-responsiblity-principle">Single-Responsiblity Principle</h2>

<p>“A class should have only one reason to change”</p>

<p>In the above example, game state AND communication are <strong>TWO</strong> reasons to change.</p>

<p>Better solution: Communication with the ChessBoard via parameters and results, and occasionally via exceptions.</p>

<p>Confine user communication to outside the game class.</p>

<p>Question: Should main do all the communication, and then call ChessBoard methods?</p>

<p>Answer: NO. Hard to reuse if it’s in main. Should have a class to manage interaction that is separate from the game state class</p>

<h2 id="pattern---model---view---controller-mvc">Pattern - Model - View - Controller (MVC)</h2>

<ul>
  <li>Separate the distinct notions of the data (or state), the presentation of the data, and the controll of the data.</li>
</ul>

<p>Example: ChessBoard</p>

<ul>
  <li>Model: the main data you are manipulating (e.g. game state)</li>
  <li>View: how the model is displayed to the user</li>
  <li>Controller: how the model is manipulated</li>
</ul>

<p>Model -&gt; Controller &lt;- View</p>

<p>Model:</p>

<ul>
  <li>Can have multiple views (e.g. text and graphics, or several graphics)</li>
  <li>Doesn’t need to know about their details</li>
  <li>Classic observer pattern (or could communicate through controller)</li>
</ul>

<p>Controller:</p>

<ul>
  <li>Mediates control flow between the model and view</li>
  <li>Might encapsulate turn-taking, or full game rules</li>
  <li>May communicate with user for input (or this could be the view)</li>
</ul>

<p>By decoupling presentation and control, MVC promotes reuse.</p>

<h2 id="exception-safety">Exception Safety</h2>

<p>Consider:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MyClass</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyClass</span><span class="p">;</span>
  <span class="n">MyClass</span> <span class="n">mc</span><span class="p">;</span>
  <span class="n">g</span><span class="p">();</span>
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>No leaks.</strong> But what if g raises an exception?</p>

<p>What is guaranteed?</p>

<ul>
  <li>During stack unwinding, all stack-allocated data is cleaned up - dtors run, memory reclaimed</li>
  <li>Heap-allocated memory is not freed</li>
</ul>

<p>Therefore, if g throws, *p is leaked, mc is not.</p>

<p><strong>Example Revisited</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MyClass</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyClass</span><span class="p">;</span>
  <span class="n">MyClass</span> <span class="n">mc</span><span class="p">;</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">throw</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Tedious, error-prone, duplication code</strong>. How else can we guarantee that something (e.g. delete p) happens no matter f exits now or exits due to an exception?</p>

<p>In some languages, “finally” clauses (in Java) guarantee certain final actions. NOT IN C++.</p>

<p>The only thing you can count on in C++ is that destructors for stack-allocated data will run.</p>

<p>Thus, use stack-alocated data with dtors as much as possible. Use the guarantee to your advantage.</p>

<p><strong>C++ Idiom: RAII - Resource Acquisition Is Initialization</strong></p>

<p>Every resource should be wrapped in a stack-allocated object whose dtor destroys it.</p>

<p>E.g. Files</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">h</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ifstream</span> <span class="n">f</span><span class="p">(</span><span class="s">"file"</span><span class="p">);</span> <span class="c1">// acquiring the resource, ("file")
</span>  <span class="c1">// initializing the object
</span>  <span class="c1">// ...
</span><span class="p">}</span>
</code></pre>
</div>

<p>File is guaranteed to be closed when f is popped from the stack (f’s dtor runs).</p>

<p>The same can be done with dynamic memory.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">std</span><span class="o">::</span><span class="n">unique</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// takes a T* in ctor
// dtor will free the pointer
// In-between - can dereference just like a pointer
</span>
<span class="cp">#include &lt;memory&gt;
</span></code></pre>
</div>

<p>Fix f():</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// allocate MyClass on the heap
</span>  <span class="n">MyClass</span> <span class="n">mc</span><span class="p">;</span>
  <span class="n">g</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This will not leak and is also safer. Also shorter.</p>

<p><br /></p>

<h2 id="july-12-2016---lecture-21">July 12, 2016 - Lecture 21</h2>

<p>Recall:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MyClass</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyClass</span><span class="p">;</span>
  <span class="n">MyClass</span> <span class="n">mc</span><span class="p">;</span>
  <span class="n">g</span><span class="p">();</span> <span class="c1">// a function that may throw
</span>  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// might leak
</span><span class="p">}</span>
</code></pre>
</div>

<p><strong>To fix using RAII</strong> with unique pointer:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="c1">// type is std::unique_ptr&lt;MyClass&gt;
</span>  <span class="n">g</span><span class="p">();</span> <span class="c1">// might throw
</span>  <span class="c1">// won't leak as stack destructor is called
</span><span class="p">}</span>
</code></pre>
</div>

<p><strong>Difficulty:</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="c1">//...
</span><span class="p">};</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">p</span> <span class="p">{</span><span class="k">new</span> <span class="n">C</span> <span class="p">{...}};</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</code></pre>
</div>

<p>What happens when a unique pointer is copied?</p>

<p>We don’t want to delete the same pointer twice! Segmentation fault.</p>

<p>Instead - copying is disabled for unique_ptrs.</p>

<p>So the truth is: The code above WILL NOT COMPILE. Unique_ptrs can only be moved, not copied.</p>

<p>We can write our own unique_ptr:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">unique</span><span class="n">_ptr</span> <span class="p">{</span>
  <span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span><span class="p">{</span><span class="n">p</span><span class="p">}</span> <span class="p">{}</span> <span class="c1">// ctor
</span>  <span class="o">~</span><span class="n">unique_ptr</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// dtor
</span>    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">unique_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="c1">// disable copy ctor
</span>
  <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="c1">// disable copy assignment
</span>
  <span class="c1">// but move ctor and assignment should be implemented
</span>  <span class="c1">// just like how it is usually done
</span>  <span class="c1">// as they don't affect the uniqueness
</span>
  <span class="c1">// move ctor
</span>  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="c1">// free other's data
</span>  <span class="p">}</span>

  <span class="c1">// move assignment opor
</span>  <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="n">opeartor</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// dereference operator
</span>  <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// operator arrow
</span>  <span class="n">T</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>If you want to be able to <strong>copy</strong> pointers, use std::shared_ptr</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">h</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// p2 popped, pointer is NOT deleted
</span><span class="p">}</span> <span class="c1">// p1 popped, pointer IS deleted
</span></code></pre>
</div>

<p>What is this magic? Shared pointers maintain a <strong>reference count</strong> (keep track among themselves the number of pointers pointing to the same object; reference count is a count of all shared_ptrs pointing at the same object). If the pointer realizes that itself is the only pointer pointing to an object, it will delete. i.e. Memory is freed when the last shared_ptr pointing at that object is freed.</p>

<p>Therefore, use shared_ptrs and unique_ptrs instead of raw pointers as much as possible! They solve the garbage collection problem. This means dramatically fewer opporitunities for leaks.</p>

<p><strong>3 levels of exception safety for a function f:</strong></p>

<ol>
  <li>Basic guarantee - if an exception occurs, the program will be in a valid state
    <ul>
      <li>nothing is leaked, class invariants maintained</li>
    </ul>
  </li>
  <li>Strong guarantee - if an exception is raised while executing f, the state of the program will be as if f had not been run</li>
  <li>No-throw guarantee - f will never throw or propagate an exception, because f will always succeed (it will always accomplish its task)</li>
</ol>

<p>Example:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{...};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="p">{...};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">.</span><span class="n">method1</span><span class="p">();</span> <span class="c1">// may throw - strong guarantee
</span>    <span class="n">b</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span> <span class="c1">// may throw - strong guarantee
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Is the function f in class C (C::f) exception safe?</p>

<ul>
  <li>If a.method1() throws - nothing has happened (OK) (f does propagate method1’s exception)</li>
  <li>If b.method2() throws - effects of method1 must be undone to offer the strong performance
    <ul>
      <li>Very hard or even imposible (what if method1 modified a global variable? Printed something to the screen? Launched a rocket?)</li>
      <li>Hard to undo method1 if method1 has non-local side-effects</li>
    </ul>
  </li>
</ul>

<p>Therefore, C::f is NOT exceotion safe.</p>

<p>But can we make it exception safe? That will require us to make an assumption: These methods do not have non-local side-effects.</p>

<p>If A::method1, B::method2 do not have non-local side effects, we can use copy and swap:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="c1">// ...
</span>  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// make temporary copies of a and b
</span>    <span class="n">A</span> <span class="n">aTemp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">B</span> <span class="n">bTemp</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

    <span class="c1">// operate on copies
</span>    <span class="n">aTemp</span><span class="p">.</span><span class="n">method1</span><span class="p">();</span> <span class="c1">// If these methods throw, what happens to the overall picture?
</span>    <span class="n">bTemp</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span> <span class="c1">// a and b will still be intact
</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">aTemp</span><span class="p">;</span> <span class="c1">// assign back
</span>    <span class="n">b</span> <span class="o">=</span> <span class="n">bTemp</span><span class="p">;</span>
    <span class="c1">// But what if copy assignment throws?
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Better if the swap was nothrow. Assigning/Copying/Moving/Swapping pointers will never and cannot throw!</p>

<p>So we can rephrase the code above, using the PImpl idiom.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CImpl</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CImpl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">CImpl</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">pImpl</span><span class="p">);</span> <span class="c1">// construct unique_ptr
</span>    <span class="n">temp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">method1</span><span class="p">();</span> <span class="c1">// if it throws, original object still intact
</span>    <span class="n">temp</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span> <span class="c1">// if it throws, original object still intact
</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">pImpl</span><span class="p">);</span> <span class="c1">// no throw, guaranteed
</span>    <span class="c1">// same if you use move assignment, in the case of using an unique_ptr
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>If either A::method1 or B::method2 offers <strong>no</strong> exception safety guarantee, then <strong>neither can f</strong>. It is impossible to construct a safe function out of unsafe pieces.</p>

<h2 id="exception-safety-and-the-stl-vectors">Exception Safety and the STL: Vectors</h2>

<p>How does exception safety apply to the most used thing in STL, vectors?<br />
Vectors:</p>

<ul>
  <li>encapsulate a heap-allocated array</li>
  <li>Follows <strong>RAII</strong> - When a stack-allocated vector goes out of scope, the internal heap-allocated memory is freed</li>
</ul>

<p>Example:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="c1">// ...
</span>  <span class="c1">// At the end of the function, v goes out of scope
</span>  <span class="c1">// array is freed, MyClass dtor runs on all objects in the array
</span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span> <span class="o">*&gt;</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// what if we have a vector of pointers?
</span>  <span class="c1">// ...
</span>  <span class="c1">// Array is freed, pointers don't have dtors
</span>  <span class="c1">// so any objects pointed at by pointers in v are NOT deleted
</span>  <span class="c1">// v doesn't know whether the pointers in the array own the objects they point at
</span>  <span class="c1">// e.g. ducks and pond analogy
</span>
  <span class="c1">// note it's not hard to delete
</span>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>But we don’t want to do cleanup ourselves!
<strong>Solution</strong>: use shared_ptrs!</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">h</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="c1">// ...
</span>  <span class="c1">// array is freed, shared_ptr dtors run,
</span>  <span class="c1">// so objects are deleted if no other shared_ptr points at them
</span>  <span class="c1">// don't have to do any explicit deallocation
</span><span class="p">}</span>
</code></pre>
</div>

<p>Another topic: emplace_back</p>

<ul>
  <li>Offers the <strong>strong guarantee</strong>
    <ul>
      <li>If the array is full (i.e. size == cap),
        <ul>
          <li>allocate new array</li>
          <li>copy the objects over (copy construction using copy ctor)
            <ul>
              <li>If a copy ctor throws, destroy the new array, old array is still intact, thus we can offer strong guarantee</li>
            </ul>
          </li>
          <li>delete old array</li>
        </ul>
      </li>
      <li>But copying an array is expensive and the old data will be thrown away! What a waste!</li>
      <li>Why don’t we <strong>move</strong> instead of <strong>copy</strong>?
        <ul>
          <li>allocate new array</li>
          <li>move objects over (move ctor)
            <ul>
              <li><strong>BUT! If move ctor throws, can’t offer strong guarantee, since the original is no longer intact</strong></li>
            </ul>
          </li>
          <li>delete old array</li>
        </ul>
      </li>
      <li>Therefore, if objects have a no-throw move, emplace_back will use move, else it will use copy (which is slower)</li>
      <li>So your move ops should be no-throw if possible</li>
    </ul>
  </li>
</ul>

<p>Example: Add keyword <strong>noexcept</strong> to tell vector that your move operators are no-throw</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">MyClass</span><span class="p">(</span><span class="n">MyClass</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="n">noexcept</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>

  <span class="n">MyClass</span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyClass</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="n">noexcept</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>This is the end of the exception safety topic.</p>

<p><br /></p>

<h2 id="july-14-2016---lecture-22">July 14, 2016 - Lecture 22</h2>

<p>Recall: emplace_back uses move ctor and assignment operator if they are no-throw, copy ctor if it throws. So make your move ctors and assignment operators no-throw if possible.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">MyClass</span><span class="p">(</span><span class="n">MyClass</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="n">noexcept</span> <span class="p">{</span>
    <span class="c1">//...
</span>    <span class="c1">// use the "noexcept" keyword to indicate no-throw
</span>  <span class="p">}</span>

  <span class="n">MyClass</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyClass</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="n">noexcept</span> <span class="p">{</span>
    <span class="c1">//...
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>At minimum: Moves and swaps should be noexcept (no-throw)</p>

<h2 id="casting">Casting</h2>

<p>Some C code!</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">Node</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span> <span class="c1">// cast
// cast forces C++ to treat a Node* as an int*
</span></code></pre>
</div>

<p>Casting: Forcing an object to be treated as another type. C-style casts should be avoided in C++.</p>

<p>Advantages of C++ casts:</p>

<ol>
  <li>C++ casts are easier to search and spot (C casts are hard to locate)</li>
  <li>Different categories of casts make code more readable (explicit); Also different casts have different intended usages</li>
  <li>Compiler would give warnings if you are doing something dumb (provides compiler and runtime errors, expose issues)</li>
</ol>

<p>If you <strong>must</strong> cast, use a C++ cast. There are 4 kinds of casting:</p>

<ol>
  <li>static_cast - “sensible casts”</li>
  <li>reinterpret_cast</li>
  <li>const_cast</li>
  <li>dynamic_cast</li>
</ol>

<p><strong>static_cast</strong> - relatively safe, sensible</p>

<p>E.g. static_cast: double-&gt;int</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">// the first one runs
</span>
<span class="c1">// now what if we want to run the second one?
</span><span class="n">f</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">));</span> <span class="c1">// cast the double to int
</span></code></pre>
</div>

<p>Superclass pointer -&gt; subclass pointer</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Text</span> <span class="p">{...};</span>
<span class="n">Text</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</code></pre>
</div>

<p>You are taking responsibility that b actually points at a Text.</p>

<p><strong>reinterpret_cast</strong> - unsafe, implementation-specific, “weird” conversions</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Student</span> <span class="n">s</span><span class="p">;</span>
<span class="n">Turtle</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Turtle</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</code></pre>
</div>

<p>It’s like making a bet. The only guaranteed thing: when you try to revert back to the old object, it will succeed.</p>

<p><strong>const_cast</strong> - for converting between const and non-const; the only C++ cast that can “cast away const”</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="c1">// g doesn't promise not the change *p
// but suppose g doesn't actually change *p (assumption)
</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// f promises not to change *p
</span>  <span class="c1">// ...
</span>  <span class="n">g</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// WRONG
</span>  <span class="n">g</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="n">p</span><span class="p">);</span> <span class="c1">// CORRECT
</span>  <span class="c1">// casting the constness away
</span><span class="p">}</span>
</code></pre>
</div>

<p><strong>dynamic_cast</strong> - Is it safe to convert a Book* to a Text*?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// don't know the right side
</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">pb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getTopic</span><span class="p">();</span> <span class="c1">// safe?
</span></code></pre>
</div>

<p>Is it safe?</p>

<p>Depends on what pb actually points at. Better to do a tentative cast, try it and see if it succeeds.</p>

<p>Use dynamic_cast:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Text</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>
</code></pre>
</div>

<p>If the cast works(i.e. pb points at a Text or a subclass of Text), then pt points at the object. If the cast fails, pt will be a nullptr. So we can check if the cast is successful by:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Text</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">getTopic</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Not a Text"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>static_cast is always faster. Sometimes static_cast costs very little, while using dynamic_cast costs a lot more during runtime.</p>

<p>But all of the above operates on raw pointers. We talked about smart pointers last class, should we use casts on smart pointers? Raw pointers are more integrated into the C++ type system. But the type system doesn’t know the relationship between a shared_ptr to Book and a shared_ptr to Text (these are our own classes). But smart pointers classes have their own versions.</p>

<p>The following cast shared_ptrs to shared_ptrs:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">static_pointer_cast</span>
<span class="n">const_pointer_cast</span>
<span class="n">dynamic_pointer_cast</span>
</code></pre>
</div>

<p>We can use dynamic casting to make decisions at runtime based on an object’s run-time type (<strong>RTTI = runtime type information</strong>)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">whatIsIt</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Book</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Text"</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">Comic</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Comic"</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Book"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Note: dynamic casting isn’t available for everybody. It only works on classes with at least one virtual method. A superclass should always have a virtual destructor (thus a virtual method), and as dynamic casting requires to know the entire class hierarchy, it only works on classes with a virtual method.</p>

<p>Note: Code like this is highly coupled to the Book class hierarchy and may indicated bad design. If I invent a new class (a subclass of Book), I have to update whatIsIt. So if whenever I add a subclass to an already existing class, I need to have knowledge of its implementation, that’s bad design.</p>

<p>Better 1 - write a virtual method, so when we add a new subclass of Book (say, CookBook), and override the whatIsIt method.</p>

<p>Better 2 - if the new subclass is a rare exception (i.e. not universally applicable), write a Visitor pattern. But visitor requries knowledge of the full implementation as well.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Book</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Text</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Comic</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// say if we want to add CookBook, we need to add this
</span><span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">CookBook</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre>
</div>

<p>So visitor is still tightly coupled, but it’s a little bit better than dynamic casting.</p>

<p>Dynamic casting also works on references.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Text</span> <span class="n">t</span> <span class="p">{...};</span>
<span class="n">Book</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="n">Text</span> <span class="o">&amp;</span><span class="n">t2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Text</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</code></pre>
</div>

<p>If b “points to” a Text, then t2 is a reference to the same Text. If not, (no such thing as a null reference) raises exception bad_cast.</p>

<p>With dynamic reference casting, we can solve the polymorphic assignment problem (think back: a week after we introduced inheritance: what happens to the Big 5 when we have inheritance?)</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="o">*</span><span class="n">pb1</span> <span class="o">=</span> <span class="o">*</span><span class="n">pb2</span><span class="p">;</span> <span class="c1">// when we don't have virtual methods
// we never wrote an assignment operator
</span></code></pre>
</div>

<p>Now we can write an assignment operator that takes in any Book and assign it to a Text:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Text</span> <span class="o">&amp;</span><span class="n">Text</span><span class="o">::</span><span class="n">opeartor</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// virtual
</span>  <span class="n">Text</span> <span class="o">*</span><span class="n">textOther</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Text</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">textOther</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// check for self-assignment
</span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Book</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
  <span class="n">topic</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">topic</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>How do I assign Text to any Book</strong> - solved.</p>

<p>What if other isn’t a Text? Exception bad_cast raised, the opeartion doens’t happen, the function goes back to the caller, and the caller deals with the inappropriate use.</p>

<h2 id="how-virtual-methods-work">How Virtual Methods Work</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vec</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Vec2</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>The two classes are virtually the same (pun intended), the only difference is the word “virtual”. What’s the actual difference?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Vec</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="n">Vec2</span> <span class="n">w</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="c1">// Do they look the same in memory?
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
<span class="c1">// prints
// 8 16
// v has size 8
// w has size 16
</span></code></pre>
</div>

<p>Not quite the same.</p>

<p><br /></p>

<h2 id="july-19-2016---lecture">July 19, 2016 - Lecture</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="k">new</span> <span class="p">{</span><span class="n">Book</span> <span class="n">Text</span> <span class="n">Comic</span><span class="p">};</span>
<span class="n">pb</span><span class="o">-&gt;</span><span class="n">isItHeavy</span><span class="p">();</span>
</code></pre>
</div>

<p>The choice of which version to run is based on the type of the actual object - not known until runtime</p>

<p>For each class with virtual methods, the compiler creates a table of function pointers (the <strong>vtable</strong>)</p>

<p>The <strong>virtual table</strong> (vtable) is a lookup table of functions used to resolve functions in a dynamic/late binding manner. The table is a static array that the compiler sets up at compile time. It contains one entry for each virtual function that can be called by objects of the class. Each entry is a function pointer that points to the most-derived function accessible by that class.</p>

<p>How it works:</p>

<ol>
  <li>Every class that uses virtual functions (or is derived from a class that has virtual functions) is given its own vtable</li>
  <li>The compiler adds a hidden pointer to the base class, which is the <strong>vptr</strong></li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">g</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">h</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">C</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// ======
</span><span class="n">C</span> <span class="n">c</span><span class="p">;</span>
</code></pre>
</div>

<p>The vtable would have f, g, and ~C pointing out to other functions outside the vtable</p>

<p>C objects have an extra pointer (the vptr) that points to C’s vtable</p>

<p>C has x, y, and a vptr -&gt; vtable (“C”, f, g, ~C)</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Book</span> <span class="n">b</span><span class="p">;</span>
<span class="n">Text</span> <span class="n">t</span><span class="p">;</span>
</code></pre>
</div>

<p>b has title, author, numPages, <strong>vptr</strong> (points to the vtable of Book, which contains isItHeavy pointer, which in turn points to the actual implementation of Book::isItHeavy)<br />
t has title, author, numPages, topic, <strong>vptr</strong> (points to the vtable of Text, which contains isItHeavy pointer, which in turn points to the actual implementation of Text::isItHeavy)</p>

<p>Calling a virtual method (all happens at runtime):</p>

<ul>
  <li>follow pointer to the vtable</li>
  <li>fetch pointer to actual method from table</li>
  <li>follow the function pointer and call the function</li>
</ul>

<p>Therefore, virtual function calls incur a small overhead cost.</p>

<p>Why isn’t destructor virtual by default? Classes not meant to be subclassed should not have virtual</p>

<p>C++: If you don’t need it, you don’t pay for it. Unless you actually need the functionality of virtual, it won’t give it to you.</p>

<p>Also: declaring at least one virtual function adds a vptr to the object. Therefore, classes with no virtual functions produce smaller objects (lower cost) than if some functions were virtual</p>

<p>Question: Why does dynamic casting (dynamic_cast) only work on classes with at least one virtual function? dynamic_cast needs to know what objects we actually have, and the compiler needs the vtable to figure out the type</p>

<p>A class that declares or inherits a virtual function is called a polymorphic class.</p>

<p>Concretely, how is an object laid out? It’s compiler-dependent.</p>

<p>g++:</p>

<p>A table of fields under vptr</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">f</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>For A, the layout would be vptr (a, c), and for B, vptr (a, c, b, d). Vptr is on the top of the table. A B object is an A object. So you will want your B object to look like an A object AND a B object simultaneously. So a pointer to B looks like a pointer to A, if you ignore the last two fields. We will always know where vptr is (first).</p>

<h2 id="multiple-inheritance">Multiple Inheritance</h2>

<p>A class can inherit from more than one class.</p>

<p>E.g.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">,</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">;</span>
    <span class="c1">// inherit a from A, b from B
</span>  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>UML:<br />
A &lt;- (hollow) C (hollow) -&gt; B</p>

<p>Challenges:</p>

<p>Suppose B inherits from A. And C inherits from A.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span><span class="p">,</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ============== main
</span><span class="n">D</span> <span class="n">dObj</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dObj</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>

<p>Compiler error: which a do you mean? You have one from virtually inheriting from B, or the one from C? “Request for ‘a’ is ambiguous”.</p>

<p>Need to specify:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">dObj</span><span class="p">.</span><span class="n">B</span><span class="o">::</span><span class="n">a</span><span class="p">;</span> <span class="c1">// OR
</span><span class="n">dObj</span><span class="p">.</span><span class="n">C</span><span class="o">::</span><span class="n">a</span><span class="p">;</span>
</code></pre>
</div>

<p>But if B and C inherit from A, should there be one A part of D, or two?
  + Should B::a and C::a be the same or different?
  + Default behaviour: two</p>

<p>What if we want “The Deadly Diamond”? A on the top, B and C on left and right, and D inherit from both B and C. Make A a virtual base class, employ virtual inheritance.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="p">};</span>
</code></pre>
</div>

<p>E.g. I/O stream hierarchy</p>

<p>ios_base
|
ios
  | istream (virtual inheritance) ———–
    | istringstream     iostream (inherit from istream, ostream) —fstream, stringstream
    | ifstream
  | ostream (virtual inheritance) ———–
    | ostringstream
    | ofstream</p>

<p>How will this be laid out?</p>

<p>What does g++ do?</p>

<p>Multiple inheritance: initialization of the virtual base class is the responsiblity of the bottom of the class hierarchy.</p>

<p>Diagaram doesn’t look like all of A, B, C, D simultaneously, but slices of it do look like A, B, C, D.</p>

<p>Therefore pointer assignment among A, B, C, D changes the address stored in the pointer.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">D</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
<span class="n">A</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// changes the address
</span></code></pre>
</div>

<p>static_cast, const_cast, dynamic_cast under multiple inheritance will also change the value of the pointer. BUT reinterpret_cast WILL NOT. That’s why reinterpret_cast is dangerous.</p>

<h2 id="template-functions">Template Functions</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// T is int, the compiler figures it out
</span><span class="p">}</span>
</code></pre>
</div>

<p>Note: Don’t need to say min<int>, just min is fine. C++ can infer T=int from the types of x and y. This applies to function templates only.</int></p>

<p><br /></p>

<h2 id="july-20-2016---tutorial">July 20, 2016 - Tutorial</h2>

<p>Smart pointers are good for exception safety because they manage memory automatically, so we can avoid memory leaks when a function throws.</p>

<h2 id="exception-safety-1">Exception Safety</h2>

<p>3 Guarantees: Basic, Strong</p>

<ul>
  <li>Basic Guarantee: “a valid state” -&gt; the object after the exception throws will still be valid, but with some unknown effects</li>
  <li>Strong Guarantee: The state that used to be it; Undone</li>
  <li>No-throw Guarantee: Will not throw an exception; difficult to get. Almost never happens unless with primitive types</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">try</span> <span class="p">{</span>
  <span class="n">o</span><span class="p">.</span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="n">o</span><span class="p">.</span><span class="n">g</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<ul>
  <li>Basic - o is a valid object, but it might have changed after f(). The program will not crash, and you can still use o (invariants of the object are preserved and no resources are leaked)</li>
  <li>Strong - it’s like you never called o.f(); “all-or-nothing”. As if the try catch block and o.f() didn’t happen</li>
</ul>

<h2 id="casting-1">Casting</h2>

<ul>
  <li>dynamic_cast: RTTI = Runtime type information. dynamic_cast checks if it makes sense to convert from one type to another. Only casts when the cast makes sense</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">A</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
</code></pre>
</div>

<ul>
  <li>static_cast: taking control from compiler; C-style casting; sensible</li>
  <li>reinterpret_cast: here’s a piece of memory, reinterpret it to a different type. Destroying C++ built-in checks and type information. Used in system engineering</li>
  <li>const_cast: const in read-only memory; if someone by mistake, forgot the const keyword; prevent the non-constness from propagating through multiple functions</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">Student</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">grade</span><span class="p">();</span>
  <span class="c1">// not modifying s, so should be const
</span><span class="p">}</span>

<span class="kt">void</span> <span class="n">prettyprint</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Grade: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">grade</span><span class="p">();</span>
  <span class="c1">// incompatible with &lt;&lt;
</span>  <span class="c1">// so you would const_cast s, to cast away the constness
</span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Grade: "</span> <span class="o">&lt;&lt;</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Student</span> <span class="o">&amp;&gt;</span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="stl">STL</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">for_each</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
<span class="c1">// begin, end, apply the function
// acts exactly like map
</span></code></pre>
</div>
